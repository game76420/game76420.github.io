<!DOCTYPE html>
<!-- saved from url=(0043)file:///E:/user/Desktop/code%20(12)%20.html -->
<html lang="zh-TW"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>五子棋 AI 對戰 (可視化版)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background-color: #f0f0f0;
            margin: 0;
            padding: 15px;
            touch-action: manipulation;
            /* min-height: 100vh; */ /* 移除，避免手機滑動時棋盤消失 */
            /* overflow-x: hidden; */ /* 移除，避免內容被裁切 */
        }
        h1 {
            color: #333;
            text-align: center;
        }
        #game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100vw; /* 新增：讓容器寬度等於螢幕 */
            max-width: 100vw; /* 新增：防止超出 */
            box-sizing: border-box;
        }
        #board-container {
            position: relative;
            width: 90vw;
            max-width: 600px;
            aspect-ratio: 1 / 1; /* 新增：確保正方形 */
            background-color: #dcb35c;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto; /* 新增：置中 */
            overflow: hidden; /* 新增：防止 canvas 溢出 */
        }
        #chess-board {
            width: 100% !important;
            height: 100% !important;
            max-width: 100vw;
            max-height: 90vw;
            display: block;
            margin: 0 auto;
            box-sizing: border-box;
            background: transparent;
        }
        #chess-board.thinking {
            cursor: wait;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 250px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #ai-status {
            background-color: #eef2f7;
            border-left: 4px solid #4a90e2;
            padding: 10px;
            border-radius: 4px;
            color: #333;
            font-size: 14px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        button, select {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        button:disabled, select:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background-color: #e9e9e9;
        }
        button:active:not(:disabled) {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        #new-game-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
        }
        #new-game-btn:hover:not(:disabled) {
            background-color: #45a049;
        }
        #undo-btn {
            background-color: #f44336;
            color: white;
            border: none;
        }
        #undo-btn:hover:not(:disabled) {
            background-color: #da190b;
        }
        /* --- 新增: 提示按鈕樣式 --- */
        #hint-btn {
            background-color: #008CBA;
            color: white;
            border: none;
        }
        #hint-btn:hover:not(:disabled) {
            background-color: #007B9A;
        }
        /* --- 新增: 棋局紀錄樣式 --- */
        #move-log-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #move-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #copy-log-btn {
            padding: 5px 10px;
            font-size: 12px;
            background-color: #6c757d;
            color: white;
            border: none;
        }
        #copy-log-btn:hover:not(:disabled) {
            background-color: #5a6268;
        }
        #move-log {
            width: 100%;
            height: 150px;
            font-family: monospace;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px;
            resize: vertical;
            background-color: #f8f9fa;
        }
        /* 響應式：手機板棋盤置中且不裁切 */
        @media (max-width: 600px) {
            #game-container {
                flex-direction: column;
                gap: 10px;
                align-items: center; /* 新增：置中 */
            }
            #board-container {
                width: 100vw !important;
                height: 100vw !important;
                max-width: 100vw !important;
                max-height: 100vw !important;
                aspect-ratio: 1 / 1;
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            #chess-board {
                width: 100vw !important;
                height: 100vw !important;
                max-width: 100vw !important;
                max-height: 100vw !important;
                display: block;
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
        }
    </style>
</head>
<body>

    <h1>五子棋 AI 對戰 (可視化版)</h1>

    <div id="game-container">
        <div id="board-container">
            <canvas id="chess-board" width="554" height="554" class=""></canvas>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>AI 狀態:</label>
                <div id="ai-status">黑棋 勝利!</div>
            </div>

            <div class="control-group">
                <button id="new-game-btn">開啟新局</button>
                <button id="undo-btn">悔棋</button>
                <button id="hint-btn">AI 提示</button> <!-- 新增: 提示按鈕 -->
                <!-- <button id="auto-play-btn">AI接管</button> --> <!-- 已移除: AI接管按鈕 -->
            </div>

            <div class="control-group">
                <label for="difficulty">選擇難度：</label>
                <select id="difficulty">
                    <option value="1">新手 (深度 1)</option>
                    <option value="2" selected="">簡單 (深度 2)</option>
                    <option value="3">普通 (深度 3)</option>
                    <option value="4">困難 (深度 4)</option>
                    <option value="5">專家 (深度 5)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="player-first">誰先手？</label>
                <select id="player-first">
                    <option value="true">玩家先手 (黑棋)</option>
                    <option value="false">AI 先手 (白棋)</option>
                </select>
            </div>
            
            <!-- --- 新增: 棋局紀錄區塊 --- -->
            <div id="move-log-container" class="control-group">
                <div id="move-log-header">
                    <label for="move-log">棋局紀錄:</label>
                    <button id="copy-log-btn">複製紀錄</button>
                </div>
                <ul id="move-log" style="height: 150px; overflow-y: auto; font-family: monospace; font-size: 12px; border: 1px solid #ccc; border-radius: 4px; padding: 5px; background-color: #f8f9fa; margin: 0;"><li data-index="1" style="cursor: pointer;">#1: 玩家 (黑棋) 落子于 (9, 9)</li><li data-index="2" style="cursor: pointer;">#2: AI (白棋) 落子于 (8, 8)</li><li data-index="3" style="cursor: pointer;">#3: 玩家 (黑棋) 落子于 (9, 7)</li><li data-index="4" style="cursor: pointer;">#4: AI (白棋) 落子于 (9, 8)</li><li data-index="5" style="cursor: pointer;">#5: 玩家 (黑棋) 落子于 (10, 8)</li><li data-index="6" style="cursor: pointer;">#6: AI (白棋) 落子于 (8, 6)</li><li data-index="7" style="cursor: pointer;">#7: 玩家 (黑棋) 落子于 (11, 7)</li><li data-index="8" style="cursor: pointer;">#8: AI (白棋) 落子于 (8, 10)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手活三威脅，封鎖於 (8, 10)</li><li data-index="9" style="cursor: pointer;">#9: 玩家 (黑棋) 落子于 (12, 6)</li><li data-index="10" style="cursor: pointer;">#10: AI (白棋) 落子于 (13, 5)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手死四威脅，封鎖於 (13, 5)</li><li data-index="11" style="cursor: pointer;">#11: 玩家 (黑棋) 落子于 (12, 7)</li><li data-index="12" style="cursor: pointer;">#12: AI (白棋) 落子于 (10, 7)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手活三威脅，封鎖於 (10, 7)</li><li data-index="13" style="cursor: pointer;">#13: 玩家 (黑棋) 落子于 (8, 9)</li><li data-index="14" style="cursor: pointer;">#14: AI (白棋) 落子于 (8, 5)</li><li data-index="15" style="cursor: pointer;">#15: 玩家 (黑棋) 落子于 (10, 9)</li><li data-index="16" style="cursor: pointer;">#16: AI (白棋) 落子于 (7, 9)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手活三威脅，封鎖於 (7, 9)</li><li data-index="17" style="cursor: pointer;">#17: 玩家 (黑棋) 落子于 (11, 9)</li><li data-index="18" style="cursor: pointer;">#18: AI (白棋) 落子于 (12, 9)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手死四威脅，封鎖於 (12, 9)</li><li data-index="19" style="cursor: pointer;">#19: 玩家 (黑棋) 落子于 (11, 8)</li><li data-index="20" style="cursor: pointer;">#20: AI (白棋) 落子于 (9, 10)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手活三威脅，封鎖於 (9, 10)</li><li data-index="21" style="cursor: pointer;">#21: 玩家 (黑棋) 落子于 (11, 10)</li><li data-index="22" style="cursor: pointer;">#22: AI (白棋) 落子于 (11, 6)</li><li style="font-size: 11px; color: rgb(183, 28, 28); background: rgb(255, 253, 231); margin-left: 1em;">  └ 偵測到對手活四威脅，封鎖於 (11, 6)</li></ul>
                <div id="replay-controls" style="display: flex; gap: 10px; margin-top: 8px;">
                  <button id="replay-play-btn">播放</button>
                  <button id="replay-pause-btn" disabled="">暫停</button>
                  <button id="replay-stop-btn" disabled="">停止</button>
                </div>
            </div>
        </div>
    </div>
    
    <script id="ai-worker" type="javascript/worker">
        // Worker 內部代碼與上一個版本幾乎相同
        // 唯一的關鍵改動是在 onmessage 中處理新的命令 getHint
        const GRID_SIZE = 19;
        let board = [];
        let playerIsBlack = true;
        let moveHistory = [];
        let zobristTable = [];
        let transpositionTable = new Map();
        
        function initZobrist() {
            zobristTable = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill(0).map(() => [
                    Math.floor(Math.random() * 2**32),
                    Math.floor(Math.random() * 2**32)
                ])
            );
        }
        
        function computeHash(currentBoard) {
            let h = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (currentBoard[y][x] !== 0) {
                        h ^= zobristTable[y][x][currentBoard[y][x] - 1];
                    }
                }
            }
            return h;
        }
        
        function findBestMove(depth, player) {
            let bestScore = -Infinity;
            let move = null;
            let reason = null;
            const moves = getPossibleMoves();

            if (moves.length === 0) return null;
            if (moveHistory.length === 0) return { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2), reason: "首手佔中" };

            const opponent = player === 1 ? 2 : 1;
            const hash = computeHash(board);
            transpositionTable.clear();

            const scoredMoves = moves.map(([y, x]) => {
                board[y][x] = player;
                const score = evaluateBoard(board, { x, y });
                board[y][x] = 0;
                return { x, y, score };
            });

            // 1. 自己五連
            for (const { x, y } of scoredMoves) {
                board[y][x] = player;
                if (checkWin(x, y, player, board)) {
                    board[y][x] = 0;
                    return { x, y, reason: `主動進攻，形成五連於 (${y}, ${x})` };
                }
                board[y][x] = 0;
            }
            // 2. 對手五連
            for (const { x, y } of scoredMoves) {
                board[y][x] = opponent;
                if (checkWin(x, y, opponent, board)) {
                    board[y][x] = 0;
                    return { x, y, reason: `偵測到對手五連威脅，封鎖於 (${y}, ${x})` };
                }
                board[y][x] = 0;
            }
            // 3. 對手活四
            for (const { x, y } of scoredMoves) {
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, opponent, board);
                    if (info.count === 3 && info.openEnds === 2) {
                        // 對手活四 = 對手有三子且兩端皆空
                        return { x, y, reason: `偵測到對手活四威脅，封鎖於 (${y}, ${x})` };
                    }
                }
            }
            // 4. 對手死四
            for (const { x, y } of scoredMoves) {
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, opponent, board);
                    if (info.count === 4 && info.openEnds === 1) {
                        return { x, y, reason: `偵測到對手死四威脅，封鎖於 (${y}, ${x})` };
                    }
                }
            }
            // 5. 自己活四
            for (const { x, y } of scoredMoves) {
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, player, board);
                    if (info.count === 3 && info.openEnds === 2) {
                        return { x, y, reason: `主動進攻，形成活四於 (${y}, ${x})` };
                    }
                }
            }
            // 6. 對手雙活三
            for (const { x, y } of scoredMoves) {
                let doubleLiveThreeCount = 0;
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, opponent, board);
                    if (info.count === 3 && info.openEnds === 2) {
                        doubleLiveThreeCount++;
                    }
                }
                if (doubleLiveThreeCount >= 2) {
                    return { x, y, reason: `偵測到對手雙活三威脅，封鎖於 (${y}, ${x})` };
                }
            }
            // 7. 對手活三
            for (const { x, y } of scoredMoves) {
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, opponent, board);
                    if (info.count === 2 && info.openEnds === 2) {
                        return { x, y, reason: `偵測到對手活三威脅，封鎖於 (${y}, ${x})` };
                    }
                }
            }
            // 8. 自己活三
            for (const { x, y } of scoredMoves) {
                for (const [dx, dy] of [[1,0],[0,1],[1,1],[1,-1]]) {
                    const info = getLineInfo(x, y, dx, dy, player, board);
                    if (info.count === 2 && info.openEnds === 2) {
                        return { x, y, reason: `主動進攻，形成活三於 (${y}, ${x})` };
                    }
                }
            }
            // 9. 其他分支（原本的 minimax 評分）
            const topMoves = scoredMoves.sort((a, b) => b.score - a.score).slice(0, 20);
            let count = 0;
            for (const { x, y } of topMoves) {
                const newHash = hash ^ zobristTable[y][x][player - 1];
                board[y][x] = player;
                const score = minimax(depth - 1, -Infinity, Infinity, false, opponent, newHash, { x, y, player });
                board[y][x] = 0;
                if (score > bestScore) {
                    bestScore = score;
                    move = { x, y };
                }
                if (count % 5 === 0) {
                    self.postMessage({
                        type: 'progress',
                        data: {
                            currentlyChecking: { x, y },
                            bestMoveSoFar: move,
                            bestScoreSoFar: bestScore,
                        }
                    });
                }
                count++;
            }
            return { ...move, reason: null };
        }

        // --- 其他 AI 函式 (minimax, evaluateBoard, checkWin 等) 保持不變 ---
        function checkWin(x, y, player, currentBoard) {
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            for (const [dx, dy] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === player) count++; else break;
                }
                for (let i = 1; i < 5; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === player) count++; else break;
                }
                // 只判斷恰好五連珠，不包含六連珠以上
                if (count === 5) return true;
            }
            return false;
        }
        function minimax(depth, alpha, beta, isMaximizing, player, currentHash, lastMove) {
            const cached = transpositionTable.get(currentHash);
            if (cached && cached.depth >= depth) return cached.score;

            if (lastMove && checkWin(lastMove.x, lastMove.y, lastMove.player || player, board)) {
                return lastMove.player === (playerIsBlack ? 2 : 1) ? 1000000 + depth : -(1000000 + depth);
            }

            if (depth === 0) return evaluateBoard(board, lastMove);
            const moves = getPossibleMoves();
            if (moves.length === 0) return 0;

            const opponent = player === 1 ? 2 : 1;
            let bestEval = isMaximizing ? -Infinity : Infinity;

            // 評估走法以排序
            const scoredMoves = moves.map(([y, x]) => {
                board[y][x] = player;
                const score = evaluateBoard(board, { x, y });
                board[y][x] = 0;
                return { x, y, score };
            }).sort((a, b) => isMaximizing ? b.score - a.score : a.score - b.score);

            // 限制走法數量，防止爆炸（可調整）
            const limitedMoves = scoredMoves.slice(0, 15);

            for (const { x, y } of limitedMoves) {
                board[y][x] = player;
                moveHistory.push({ x, y, player });

                const newHash = currentHash ^ zobristTable[y][x][player - 1];
                const evalScore = minimax(depth - 1, alpha, beta, !isMaximizing, opponent, newHash, { x, y, player });

                board[y][x] = 0;
                moveHistory.pop();

                if (isMaximizing) {
                    bestEval = Math.max(bestEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                } else {
                    bestEval = Math.min(bestEval, evalScore);
                    beta = Math.min(beta, evalScore);
                }

                if (beta <= alpha) break;
            }

            // 只記錄高深度評估
            const prev = transpositionTable.get(currentHash);
            if (!prev || prev.depth < depth) {
                transpositionTable.set(currentHash, { depth, score: bestEval });
            }

            return bestEval;
        }
        function getPossibleMoves() {
            const moves = new Set();
            if (moveHistory.length === 0) {
                moves.add(`${Math.floor(GRID_SIZE/2)},${Math.floor(GRID_SIZE/2)}`);
                return Array.from(moves).map(s => s.split(',').map(Number));
            }
            const range = 2;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] !== 0) {
                        for (let i = -range; i <= range; i++) {
                            for (let j = -range; j <= range; j++) {
                                const nx = x + j; const ny = y + i;
                                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === 0) {
                                    moves.add(`${ny},${nx}`);
                                }
                            }
                        }
                    }
                }
            }
            return Array.from(moves).map(s => s.split(',').map(Number));
        }
        function evaluateBoard(currentBoard, lastMove) {
            const aiPlayer = playerIsBlack ? 2 : 1;
            const humanPlayer = playerIsBlack ? 1 : 2;

            return calculateTotalScore(currentBoard, aiPlayer)
                 - calculateTotalScore(currentBoard, humanPlayer) * 1.5;
        }

        function calculateTotalScore(board, player) {
            let total = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] === player) {
                        total += calculateScoreForMove({ x, y }, player, board);
                    }
                }
            }
            return total;
        }
        function calculateScoreForMove(move, player, currentBoard) {
            if (!move) return 0;
            const {x, y} = move;
            let score = 0;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            directions.forEach(([dx, dy]) => {
                score += getScoreFromLine(getLineInfo(x, y, dx, dy, player, currentBoard));
            });
            return score;
        }
        function getLineInfo(x, y, dx, dy, player, currentBoard) {
            let count = 0;
            // 向一側
            let nx = x + dx, ny = y + dy;
            while (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === player) {
                count++;
                nx += dx; ny += dy;
            }
            let openEnds = 0;
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === 0) openEnds++;

            // 另一側
            nx = x - dx; ny = y - dy;
            while (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === player) {
                count++;
                nx -= dx; ny -= dy;
            }
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && currentBoard[ny][nx] === 0) openEnds++;

            return { count, openEnds };
        }
        function getScoreFromLine({count, openEnds}){
            if (count === 5) return 1000000;
            if (count === 4) { if (openEnds === 1) return 100000; if (openEnds === 0) return 1000; }
            if (count === 3 && openEnds === 1) return 0; // 死三不加分，AI永遠不擋死三
            if (count === 3 && openEnds === 2) return 5000;
            if (count === 2) { if (openEnds === 2) return 100; if (openEnds === 1) return 10; }
            if(count === 1 && openEnds === 2) return 1;
            return 0;
        }

        // 新增：取得威脅線上所有棋子與兩端空點座標（不包含偵測點本身）
        function getThreatLine(x, y, dx, dy, count, player, board) {
            let line = [];
            // 向負方向找空點
            let px = x, py = y;
            while (true) {
                const nx = px - dx, ny = py - dy;
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === player) {
                    px = nx; py = ny;
                } else {
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === 0) {
                        line.push({ x: nx, y: ny, type: 'empty' });
                    }
                    break;
                }
            }
            // 正方向棋子（不包含偵測點本身）
            let cx = px, cy = py;
            let added = 0;
            while (added < count) {
                if ((cx !== x || cy !== y) && cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE && board[cy][cx] === player) {
                    line.push({ x: cx, y: cy, type: 'stone' });
                    added++;
                }
                cx += dx; cy += dy;
            }
            // 正方向空點
            if (cx >= 0 && cx < GRID_SIZE && cy >= 0 && cy < GRID_SIZE && board[cy][cx] === 0) {
                line.push({ x: cx, y: cy, type: 'empty' });
            }
            return line;
        }

        self.onmessage = function(e) {
            const { command, data } = e.data;
            if (command === 'init') {
                initZobrist();
            } else if (command === 'calculateMove' || command === 'getHint') { // --- 修改: 同時處理下棋和提示 ---
                board = data.board;
                playerIsBlack = data.playerIsBlack;
                moveHistory = data.moveHistory;
                const aiPlayer = playerIsBlack ? 2 : 1; // AI 是黑棋 (1) 還是白棋 (2)
                
                const bestMove = findBestMove(data.difficulty, aiPlayer);
                
                // --- 修改: 根據不同命令回傳不同類型的訊息 ---
                if (command === 'calculateMove') {
                    self.postMessage({ type: 'finalResult', data: bestMove });
                } else { // command === 'getHint'
                    self.postMessage({ type: 'hintResult', data: bestMove });
                }
            }
        };
    </script>

    <script>
        const canvas = document.getElementById('chess-board');
        const ctx = canvas.getContext('2d');
        const newGameBtn = document.getElementById('new-game-btn');
        const undoBtn = document.getElementById('undo-btn');
        const difficultySelect = document.getElementById('difficulty');
        const playerFirstSelect = document.getElementById('player-first');
        const aiStatusDiv = document.getElementById('ai-status');
        const hintBtn = document.getElementById('hint-btn'); // 新增
        const moveLogTextarea = document.getElementById('move-log'); // 新增
        const copyLogBtn = document.getElementById('copy-log-btn'); // 新增
        const autoPlayBtn = document.getElementById('auto-play-btn'); // 新增


        const GRID_SIZE = 19;
        let board = [];
        let moveHistory = [];
        let playerIsBlack = true;
        let isPlayerTurn = true;
        let gameOver = false;
        let cellSize;
        let previewPos = null;
        let aiWorker = null;
        
        let aiThinkingData = null;
        let hintMove = null; // --- 新增: 存儲 AI 提示的位置 ---
        let lastAIMove = null; // --- 新增: 記錄 AI 最後下棋位置 ---
        // let autoPlayMode = false; // --- 已移除: AI自動下棋模式 ---
        // --- 新增: 棋局重播相關變數 ---
        let isReplaying = false;
        let replayIndex = 0;
        let replayTimer = null;
        let originalBoard = null;
        let originalMoveHistory = null;
        // --- 新增: 棋局跳步功能相關變數 ---
        let fullMoveHistory = [];
        let currentStep = null;

        function initAIWorker() {
            if (window.Worker) {
                const workerScript = document.getElementById('ai-worker').textContent;
                const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
                aiWorker = new Worker(URL.createObjectURL(workerBlob));
                
                aiWorker.onmessage = function(e) {
                    const { type, data } = e.data;
                    
                    if (type === 'progress') {
                        updateAIProgressVisualization(data);
                    } else if (type === 'finalResult') {
                        const bestMove = data;
                        if(bestMove) {
                            // 將 reason 一起傳給 makeMove
                            makeMove(bestMove.x, bestMove.y, isPlayerTurn ? (playerIsBlack ? 1 : 2) : (playerIsBlack ? 2 : 1), bestMove.reason);
                            updateMoveRecord();
                            if (bestMove.reason) {
                                aiStatusDiv.textContent = bestMove.reason;
                            }
                        }
                        setThinking(false);
                    } else if (type === 'hintResult') { // --- 新增: 處理提示結果 ---
                        setThinking(false);
                        const bestMove = data;
                        // if (autoPlayMode && bestMove) {
                        //     makeMove(bestMove.x, bestMove.y, isPlayerTurn ? (playerIsBlack ? 1 : 2) : (playerIsBlack ? 2 : 1));
                        //     if (!gameOver && autoPlayMode) {
                        //         setTimeout(autoPlay, 300);
                        //     }
                        // } else {
                        hintMove = bestMove;
                        aiStatusDiv.textContent = 'AI 提示已標出';
                        redrawAll();
                        // }
                    }
                };
                
                aiWorker.postMessage({ command: 'init' });
            } else {
                console.error('您的瀏覽器不支持 Web Workers，性能可能較差。');
            }
        }
        
        function updateAIProgressVisualization(data) {
            aiThinkingData = data;
            aiStatusDiv.innerHTML = `思考中...<br>當前最佳分數: ${data.bestScoreSoFar}`;
            redrawAll();
        }
        
        function clearAIVisualization() {
            aiThinkingData = null;
            aiStatusDiv.textContent = isPlayerTurn ? '等待玩家落子...' : '遊戲結束';
            redrawAll();
        }

        function setThinking(thinking) {
            // 只根據 thinking 控制悔棋按鈕，不再考慮 gameOver
            // undoBtn.disabled = thinking;
            [newGameBtn, difficultySelect, playerFirstSelect, hintBtn].forEach(el => el.disabled = thinking);
            canvas.classList.toggle('thinking', thinking);
            if (!thinking) {
                clearAIVisualization();
            }
        }
        
        function redrawAll() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard();
            drawPieces();
            drawLastAIMoveMarker(); // --- 新增: 標示 AI 剛剛下的位置 ---
            drawHintMarker(); // --- 新增: 繪製提示標記 ---
            drawPreviewMarker();
            drawAIThinkingMarkers();
        }
        
        // --- 新增: 繪製 AI 提示位置的標記 ---
        function drawHintMarker() {
            if (!hintMove) return;
            const { x, y } = hintMove;
            const markerX = cellSize * (x + 1);
            const markerY = cellSize * (y + 1);

            ctx.save();
            ctx.strokeStyle = '#FFD700'; //金色
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(markerX, markerY, cellSize/2.5, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
        }

        // --- 新增: 標示 AI 剛剛下的位置 ---
        function drawLastAIMoveMarker() {
            if (!lastAIMove) return;
            const { x, y } = lastAIMove;
            const markerX = cellSize * (x + 1);
            const markerY = cellSize * (y + 1);

            ctx.save();
            ctx.strokeStyle = '#FF3333'; // 紅色
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(markerX, markerY, cellSize/2.2, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
        }

        function drawAIThinkingMarkers() {
            if (!aiThinkingData) return;

            const { currentlyChecking, bestMoveSoFar, threatType, threatPos } = aiThinkingData;

            if (currentlyChecking) {
                const { x, y } = currentlyChecking;
                const markerX = cellSize * (x + 1);
                const markerY = cellSize * (y + 1);
                ctx.fillStyle = 'rgba(0, 100, 255, 0.4)';
                ctx.strokeStyle = 'rgba(0, 100, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.rect(markerX - cellSize/2, markerY - cellSize/2, cellSize, cellSize);
                ctx.fill();
                ctx.stroke();
            }

            if (threatType && threatPos) {
                const { x, y } = threatPos;
                const markerX = cellSize * (x + 1);
                const markerY = cellSize * (y + 1);
                let color = '#FFD700'; // 預設金色
                if (threatType === '活四') color = '#FF5722';
                else if (threatType === '死四') color = '#9C27B0';
                else if (threatType === '雙活三') color = '#2196F3';
                else if (threatType === '活三') color = '#4CAF50';
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(markerX, markerY, cellSize/2.1, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
                // 狀態區顯示
                aiStatusDiv.innerHTML = `AI 正在檢查 <b>${threatType}</b> 威脅於 (${y}, ${x})...`;
            }
            if (bestMoveSoFar) {
                const { x, y } = bestMoveSoFar;
                const markerX = cellSize * (x + 1);
                const markerY = cellSize * (y + 1);
                ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(markerX, markerY, cellSize/3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }
        }

        function initBoard() {
            fullMoveHistory = []; // 新增：清空完整棋譜紀錄
            currentStep = null;   // 新增：清空跳步狀態
            // 動態計算高度
            const vw = Math.min(window.innerWidth, 600);
            const size = vw * 0.9;
            const dpr = window.devicePixelRatio || 1;
            const boardContainer = document.getElementById('board-container');
            boardContainer.style.width = size + 'px';
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            cellSize = size / (GRID_SIZE + 1);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            moveHistory = [];
            gameOver = false;
            previewPos = null;
            hintMove = null; // --- 新增: 清除提示 ---
            lastAIMove = null; // --- 新增: 清除 AI 最後下棋位置 ---
            clearAIVisualization();
            updateMoveRecord(); // --- 新增: 清空紀錄 ---
            redrawAll();
        }

        function startGame() {
            fullMoveHistory = []; // 新增：新局時也清空完整棋譜紀錄
            currentStep = null;   // 新增：新局時也清空跳步狀態
            initBoard();
            playerIsBlack = playerFirstSelect.value === 'true';
            isPlayerTurn = playerIsBlack;
            aiStatusDiv.textContent = isPlayerTurn ? '等待玩家落子...' : 'AI 思考中...';
            if (!isPlayerTurn) {
                setTimeout(aiMove, 500); 
            }
        }
        
        function makeMove(x, y, player, reason) {
            if (board[y][x] !== 0) return;
            
            if (!isPlayerTurn) {
                clearAIVisualization();
                lastAIMove = { x, y }; // --- 新增: AI 下棋時記錄 ---
            } else {
                lastAIMove = null; // --- 新增: 玩家下棋時清除 ---
            }
            hintMove = null; // --- 新增: 玩家或AI下棋後，清除提示 ---

            board[y][x] = player;
            // 將 reason 一起存入 moveHistory
            moveHistory.push({x, y, player, reason});
            updateMoveRecord(); // --- 新增: 更新紀錄 ---
            previewPos = null;
            redrawAll();

            if (checkWin(x, y, player)) {
                gameOver = true;
                setThinking(false);
                const winnerText = `${player === 1 ? '黑棋' : '白棋'} 勝利!`;
                aiStatusDiv.textContent = winnerText;
                setTimeout(() => alert(winnerText), 100);
                return;
            }

            if (moveHistory.length === GRID_SIZE * GRID_SIZE) {
                gameOver = true;
                aiStatusDiv.textContent = '平局!';
                setTimeout(() => alert('平局!'), 100);
                return;
            }

            isPlayerTurn = !isPlayerTurn;
            aiStatusDiv.textContent = isPlayerTurn ? '等待玩家落子...' : 'AI 思考中...';
            if (!isPlayerTurn && !gameOver) {
                aiMove();
            }
        }
        
        function undoMove() {
            if (moveHistory.length === 0) return; // 允許任何時候悔棋
            const minMoves = playerIsBlack ? 0 : 1;
            if (moveHistory.length <= minMoves) return;
            for(let i=0; i < 2 && moveHistory.length > 0; i++){
                const lastMove = moveHistory.pop();
                if(lastMove){ board[lastMove.y][lastMove.x] = 0; }
            }
            // 重新判斷遊戲是否結束，悔棋後一律恢復為未結束
            gameOver = false;
            // 根據moveHistory最後一步決定輪到誰
            if (moveHistory.length === 0) {
                isPlayerTurn = playerIsBlack;
            } else {
                const last = moveHistory[moveHistory.length - 1];
                // 如果最後一步是AI，則輪到玩家
                isPlayerTurn = ((playerIsBlack && last.player === 2) || (!playerIsBlack && last.player === 1));
            }
            aiStatusDiv.textContent = isPlayerTurn ? '等待玩家落子...' : 'AI 思考中...';
            hintMove = null; // --- 新增: 悔棋後清除提示 ---
            lastAIMove = null; // --- 新增: 悔棋後清除 AI 最後下棋位置 ---
            clearAIVisualization();
            updateMoveRecord(); // --- 新增: 更新紀錄 ---
            redrawAll();
        }

        function aiMove() {
            if (gameOver) return;
            setThinking(true);
            aiStatusDiv.textContent = 'AI 開始思考...';
            aiWorker.postMessage({
                command: 'calculateMove',
                data: {
                    board: board,
                    playerIsBlack: playerIsBlack,
                    moveHistory: moveHistory,
                    difficulty: parseInt(difficultySelect.value)
                }
            });
        }
        
        // --- 新增: 請求 AI 提示的函式 ---
        function requestHint() {
            if (gameOver || !isPlayerTurn) return;
            setThinking(true);
            aiStatusDiv.textContent = 'AI 正在為您建議...';
            // AI 需要知道當前玩家是誰，才能為玩家計算最佳落子點
            const currentPlayer = playerIsBlack ? 1 : 2; 
            aiWorker.postMessage({
                command: 'getHint',
                data: {
                    board: board,
                    playerIsBlack: !playerIsBlack, // 傳入相反的設定，讓AI以為自己是現在的玩家
                    moveHistory: moveHistory,
                    difficulty: parseInt(difficultySelect.value)
                }
            });
        }
        
        // --- 新增: 更新棋局紀錄的函式，支援點擊跳步 ---
        function updateMoveRecord() {
            // 若在重播或跳步狀態，顯示 fullMoveHistory，否則顯示 moveHistory
            const logList = document.getElementById('move-log');
            const history = (fullMoveHistory.length > 0) ? fullMoveHistory : moveHistory;
            logList.innerHTML = '';
            history.forEach((move, index) => {
                const moveNumber = index + 1;
                const playerColor = move.player === 1 ? '黑棋' : '白棋';
                let playerType;
                if ((playerIsBlack && move.player === 1) || (!playerIsBlack && move.player === 2)) {
                    playerType = '玩家';
                } else {
                    playerType = 'AI';
                }
                const li = document.createElement('li');
                li.textContent = `#${moveNumber}: ${playerType} (${playerColor}) 落子于 (${move.y}, ${move.x})`;
                li.setAttribute('data-index', index + 1);
                li.style.cursor = 'pointer';
                if (currentStep === index + 1) {
                    li.style.background = '#ffe082';
                    li.style.fontWeight = 'bold';
                }
                logList.appendChild(li);
                // 顯示 reason
                if (move.reason) {
                    const reasonLi = document.createElement('li');
                    reasonLi.textContent = `  └ ${move.reason}`;
                    reasonLi.style.fontSize = '11px';
                    reasonLi.style.color = '#b71c1c';
                    reasonLi.style.background = '#fffde7';
                    reasonLi.style.marginLeft = '1em';
                    logList.appendChild(reasonLi);
                }
            });
            logList.scrollTop = logList.scrollHeight;
        }

        // --- 新增: 點擊棋譜跳步功能 ---
        document.getElementById('move-log').addEventListener('click', function(e) {
            if (e.target.tagName.toLowerCase() === 'li') {
                const step = parseInt(e.target.getAttribute('data-index'));
                showStep(step);
            }
        });

        // --- 新增: 還原棋盤到指定步數的函式 ---
        function showStep(step) {
            if (!fullMoveHistory.length) return;
            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            moveHistory = [];
            for (let i = 0; i < step; i++) {
                const move = fullMoveHistory[i];
                board[move.y][move.x] = move.player;
                moveHistory.push(move);
            }
            currentStep = step;
            updateMoveRecord();
            redrawAll();
        }

        // --- 新增: 棋局重播控制函式 ---
        function startReplay() {
            if (moveHistory.length === 0 || isReplaying) return;
            isReplaying = true;
            replayIndex = 0;
            originalBoard = board.map(row => row.slice());
            originalMoveHistory = moveHistory.slice();
            board = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            moveHistory = [];
            setReplayButtons(true);
            redrawAll();
            replayStep();
        }
        function replayStep() {
            if (!isReplaying || replayIndex >= originalMoveHistory.length) {
                stopReplay();
                return;
            }
            const move = originalMoveHistory[replayIndex];
            board[move.y][move.x] = move.player;
            moveHistory.push(move);
            updateMoveRecord();
            redrawAll();
            replayIndex++;
            replayTimer = setTimeout(replayStep, 500); // 0.5秒一手
        }
        function pauseReplay() {
            if (!isReplaying) return;
            clearTimeout(replayTimer);
            setReplayButtons(false, true);
        }
        function resumeReplay() {
            if (!isReplaying) return;
            setReplayButtons(true);
            replayStep();
        }
        function stopReplay() {
            isReplaying = false;
            clearTimeout(replayTimer);
            if (originalBoard && originalMoveHistory) {
                board = originalBoard.map(row => row.slice());
                moveHistory = originalMoveHistory.slice();
                updateMoveRecord();
                redrawAll();
            }
            setReplayButtons(false, false, true);
        }
        function setReplayButtons(playing, paused, stopped) {
            replayPlayBtn.disabled = playing;
            replayPauseBtn.disabled = !playing;
            replayStopBtn.disabled = !playing && !paused;
        }

        function checkWin(x, y, player) {
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            for (const [dx, dy] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) { const nx = x + i * dx, ny = y + i * dy; if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === player) count++; else break; }
                for (let i = 1; i < 5; i++) { const nx = x - i * dx, ny = y - i * dy; if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && board[ny][nx] === player) count++; else break; }
                if (count === 5) return true;
            }
            return false;
        }
        function getBoardCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            // 計算 canvas 實際像素與 CSS 像素的縮放比例
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            // 轉換為 canvas 內部座標
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            return { boardX: Math.round(x / cellSize) - 1, boardY: Math.round(y / cellSize) - 1 };
        }
        canvas.addEventListener('click', (e) => {
            if (!isPlayerTurn) return; // 移除 gameOver 限制
            const { boardX, boardY } = getBoardCoordinates(e);
            if (boardX >= 0 && boardX < GRID_SIZE && boardY >= 0 && boardY < GRID_SIZE) {
                makeMove(boardX, boardY, playerIsBlack ? 1 : 2);
            }
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isPlayerTurn) return; // 移除 gameOver 限制
            const { boardX, boardY } = getBoardCoordinates(e);
            if (boardX >= 0 && boardX < GRID_SIZE && boardY >= 0 && boardY < GRID_SIZE) {
                if (!previewPos || previewPos.x !== boardX || previewPos.y !== boardY) {
                    previewPos = { x: boardX, y: boardY };
                    redrawAll();
                }
            } else { if (previewPos) { previewPos = null; redrawAll(); } }
        });
        canvas.addEventListener('mouseout', () => { if (previewPos) { previewPos = null; redrawAll(); } });
        
        // --- 新增: 綁定棋局重播按鈕事件 ---
        const replayPlayBtn = document.getElementById('replay-play-btn');
        const replayPauseBtn = document.getElementById('replay-pause-btn');
        const replayStopBtn = document.getElementById('replay-stop-btn');
        replayPlayBtn.addEventListener('click', () => {
            if (isReplaying && !replayPauseBtn.disabled) {
                resumeReplay();
            } else {
                startReplay();
            }
        });
        replayPauseBtn.addEventListener('click', pauseReplay);
        replayStopBtn.addEventListener('click', stopReplay);

        // 在新局、悔棋、AI自動等操作時，記得呼叫 stopReplay 以避免重播狀態混亂
        function safeStopReplay() {
            if (isReplaying) stopReplay();
            syncFullMoveHistory(); // 新增：同步 fullMoveHistory
        }
        newGameBtn.addEventListener('click', () => {
            safeStopReplay();
            startGame();
        });
        undoBtn.addEventListener('click', () => {
            safeStopReplay();
            undoMove();
        });
        hintBtn.addEventListener('click', requestHint); // --- 新增 ---

        // --- 新增: 複製按鈕功能 ---
        copyLogBtn.addEventListener('click', () => {
            // 取得所有 li 的文字
            const logList = document.getElementById('move-log');
            const items = Array.from(logList.querySelectorAll('li'));
            const text = items.map(li => li.textContent).join('\n');
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyLogBtn.textContent;
                copyLogBtn.textContent = '已複製!';
                copyLogBtn.disabled = true;
                setTimeout(() => {
                    copyLogBtn.textContent = originalText;
                    copyLogBtn.disabled = false;
                }, 1500);
            }).catch(err => {
                console.error('複製失敗: ', err);
                alert('複製失敗，您的瀏覽器可能不支援此功能。');
            });
        });

        // --- 新增: 只調整棋盤尺寸的函式 ---
        function resizeBoardCanvas() {
            const vw = window.innerWidth;
            const size = vw; // 直接用螢幕寬度
            const dpr = window.devicePixelRatio || 1;
            const boardContainer = document.getElementById('board-container');
            boardContainer.style.width = size + 'px';
            boardContainer.style.height = size + 'px';
            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            cellSize = size / (GRID_SIZE + 1);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
            redrawAll();
        }
        // window.addEventListener('resize', initBoard);
        window.addEventListener('resize', resizeBoardCanvas); // 只調整尺寸，不重設棋局
        initAIWorker();
        startGame();

        // --- 省略了未變動的繪圖函式 ---
        function drawBoard() {
            ctx.fillStyle = '#dcb35c'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
            // 讓棋盤網格線置中
            for (let i = 0; i < GRID_SIZE; i++) {
                // 垂直線
                ctx.beginPath();
                ctx.moveTo(cellSize * (i + 1), cellSize);
                ctx.lineTo(cellSize * (i + 1), cellSize * GRID_SIZE);
                ctx.stroke();
                // 水平線
                ctx.beginPath();
                ctx.moveTo(cellSize, cellSize * (i + 1));
                ctx.lineTo(cellSize * GRID_SIZE, cellSize * (i + 1));
                ctx.stroke();
            }
            // 星位點
            const starPoints = [ {x: 3, y: 3}, {x: 9, y: 3}, {x: 15, y: 3}, {x: 3, y: 9}, {x: 9, y: 9}, {x: 15, y: 9}, {x: 3, y: 15}, {x: 9, y: 15}, {x: 15, y: 15} ];
            ctx.fillStyle = '#333';
            starPoints.forEach(p => { ctx.beginPath(); ctx.arc(cellSize * (p.x + 1), cellSize * (p.y + 1), cellSize / 5, 0, 2 * Math.PI); ctx.fill(); });
        }
        function drawPieces() {
            for (let y = 0; y < GRID_SIZE; y++) { for (let x = 0; x < GRID_SIZE; x++) { if (board[y][x] !== 0) drawPiece(x, y, board[y][x]); } }
        }
        function drawPiece(x, y, player) {
            ctx.beginPath();
            const radius = cellSize / 2 * 0.9; const pieceX = cellSize * (x + 1); const pieceY = cellSize * (y + 1);
            const gradient = ctx.createRadialGradient(pieceX - radius * 0.2, pieceY - radius * 0.2, radius * 0.1, pieceX, pieceY, radius);
            if (player === 1) { gradient.addColorStop(0, '#666'); gradient.addColorStop(1, '#000'); } else { gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ddd'); }
            ctx.fillStyle = gradient; ctx.arc(pieceX, pieceY, radius, 0, 2 * Math.PI); ctx.fill();
        }
        function drawPreviewMarker() {
            if (!previewPos || !isPlayerTurn) return; // 移除 gameOver 限制
            const { x, y } = previewPos;
            if (board[y][x] !== 0) return;
            const player = playerIsBlack ? 1 : 2;
            ctx.globalAlpha = 0.5; drawPiece(x, y, player); ctx.globalAlpha = 1.0;
        }

        function autoPlay() {
            if (gameOver) {
                return;
            }
            setThinking(true);
            aiStatusDiv.textContent = 'AI自動下棋中...';
            // 根據isPlayerTurn決定目前輪到哪一方
            const currentPlayerIsBlack = isPlayerTurn ? playerIsBlack : !playerIsBlack;
            aiWorker.postMessage({
                command: 'getHint',
                data: {
                    board: board,
                    playerIsBlack: currentPlayerIsBlack,
                    moveHistory: moveHistory,
                    difficulty: parseInt(difficultySelect.value)
                }
            });
        }

        // --- 修改: makeMove, undoMove, startGame, stopReplay, safeStopReplay, aiMove, autoPlay, startReplay, stopReplay, resumeReplay, pauseReplay ---
        // 使 fullMoveHistory 與 moveHistory 保持同步，並在正常下棋時取消跳步高亮
        function syncFullMoveHistory() {
            fullMoveHistory = moveHistory.slice();
            currentStep = null;
        }
        // 修改 makeMove
        const _originalMakeMove = makeMove;
        makeMove = function(x, y, player, reason) {
            _originalMakeMove(x, y, player, reason);
            syncFullMoveHistory();
            updateUndoBtnState();
        };
        // 修改 undoMove
        const _originalUndoMove = undoMove;
        undoMove = function() {
            _originalUndoMove();
            syncFullMoveHistory();
            updateMoveRecord(); // <-- 新增這行，確保棋譜刷新
            updateUndoBtnState();
        };
        // 修改 startGame
        const _originalStartGame = startGame;
        startGame = function() {
            _originalStartGame();
            // syncFullMoveHistory(); // <-- 移除這行，避免新局時又把 moveHistory 複製到 fullMoveHistory
            updateUndoBtnState();
        };
        // 修改 stopReplay
        const _originalStopReplay = stopReplay;
        stopReplay = function() {
            _originalStopReplay();
            syncFullMoveHistory();
            updateUndoBtnState();
        };
        // 在新局、悔棋、AI自動等操作時，safeStopReplay 也同步 fullMoveHistory
        function safeStopReplay() {
            if (isReplaying) stopReplay();
            syncFullMoveHistory();
        }
        // 在重播開始時，fullMoveHistory 設為 moveHistory 的快照
        const _originalStartReplay = startReplay;
        startReplay = function() {
            fullMoveHistory = moveHistory.slice();
            currentStep = null;
            _originalStartReplay();
        };
        // 在重播暫停/繼續時，保持高亮
        const _originalPauseReplay = pauseReplay;
        pauseReplay = function() {
            _originalPauseReplay();
            currentStep = replayIndex;
            updateMoveRecord();
        };
        const _originalResumeReplay = resumeReplay;
        resumeReplay = function() {
            _originalResumeReplay();
            currentStep = null;
            updateMoveRecord();
        };

        // 初始化時也要設置
        updateUndoBtnState();

        // 新增：悔棋按鈕狀態控制函式，只在 AI 思考時 disable
        function updateUndoBtnState() {
            // undoBtn 只在 AI 思考時不能按，遊戲結束也能悔棋
            // undoBtn.disabled = canvas.classList.contains('thinking') || moveHistory.length === 0;
            undoBtn.disabled = moveHistory.length === 0;
        }

    </script>

</body></html> 
