<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, minimum-scale=0.5, user-scalable=yes">
    <title>äº”å­æ£‹AIæ¸¸æˆ - é˜²å®ˆå¼ºåŒ–ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            color: #fff;
            overflow-x: hidden;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            width: 100%;
            background: rgba(25, 25, 35, 0.85);
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        .header {
            background: rgba(15, 15, 25, 0.95);
            padding: 15px;
            text-align: center;
            border-bottom: 2px solid #fdbb2d;
        }
        
        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(45deg, #fdbb2d, #b21f1f);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .header p {
            color: #ddd;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            padding: 15px;
        }
        
        .game-board-container {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .board-wrapper {
            width: 100%;
            max-width: 95vw;
            margin: 0 auto;
            position: relative;
            background: #dcb35c;
            border-radius: 4px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            border: 2px solid #8B4513;
            overflow: hidden;
        }
        
        #boardCanvas {
            width: 100%;
            height: auto;
            display: block;
            touch-action: pan-x pan-y pinch-zoom;
        }
        
        .controls-sidebar {
            width: 100%;
            padding: 15px;
            background: rgba(35, 35, 45, 0.8);
            border-radius: 10px;
            margin-top: 10px;
        }
        
        .panel {
            background: rgba(25, 25, 35, 0.9);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #444;
        }
        
        .panel h2 {
            font-size: 1.3rem;
            margin-bottom: 12px;
            color: #fdbb2d;
            display: flex;
            align-items: center;
        }
        
        .panel h2 i {
            margin-right: 8px;
        }
        
        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .btn {
            background: linear-gradient(to bottom, #4a6ea9, #2a4a7e);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            flex: 1;
            min-width: 100px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        .btn:hover {
            background: linear-gradient(to bottom, #5a7eb9, #3a5a9e);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .btn.active {
            background: linear-gradient(to bottom, #fdbb2d, #e0a000);
            color: #1a1a2e;
            font-weight: 600;
        }
        
        .btn.warning {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
        }
        
        .btn.warning:hover {
            background: linear-gradient(to bottom, #f39c12, #e67e22);
        }
        
        .slider-container {
            margin: 12px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 6px;
            color: #ddd;
            font-size: 0.95rem;
        }
        
        .difficulty-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fdbb2d;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .status-indicators {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            flex-wrap: wrap;
        }
        
        .indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
            margin: 5px;
        }
        
        .indicator-value {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 3px;
        }
        
        .history-panel {
            max-height: 150px;
            overflow-y: auto;
        }
        
        .history-item {
            padding: 6px 10px;
            background: rgba(50, 50, 60, 0.6);
            border-radius: 5px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .history-item:hover {
            background: rgba(70, 70, 80, 0.8);
        }
        
        .ai-thinking {
            display: none;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            min-width: 260px;
            max-width: 90vw;
            background: rgba(0,0,0,0.85);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            padding: 32px 24px 24px 24px;
            z-index: 30;
            text-align: center;
            color: #fff;
            font-size: 1rem;
        }
        .ai-thinking .progress-container {
            margin: 18px 0 8px 0;
        }
        .ai-thinking .progress-bar {
            height: 10px;
        }
        .ai-thinking .progress-text {
            margin-bottom: 8px;
        }
        .ai-thinking p {
            margin: 6px 0;
        }
        
        .progress-container {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 8px;
            background: linear-gradient(90deg, #2ecc71, #3498db, #9b59b6);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
            position: relative;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .progress-text {
            font-size: 0.85rem;
            color: #ddd;
            margin-top: 5px;
        }
        
        .thinking-animation {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #fdbb2d;
            margin: 0 2px;
            animation: pulse 1.5s infinite;
        }
        
        .thinking-animation:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .thinking-animation:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 1; }
        }
        
        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            z-index: 10;
            border: 3px solid #fdbb2d;
            width: 90%;
            max-width: 350px;
        }
        
        .win-message.hidden {
            display: none !important;
            pointer-events: none !important;
        }
        
        .win-message h2 {
            font-size: 1.8rem;
            margin-bottom: 15px;
            color: #fdbb2d;
        }
        
        .win-message p {
            font-size: 1.1rem;
            margin-bottom: 20px;
        }
        
        .highlight {
            position: absolute;
            background: rgba(253, 187, 45, 0.3);
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
            animation: highlight-pulse 2s infinite;
        }
        
        @keyframes highlight-pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 0.9; }
        }
        
        .difficulty-indicator {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            background: #4a6ea9;
            font-size: 0.8rem;
            margin-left: 6px;
            color: white;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (min-width: 768px) {
            .main-content {
                flex-direction: row;
            }
            
            .controls-sidebar {
                width: 300px;
                margin-left: 15px;
                margin-top: 0;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .btn {
                padding: 10px 15px;
                font-size: 1rem;
            }
        }
        
        @media (min-width: 992px) {
            .game-board-container {
                min-width: 500px;
            }
            
            .board-wrapper {
                max-width: 600px;
            }
        }
        
        /* ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– */
        .mobile-optimization {
            display: none;
            text-align: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #fdbb2d;
        }
        
        .ai-features {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid rgba(46, 204, 113, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }
        
        .ai-features h3 {
            color: #2ecc71;
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .ai-features ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .ai-features li {
            color: #ddd;
            font-size: 0.85rem;
            margin-bottom: 4px;
            padding-left: 15px;
            position: relative;
        }
        
        .ai-features li:before {
            content: "âœ“";
            color: #2ecc71;
            position: absolute;
            left: 0;
            font-weight: bold;
        }
        
        .threat-warning {
            color: #e74c3c !important;
            font-weight: bold;
        }
        
        .defense-active {
            color: #f39c12 !important;
            font-weight: bold;
        }
        
        .last-move-indicator {
            animation: lastMovePulse 2s infinite;
        }
        
        @keyframes lastMovePulse {
            0%, 100% { 
                stroke-width: 3;
                stroke-opacity: 1;
            }
            50% { 
                stroke-width: 5;
                stroke-opacity: 0.7;
            }
        }
        
        @media (max-width: 480px) {
            .header {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .main-content {
                padding: 10px;
            }
            
            .game-board-container {
                padding: 10px;
            }
            
            .panel {
                padding: 12px;
            }
            
            .mobile-optimization {
                display: block;
            }
        }
        
        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            z-index: 20;
            display: none;
            border: 2px solid #fdbb2d;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .zoom-indicator.zooming {
            animation: zoomPulse 1s infinite;
        }
        
        @keyframes zoomPulse {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.05);
                opacity: 0.8;
            }
        }
        
        .corner-warning {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            z-index: 20;
            display: none;
        }
        
        .threat-defense-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(231, 76, 60, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            z-index: 20;
            display: none;
            animation: threatPulse 1.5s infinite;
        }
        
        @keyframes threatPulse {
            0%, 100% { 
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.5);
            }
            50% { 
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>äº”å­æ£‹AIæ¸¸æˆ - é˜²å®ˆå¼ºåŒ–ç‰ˆ</h1>
            <p>AIè½å­ä¼˜åŒ– + æ´»ä¸‰è‡ªåŠ¨é˜²å®ˆ + æ™ºèƒ½å¨èƒæ£€æµ‹</p>
        </div>
        
        <div class="main-content">
            <div class="game-board-container">
                <div class="board-wrapper">
                    <div class="zoom-indicator" id="zoomIndicator">ğŸ–ï¸ åŒæŒ‡ç¼©æ”¾ä¸­</div>
                    <div class="corner-warning" id="cornerWarning">âš ï¸ AIæ£€æµ‹åˆ°è§’è½è½å­</div>
                    <div class="threat-defense-indicator" id="threatIndicator">ğŸ›¡ï¸ AIæ­£åœ¨é˜²å®ˆæ´»ä¸‰å¨èƒ</div>
                    <canvas id="boardCanvas"></canvas>
                    <div class="ai-thinking" id="aiThinking">
                        <p>ğŸ¤– AIæ€è€ƒä¸­ <span class="thinking-animation"></span><span class="thinking-animation"></span><span class="thinking-animation"></span></p>
                        <div class="progress-container">
                            <div class="progress-bar" id="aiProgressBar"></div>
                        </div>
                        <div class="progress-text" id="aiProgressText">å‡†å¤‡å¼€å§‹æ€è€ƒ...</div>
                        <p>æ€è€ƒæ·±åº¦: <span id="aiDepth">3</span> | è¯„ä¼°ç‚¹æ•°: <span id="evaluatedPoints">0</span></p>
                        <p>ç¼“å­˜å‘½ä¸­: <span id="cacheHits">0</span> | æ—¶é—´æ§åˆ¶: <span id="timeControl">2000ms</span></p>
                        <p>å¨èƒæ£€æµ‹: <span id="threatLevel">æ— </span> | é˜²å®ˆæ¨¡å¼: <span id="defenseMode">æ­£å¸¸</span></p>
                    </div>
                    <div class="win-message hidden" id="winMessage">
                        <h2 id="winTitle">æ¸¸æˆç»“æŸ</h2>
                        <p id="winText"></p>
                        <button class="btn" id="closeWinBtn">ç¡®å®š</button>
                    </div>
                </div>
            </div>
            
            <div class="controls-sidebar">
                <div class="panel">
                    <h2>âš™ï¸ æ¸¸æˆè®¾ç½®</h2>
                    <div class="btn-group">
                        <button class="btn active" id="playerFirstBtn">ç©å®¶å…ˆæ‰‹</button>
                        <button class="btn" id="aiFirstBtn">AIå…ˆæ‰‹</button>
                    </div>
                    
                    <div class="slider-container">
                        <label for="difficultySlider">AIéš¾åº¦: <span id="difficultyValue">ä¸­ç­‰</span><span class="difficulty-indicator" id="difficultyLevel">2/5</span></label>
                        <input type="range" min="1" max="5" value="2" class="slider" id="difficultySlider">
                        <div class="difficulty-labels">
                            <span>ç®€å•</span>
                            <span>ä¸­ç­‰</span>
                            <span>å›°éš¾</span>
                            <span>ä¸“å®¶</span>
                            <span>å¤§å¸ˆ</span>
                        </div>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn" id="hintBtn">æç¤ºæœ€ä½³è½å­</button>
                        <button class="btn" id="undoBtn">æ’¤é”€ä¸€æ­¥</button>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn" id="newGameBtn">é‡æ–°å¼€å§‹</button>
                    </div>
                    
                    <div class="mobile-optimization">
                        âœ… å·²ä¼˜åŒ–ç§»åŠ¨è®¾å¤‡ä½“éªŒï¼Œæ”¯æŒåŒæŒ‡ç¼©æ”¾æŸ¥çœ‹æ£‹ç›˜<br>
                        ğŸ§ª ç‚¹å‡»"æµ‹è¯•ç¼©æ”¾åŠŸèƒ½"æŒ‰é’®è·å–å¸®åŠ©
                    </div>
                    
                    <div class="ai-features">
                        <h3>ğŸ¤– AIæ™ºèƒ½å¯¹æˆ˜ç‰¹æ€§</h3>
                        <ul>
                            <li>æ´»ä¸‰è‡ªåŠ¨é˜²å®ˆ</li>
                            <li>è§’è½è½å­ä¼˜åŒ–</li>
                            <li>ä½ç½®æƒé‡å¼ºåŒ–</li>
                            <li>ç´§æ€¥é˜²å®ˆæœºåˆ¶</li>
                            <li>å¨èƒç­‰çº§è¯†åˆ«</li>
                            <li>å‘å±•æ½œåŠ›è¯„ä¼°</li>
                        </ul>
                    </div>
                </div>
                
                <div class="panel">
                    <h2>ğŸ“Š æ¸¸æˆçŠ¶æ€</h2>
                    <div class="status-indicators">
                        <div class="indicator">
                            <span>å½“å‰ç©å®¶</span>
                            <div class="indicator-value" id="currentPlayer">é»‘æ£‹</div>
                        </div>
                        <div class="indicator">
                            <span>å›åˆæ•°</span>
                            <div class="indicator-value" id="moveCount">0</div>
                        </div>
                        <div class="indicator">
                            <span>AIéš¾åº¦</span>
                            <div class="indicator-value" id="aiLevelDisplay">ä¸­ç­‰</div>
                        </div>
                    </div>
                    
                    <div class="panel history-panel">
                        <h2 style="display:flex;align-items:center;justify-content:space-between;">
                            <span>ğŸ“œ å†å²è®°å½•</span>
                            <button id="copyAllHistoryBtn" style="margin-left:10px;font-size:0.9em;padding:3px 12px;border-radius:5px;border:none;background:#fdbb2d;color:#222;cursor:pointer;">è¤‡è£½å…¨éƒ¨</button>
                        </h2>
                        <div id="historyList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¸¸æˆå¸¸é‡
        const BOARD_SIZE = 19;
        const EMPTY = 0;
        const PLAYER = 1;
        const AI_PLAYER = 2;
        
        // æ£‹å­é¢œè‰²å¸¸é‡
        const BLACK = 1;
        const WHITE = 2;
        
        // éš¾åº¦çº§åˆ«å®šä¹‰ - ä¼˜åŒ–ç‰ˆ
        const DIFFICULTY_LEVELS = [
            { name: "ç®€å•", depth: 2, searchRadius: 1, evalPoints: 500, timeLimit: 1000 },
            { name: "ä¸­ç­‰", depth: 3, searchRadius: 2, evalPoints: 1500, timeLimit: 2000 },
            { name: "å›°éš¾", depth: 4, searchRadius: 2, evalPoints: 3000, timeLimit: 3000 },
            { name: "ä¸“å®¶", depth: 5, searchRadius: 3, evalPoints: 8000, timeLimit: 5000 },
            { name: "å¤§å¸ˆ", depth: 6, searchRadius: 3, evalPoints: 15000, timeLimit: 8000 }
        ];
        
        // å¼€å±€åº“ - å¸¸è§å¼€å±€æ¨¡å¼
        const OPENING_MOVES = [
            {row: 9, col: 9}, // å¤©å…ƒ
            {row: 8, col: 8}, {row: 10, col: 10}, // æ˜Ÿä½
            {row: 8, col: 10}, {row: 10, col: 8}, // æ˜Ÿä½
            {row: 7, col: 9}, {row: 11, col: 9}, // è¾¹æ˜Ÿ
            {row: 9, col: 7}, {row: 9, col: 11}  // è¾¹æ˜Ÿ
        ];
        
        // ä½ç½®æƒé‡è¡¨ - æ£‹ç›˜ä¸­å¿ƒä½ç½®æ›´æœ‰ä»·å€¼ - å¼ºåŒ–è§’è½æƒ©ç½š
        const POSITION_WEIGHTS = (() => {
            const weights = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(1));
            const center = Math.floor(BOARD_SIZE / 2);
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const distanceFromCenter = Math.abs(row - center) + Math.abs(col - center);
                    // è§’è½ä½ç½®æƒ©ç½šæ›´é‡
                    const isCorner = (row === 0 || row === BOARD_SIZE-1) && 
                                    (col === 0 || col === BOARD_SIZE-1);
                    const isEdge = (row === 0 || row === BOARD_SIZE-1 || col === 0 || col === BOARD_SIZE-1);
                    if (isCorner) {
                        weights[row][col] = 0.05; // è§’è½æä½
                    } else if (isEdge) {
                        weights[row][col] = 0.7; // è¾¹ç¼˜ä½ç½®é™ä½æƒé‡
                    } else if (distanceFromCenter <= 2) {
                        weights[row][col] = 2.0;
                    } else if (distanceFromCenter <= 4) {
                        weights[row][col] = 1.5;
                    } else if (distanceFromCenter <= 6) {
                        weights[row][col] = 1.1;
                    } else if (distanceFromCenter <= 8) {
                        weights[row][col] = 0.8;
                    } else {
                        weights[row][col] = 0.5;
                    }
                }
            }
            return weights;
        })();
        
        // æ€§èƒ½æŒ‡æ ‡
        let performanceMetrics = {
            lastAITime: 0,
            mobileMode: false,
            touchPoints: 0,
            isZooming: false,
            cacheHits: 0,
            totalEvaluations: 0,
            aiProgress: 0,
            aiStatus: "å‡†å¤‡ä¸­"
        };
        
        // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // åŠ¨æ€è®¡ç®—å•å…ƒæ ¼å¤§å°
        function calculateCellSize() {
            const wrapper = document.querySelector('.board-wrapper');
            const maxWidth = wrapper.clientWidth;
            return Math.floor(maxWidth / BOARD_SIZE);
        }
        
        // æ¸¸æˆçŠ¶æ€ç±»
        class Game {
            constructor() {
                this.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
                this.currentPlayer = PLAYER;
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.history = [];
                this.blackPlayer = PLAYER; // é»˜è®¤ç©å®¶æ‰§é»‘
                this.whitePlayer = AI_PLAYER; // é»˜è®¤AIæ‰§ç™½
                this.winLine = null; // æ–°å¢ï¼šè®°å½•èƒœåˆ©äº”å­åæ ‡
            }
            
            // é‡ç½®æ¸¸æˆ
            reset() {
                this.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
                this.currentPlayer = PLAYER; // é»˜è®¤ç©å®¶å…ˆæ‰‹
                this.gameOver = false;
                this.winner = null;
                this.moveHistory = [];
                this.history = [];
            }
            
            // è®¾ç½®å½“å‰ç©å®¶
            setCurrentPlayer(player) {
                this.currentPlayer = player;
            }
            
            // è®¾ç½®æ£‹å­é¢œè‰²
            setPieceColors(blackPlayer, whitePlayer) {
                this.blackPlayer = blackPlayer;
                this.whitePlayer = whitePlayer;
            }
            
            // è·å–ç©å®¶çš„æ£‹å­é¢œè‰²
            getPlayerColor(player) {
                return player === this.blackPlayer ? BLACK : WHITE;
            }
            
            // æ ¹æ®é¢œè‰²è·å–ç©å®¶
            getPlayerByColor(color) {
                return color === BLACK ? this.blackPlayer : this.whitePlayer;
            }
            
            // è½å­
            makeMove(row, col) {
                if (this.gameOver || this.board[row][col] !== EMPTY) {
                    return false;
                }
                
                // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²
                this.history.push({
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer
                });
                
                this.board[row][col] = this.currentPlayer;
                this.moveHistory.push({row, col, player: this.currentPlayer});
                
                // æ£€æŸ¥èƒœåˆ©
                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;

                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    this.winner = EMPTY; // å¹³å±€
                } else {
                    // åˆ‡æ¢ç©å®¶
                    this.currentPlayer = this.currentPlayer === PLAYER ? AI_PLAYER : PLAYER;
                }
                
                return true;
            }
            
            // æ’¤é”€ä¸€æ­¥
            undo() {
                if (this.history.length > 0) {
                    const prevState = this.history.pop();
                    this.board = prevState.board;
                    this.currentPlayer = prevState.currentPlayer;
                    this.moveHistory.pop();
                    this.gameOver = false;
                    this.winner = null;
                    return true;
                }
                return false;
            }
            
            // æ£€æŸ¥èƒœåˆ©
            checkWin(row, col) {
                const player = this.board[row][col];
                const directions = [
                    [0, 1],   // æ°´å¹³
                    [1, 0],   // å‚ç›´
                    [1, 1],   // å¯¹è§’çº¿
                    [1, -1]   // åå¯¹è§’çº¿
                ];
                for (const [dx, dy] of directions) {
                    let count = 1;
                    let line = [{row, col}];
                    // æ­£å‘æ£€æŸ¥
                    let r = row + dx, c = col + dy;
                    while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && this.board[r][c] === player) {
                        count++;
                        line.push({row: r, col: c});
                        r += dx;
                        c += dy;
                    }
                    // åå‘æ£€æŸ¥
                    r = row - dx;
                    c = col - dy;
                    while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && this.board[r][c] === player) {
                        count++;
                        line.unshift({row: r, col: c});
                        r -= dx;
                        c -= dy;
                    }
                    // åªå…è®¸ä¸¥æ ¼äº”è¿ç èƒœåˆ©ï¼Œé•¿è¿ä¸ç®—
                    if (count === 5) {
                        // æ£€æŸ¥ä¸¤ç«¯æ˜¯å¦è¿˜æœ‰åŒè‰²æ£‹å­ï¼ˆé•¿è¿ä¸ç®—ï¼‰
                        let beforeR = line[0].row - dx, beforeC = line[0].col - dy;
                        let afterR = line[4].row + dx, afterC = line[4].col + dy;
                        if (
                            beforeR >= 0 && beforeR < BOARD_SIZE && beforeC >= 0 && beforeC < BOARD_SIZE && this.board[beforeR][beforeC] === player
                            ||
                            afterR >= 0 && afterR < BOARD_SIZE && afterC >= 0 && afterC < BOARD_SIZE && this.board[afterR][afterC] === player
                        ) {
                            continue; // é•¿è¿ï¼Œè·³è¿‡
                        }
                        this.winLine = line;
                        return true;
                    }
                }
                this.winLine = null;
                return false;
            }
            
            // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å·²æ»¡
            isBoardFull() {
                return this.board.every(row => row.every(cell => cell !== EMPTY));
            }
            
            // è·å–æ£‹ç›˜çŠ¶æ€
            getBoard() {
                return this.board;
            }
            
            // è·å–å½“å‰ç©å®¶
            getCurrentPlayer() {
                return this.currentPlayer;
            }
            
            // è·å–ç§»åŠ¨å†å²
            getMoveHistory() {
                return this.moveHistory;
            }
            
            // æ–°å¢ï¼šè·å–èƒœåˆ©äº”å­åæ ‡
            getWinLine() {
                return this.winLine;
            }
        }
        
        // AIç±» - ä¼˜åŒ–ç‰ˆ
        class AI {
            constructor(game) {
                this.game = game;
                this.depth = 2;
                this.searchRadius = 2;
                this.maxEvalPoints = 800;
                this.timeLimit = 2000;
                this.mobileMode = false;
                this.transpositionTable = new Map(); // ç½®æ¢è¡¨ç¼“å­˜
                this.moveOrderingCache = new Map(); // ç§»åŠ¨æ’åºç¼“å­˜
                this.evaluationCache = new Map(); // è¯„ä¼°ç¼“å­˜
            }
            
            // è®¾ç½®éš¾åº¦
            setDifficulty(level) {
                const difficulty = DIFFICULTY_LEVELS[level - 1];
                this.depth = difficulty.depth;
                this.searchRadius = difficulty.searchRadius;
                this.maxEvalPoints = difficulty.evalPoints;
                this.timeLimit = difficulty.timeLimit;
                
                // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šè‡ªåŠ¨è°ƒæ•´éš¾åº¦
                if (this.mobileMode && level > 3) {
                    this.depth = Math.min(this.depth, 4);
                    this.maxEvalPoints = Math.min(this.maxEvalPoints, 5000);
                    this.timeLimit = Math.min(this.timeLimit, 3000);
                }
                
                // æ¸…ç©ºç¼“å­˜
                this.transpositionTable.clear();
                this.moveOrderingCache.clear();
                this.evaluationCache.clear();
            }
            
            // å¯ç”¨ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–
            enableMobileMode() {
                this.mobileMode = true;
                // é™ä½é»˜è®¤éš¾åº¦
                this.depth = Math.min(this.depth, 3);
                this.maxEvalPoints = Math.min(this.maxEvalPoints, 2000);
                this.timeLimit = Math.min(this.timeLimit, 2000);
            }
            
            // æ¸…ç†ç¼“å­˜
            clearCache() {
                this.transpositionTable.clear();
                this.moveOrderingCache.clear();
                this.evaluationCache.clear();
                performanceMetrics.cacheHits = 0;
                performanceMetrics.totalEvaluations = 0;
            }
            
            // è·å–æœ€ä½³è½å­ä½ç½® - ä¼˜å…ˆçº§ä¼˜åŒ–ç‰ˆ
            getBestMove() {
                const startTime = performance.now();
                let bestScore = -Infinity;
                let bestMove = null;
                const board = this.game.getBoard();
                let evaluatedPoints = 0;
                this.updateProgress(5, "ğŸ§  å¼€å§‹åˆ†æå±€åŠ¿...");
                
                // 0.5 æ–°å¢ï¼šæ£€æŸ¥"ç©ºé»‘é»‘ç©ºé»‘ç©º"æ¨¡å¼å¨èƒ
                const specificPatternThreat = this.findSpecificPatternThreat(board);
                if (specificPatternThreat) {
                    this.updateProgress(100, "ğŸ›‘ æ£€æµ‹åˆ°ç‰¹å®šæ¨¡å¼å¨èƒï¼ç´§æ€¥é˜²å®ˆ");
                    return specificPatternThreat;
                }
                
                // 0. æ£€æŸ¥æ£‹ç›˜ä¸Šç©å®¶å·²ç»å½¢æˆçš„å†²å››ï¼ˆå››è¿ç ï¼‰çš„é˜²å®ˆç‚¹
                const existingFourBlock = this.findExistingFourThreat(board);
                if (existingFourBlock && board[existingFourBlock.row][existingFourBlock.col] === EMPTY) {
                    this.updateProgress(100, "ğŸš¨ å¿…é¡»é˜²å®ˆç©å®¶å·²å­˜åœ¨çš„å†²å››");
                    return existingFourBlock;
                }
                
                // 1. æ£€æŸ¥ç©å®¶äº”è¿ç /æ´»å››å¨èƒï¼ˆå¿…é¡»ç«‹å³é˜²å®ˆï¼‰
                const mustBlock = this.findMustBlockMove(board);
                if (mustBlock && board[mustBlock.row][mustBlock.col] === EMPTY) {
                    this.updateProgress(100, "ğŸš¨ å¿…é¡»é˜²å®ˆç©å®¶æ´»å››/å†²å››");
                    return mustBlock;
                }
                
                // 2. æ£€æŸ¥ç©å®¶æ´»ä¸‰å¨èƒï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
                const blockLiveThree = this.findBlockLiveThreeMove(board);
                if (blockLiveThree && board[blockLiveThree.row][blockLiveThree.col] === EMPTY) {
                    this.updateProgress(100, "ğŸ›¡ï¸ é˜²å®ˆç©å®¶æ´»ä¸‰");
                    return blockLiveThree;
                }
                
                // 3. æ–°å¢ï¼šæ£€æŸ¥åŒæ´»ä¸‰å¨èƒ
                const doubleLiveThreeBlock = this.findDoubleLiveThreeThreat(board);
                if (doubleLiveThreeBlock && board[doubleLiveThreeBlock.row][doubleLiveThreeBlock.col] === EMPTY) {
                    this.updateProgress(100, "ğŸ›¡ï¸ åŒæ´»ä¸‰å¨èƒï¼éœ€è¦é˜²å®ˆ");
                    return doubleLiveThreeBlock;
                }
                
                // 4. AIæœ‰äº”è¿ç /æ´»å››ï¼Œç›´æ¥è¿›æ”»
                const winMove = this.findWinMove(board);
                if (winMove && board[winMove.row][winMove.col] === EMPTY) {
                    this.updateProgress(100, "âš¡ AIç›´æ¥è¿›æ”»è·èƒœ");
                    return winMove;
                }
                
                // 5. ç©å®¶æœ‰åŒå››å¨èƒï¼ˆä¸¤ä¸ªå†²å››/æ´»å››ç»„åˆï¼‰
                const doubleFourBlock = this.findDoubleFourThreat(board);
                if (doubleFourBlock) {
                    this.updateProgress(100, "ğŸ›‘ åŒå››å¨èƒï¼ç´§æ€¥é˜²å®ˆ");
                    return doubleFourBlock;
                }
                
                // 6. ç©å®¶æœ‰å››ä¸‰å¨èƒï¼ˆå†²å››+æ´»ä¸‰ï¼‰
                const fourThreeBlock = this.findFourThreeThreat(board);
                if (fourThreeBlock) {
                    this.updateProgress(100, "âš ï¸ å››ä¸‰å¨èƒï¼ä¼˜å…ˆé˜²å®ˆ");
                    return fourThreeBlock;
                }
                
                // 7. ç©å®¶æœ‰æ½œåœ¨æ´»ä¸‰/æ´»äºŒå¨èƒï¼ˆæ–°å¢ï¼‰
                const potentialThreat = this.findPotentialThreatMove(board);
                if (potentialThreat && board[potentialThreat.row][potentialThreat.col] === EMPTY) {
                    this.updateProgress(100, "ğŸ” é˜²å®ˆæ½œåœ¨å¨èƒ");
                    return potentialThreat;
                }
                
                // 8. AIæœ‰æ´»ä¸‰ï¼Œè¿›æ”»
                const attackMove = this.findAttackMove(board);
                if (attackMove && board[attackMove.row][attackMove.col] === EMPTY) {
                    this.updateProgress(100, "âš¡ è¿›æ”»æœºä¼šä¼˜å…ˆ");
                    return attackMove;
                }
                
                // 9. å¼€å±€åº“æ£€æŸ¥
                if (this.game.getMoveHistory().length < 4) {
                    this.updateProgress(15, "ğŸ“š æ£€æŸ¥å¼€å±€åº“...");
                    const openingMove = this.getOpeningMove(board);
                    if (openingMove && board[openingMove.row][openingMove.col] === EMPTY) {
                        this.updateProgress(100, "âœ… ä½¿ç”¨å¼€å±€åº“ç§»åŠ¨");
                        return openingMove;
                    }
                }
                
                // 10. æ£€æŸ¥ç´§æ€¥é˜²å®ˆéœ€æ±‚
                this.updateProgress(25, "ğŸ›¡ï¸ æ£€æŸ¥ç´§æ€¥é˜²å®ˆéœ€æ±‚...");
                const urgentDefenseMove = this.findUrgentDefenseMove(board);
                if (urgentDefenseMove && board[urgentDefenseMove.row][urgentDefenseMove.col] === EMPTY) {
                    this.updateProgress(100, "ğŸš¨ æ‰§è¡Œç´§æ€¥é˜²å®ˆ");
                    return urgentDefenseMove;
                }
                
                // 11. ä½¿ç”¨æ”¹è¿›çš„å¤‡é€‰ç§»åŠ¨ç­–ç•¥
                this.updateProgress(50, "ğŸ” æœç´¢æœ€ä½³ä½ç½®...");
                const fallbackMove = this.getFallbackMove(board);
                if (fallbackMove) {
                    return fallbackMove;
                }
                
                // æœ€åæ‰‹æ®µï¼šè¿”å›ç¬¬ä¸€ä¸ªéè§’è½ç©ºä½
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((r === 0 || r === BOARD_SIZE-1) && (c === 0 || c === BOARD_SIZE-1)) {
                                continue;
                            }
                            return {row: r, col: c};
                        }
                    }
                }
                // å¦‚æœæ£‹ç›˜æ»¡äº†ï¼Œè¿”å›null
                return null;
            }
            
            // å¢å¼ºç‰ˆæ´»ä¸‰æ£€æµ‹æ–¹æ³•
            isLiveThree(board, row, col, player) {
                const directions = [[0,1],[1,0],[1,1],[1,-1]];
                let liveThreeCount = 0;
                
                for (const [dx,dy] of directions) {
                    let count = 1;
                    let openEnds = 0;
                    
                    // æ­£å‘æ£€æŸ¥
                    let r = row + dx, c = col + dy;
                    let consecutive = true;
                    let blocked = false;
                    
                    // æ­£å‘è¿ç»­æ£‹å­
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else {
                            if (board[r][c] === EMPTY) {
                                openEnds++;
                            } else {
                                blocked = true;
                            }
                            consecutive = false;
                        }
                        r += dx; 
                        c += dy;
                    }
                    
                    // åå‘æ£€æŸ¥
                    r = row - dx; 
                    c = col - dy;
                    consecutive = true;
                    
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else {
                            if (board[r][c] === EMPTY) {
                                openEnds++;
                            } else {
                                blocked = true;
                            }
                            consecutive = false;
                        }
                        r -= dx; 
                        c -= dy;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ´»ä¸‰ï¼šè¿ç»­3ä¸ªæ£‹å­ä¸”ä¸¤ç«¯å¼€æ”¾
                    if (count === 3 && openEnds >= 2 && !blocked) {
                        return true;
                    }
                    
                    // æ£€æŸ¥è·³æ´»ä¸‰æ¨¡å¼ï¼šä¾‹å¦‚ _OO_O
                    if (this.checkJumpLiveThree(board, row, col, dx, dy, player)) {
                        return true;
                    }
                }
                return false;
            }
            
            // æ£€æŸ¥è·³æ´»ä¸‰æ¨¡å¼
            checkJumpLiveThree(board, row, col, dx, dy, player) {
                // æ¨¡å¼1: O O _ O
                let pattern1 = [
                    [0, 0], [dx, dy], [2*dx, 2*dy], [3*dx, 3*dy]
                ];
                
                // æ¨¡å¼2: O _ O O
                let pattern2 = [
                    [0, 0], [dx, dy], [3*dx, 3*dy], [4*dx, 4*dy]
                ];
                
                // æ£€æŸ¥æ¨¡å¼1
                let validPattern1 = true;
                for (let i = 0; i < pattern1.length; i++) {
                    const [dr, dc] = pattern1[i];
                    const r = row + dr;
                    const c = col + dc;
                    
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                        validPattern1 = false;
                        break;
                    }
                    
                    if (i === 2) { // ä¸­é—´ç©ºä½
                        if (board[r][c] !== EMPTY) {
                            validPattern1 = false;
                            break;
                        }
                    } else {
                        if (board[r][c] !== player) {
                            validPattern1 = false;
                            break;
                        }
                    }
                }
                
                // æ£€æŸ¥æ¨¡å¼1çš„å¼€æ”¾ç«¯
                if (validPattern1) {
                    const startR = row - dx;
                    const startC = col - dy;
                    const endR = row + 4*dx;
                    const endC = col + 4*dy;
                    
                    let startOpen = (startR < 0 || startR >= BOARD_SIZE || startC < 0 || startC >= BOARD_SIZE) ? 
                        false : board[startR][startC] === EMPTY;
                    let endOpen = (endR < 0 || endR >= BOARD_SIZE || endC < 0 || endC >= BOARD_SIZE) ? 
                        false : board[endR][endC] === EMPTY;
                        
                    if (startOpen && endOpen) {
                        return true;
                    }
                }
                
                // æ£€æŸ¥æ¨¡å¼2
                let validPattern2 = true;
                for (let i = 0; i < pattern2.length; i++) {
                    const [dr, dc] = pattern2[i];
                    const r = row + dr;
                    const c = col + dc;
                    
                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                        validPattern2 = false;
                        break;
                    }
                    
                    if (i === 1) { // ä¸­é—´ç©ºä½
                        if (board[r][c] !== EMPTY) {
                            validPattern2 = false;
                            break;
                        }
                    } else {
                        if (board[r][c] !== player) {
                            validPattern2 = false;
                            break;
                        }
                    }
                }
                
                // æ£€æŸ¥æ¨¡å¼2çš„å¼€æ”¾ç«¯
                if (validPattern2) {
                    const startR = row - dx;
                    const startC = col - dy;
                    const endR = row + 5*dx;
                    const endC = col + 5*dy;
                    
                    let startOpen = (startR < 0 || startR >= BOARD_SIZE || startC < 0 || startC >= BOARD_SIZE) ? 
                        false : board[startR][startC] === EMPTY;
                    let endOpen = (endR < 0 || endR >= BOARD_SIZE || endC < 0 || endC >= BOARD_SIZE) ? 
                        false : board[endR][endC] === EMPTY;
                        
                    if (startOpen && endOpen) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // å¢å¼ºå¨èƒæ£€æµ‹å‡½æ•°
            getThreatLevel(board, row, col) {
                const player = board[row][col];
                const directions = [[0,1],[1,0],[1,1],[1,-1]];
                let maxThreat = 0;
                for (const [dx, dy] of directions) {
                    let count = 1;
                    let openEnds = 0;
                    let r = row + dx, c = col + dy;
                    let consecutive = true;
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else {
                            if (board[r][c] === EMPTY) {
                                openEnds++;
                            }
                            consecutive = false;
                        }
                        r += dx;
                        c += dy;
                    }
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                        openEnds++;
                    }
                    r = row - dx;
                    c = col - dy;
                    consecutive = true;
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else {
                            if (board[r][c] === EMPTY) {
                                openEnds++;
                            }
                            consecutive = false;
                        }
                        r -= dx;
                        c -= dy;
                    }
                    if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                        openEnds++;
                    }
                    // åŸæœ‰å¨èƒç­‰çº§
                    if (count >= 5) {
                        maxThreat = Math.max(maxThreat, 5);
                    } else if (count === 4) {
                        if (openEnds >= 2) {
                            maxThreat = Math.max(maxThreat, 4);
                        } else if (openEnds >= 1) {
                            maxThreat = Math.max(maxThreat, 4);
                        }
                    } else if (count === 3) {
                        if (openEnds >= 2) {
                            maxThreat = Math.max(maxThreat, 3);
                        }
                    }
                    // å¢å¼ºï¼šæ£€æŸ¥è·³æ´»ä¸‰æ¨¡å¼
                    if (count < 4 && this.checkJumpLiveThree(board, row, col, dx, dy, player)) {
                        maxThreat = Math.max(maxThreat, 3);
                    }
                }
                // æ–°å¢ï¼šæ£€æŸ¥åŒæ´»ä¸‰å¨èƒ
                if (maxThreat >= 3) {
                    let liveThreeCount = 0;
                    for (const [dx, dy] of directions) {
                        if (this.getDirectionalThreat(board, row, col, dx, dy, player) >= 3) {
                            liveThreeCount++;
                        }
                    }
                    if (liveThreeCount >= 2) {
                        maxThreat = Math.max(maxThreat, 4); // åŒæ´»ä¸‰è§†ä¸ºæ›´é«˜å¨èƒ
                    }
                }
                // æ–°å¢ï¼šæ£€æŸ¥ç‰¹å®šå¨èƒæ¨¡å¼
                const specificPatternThreat = this.findSpecificPatternThreat(board);
                if (specificPatternThreat && specificPatternThreat.row === row && specificPatternThreat.col === col) {
                    maxThreat = Math.max(maxThreat, 4); // è§†ä¸ºé«˜çº§å¨èƒ
                }
                return maxThreat;
            }
            
            // å¢å¼ºé˜²å®ˆæ´»ä¸‰å‡½æ•°
            findBlockLiveThreeMove(board) {
                const blockPoints = [];
                const center = Math.floor(BOARD_SIZE / 2);
                
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            
                            // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦èƒ½å¤Ÿé˜»æ­¢ç©å®¶çš„æ´»ä¸‰
                            board[row][col] = PLAYER;
                            const isThreat = this.isLiveThree(board, row, col, PLAYER);
                            board[row][col] = EMPTY;
                            
                            if (isThreat) {
                                // è®¡ç®—å¨èƒåˆ†æ•°ï¼šä¸­å¿ƒä½ç½®æƒé‡æ›´é«˜
                                const distanceFromCenter = Math.abs(row - center) + Math.abs(col - center);
                                const positionWeight = 1.0 - (distanceFromCenter / (BOARD_SIZE * 2));
                                const threatScore = 50000 * positionWeight;
                                
                                blockPoints.push({
                                    row, 
                                    col, 
                                    score: threatScore
                                });
                            }
                        }
                    }
                }
                
                // æŒ‰å¨èƒåˆ†æ•°é™åºæ’åº
                blockPoints.sort((a, b) => b.score - a.score);
                return blockPoints.length > 0 ? blockPoints[0] : null;
            }
            
            // æŸ¥æ‰¾ç©å®¶ä¸‹ä¸€æ­¥èƒ½å½¢æˆæ´»å››/å†²å››çš„ä½ç½®
            findMustBlockMove(board) {
                const threatPoints = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            if ((row === 0 || row === BOARD_SIZE-1) && (col === 0 || col === BOARD_SIZE-1)) continue;
                            board[row][col] = PLAYER;
                            const threatLevel = this.getThreatLevel(board, row, col);
                            board[row][col] = EMPTY;
                            // å¨èƒç­‰çº§4è¡¨ç¤ºæ´»å››æˆ–å†²å››ï¼ˆéƒ½æ˜¯å¿…é¡»ç«‹å³é˜²å®ˆçš„ï¼‰ï¼Œ5è¡¨ç¤ºäº”è¿ï¼ˆå·²ç»èµ¢äº†ï¼‰
                            if (threatLevel >= 4) {
                                threatPoints.push({row, col});
                            }
                        }
                    }
                }
                if (threatPoints.length === 0) return null;
                // è¿”å›ç¬¬ä¸€ä¸ªå¨èƒä½ç½®
                return threatPoints[0];
            }
            
            // æ›´æ–°å¨èƒçŠ¶æ€æ˜¾ç¤º
            updateThreatDisplay(board) {
                const threats = this.checkGlobalThreats(board);
                let threatLevel = "æ— ";
                let defenseMode = "æ­£å¸¸";
                
                // æ£€æŸ¥ç©å®¶å¨èƒ
                if (threats.player.liveFour > 0) {
                    threatLevel = "æ´»å››å¨èƒ";
                    defenseMode = "ç´§æ€¥é˜²å®ˆ";
                } else if (threats.player.liveThree > 0 || threats.player.doubleThree > 0) {
                    threatLevel = threats.player.doubleThree > 0 ? "åŒæ´»ä¸‰å¨èƒ" : "æ´»ä¸‰å¨èƒ";
                    defenseMode = "ç§¯æé˜²å®ˆ";
                }
                
                document.getElementById('threatLevel').textContent = threatLevel;
                document.getElementById('defenseMode').textContent = defenseMode;
                
                // æ˜¾ç¤ºå¨èƒæŒ‡ç¤ºå™¨
                const threatIndicator = document.getElementById('threatIndicator');
                if (threats.player.liveThree > 0 || threats.player.liveFour > 0 || threats.player.doubleThree > 0) {
                    threatIndicator.style.display = 'block';
                    if (threats.player.liveFour > 0) {
                        threatIndicator.textContent = "ğŸ›¡ï¸ AIæ­£åœ¨é˜²å®ˆæ´»å››å¨èƒ";
                    } else if (threats.player.doubleThree > 0) {
                        threatIndicator.textContent = "ğŸ›¡ï¸ AIæ­£åœ¨é˜²å®ˆåŒæ´»ä¸‰å¨èƒ";
                    } else {
                        threatIndicator.textContent = "ğŸ›¡ï¸ AIæ­£åœ¨é˜²å®ˆæ´»ä¸‰å¨èƒ";
                    }
                } else {
                    threatIndicator.style.display = 'none';
                }
            }
            
            // æ›´æ–°AIè¿›åº¦
            updateProgress(progress, status) {
                performanceMetrics.aiProgress = progress;
                performanceMetrics.aiStatus = status;
                
                const progressBar = document.getElementById('aiProgressBar');
                const progressText = document.getElementById('aiProgressText');
                
                if (progressBar && progressText) {
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = status;
                }
            }
            
            // è·å–å¼€å±€ç§»åŠ¨
            getOpeningMove(board) {
                const moveHistory = this.game.getMoveHistory();
                const center = Math.floor(BOARD_SIZE / 2);
                // åªè¦ä¸­å¿ƒç‚¹æ˜¯ç©ºçš„ï¼ŒAIç¬¬ä¸€æ‰‹å°±ä¸‹ä¸­å¿ƒ
                if (moveHistory.length === 1 && board[center][center] === EMPTY) {
                    return {row: center, col: center};
                }
                // å…¶å®ƒæƒ…å†µå†éå†å¼€å±€åº“
                for (const openingMove of OPENING_MOVES) {
                    if (board[openingMove.row][openingMove.col] === EMPTY) {
                        return openingMove;
                    }
                }
                return null;
            }
            
            // ç§»åŠ¨æ’åºä¼˜åŒ–
            sortMoves(moves, board) {
                moves.sort((a, b) => {
                    const scoreA = this.getMoveScore(a, board);
                    const scoreB = this.getMoveScore(b, board);
                    return scoreB - scoreA; // é™åºæ’åˆ—
                });
            }
            
            // è·å–ç§»åŠ¨è¯„åˆ†ï¼ˆç”¨äºæ’åºï¼‰- å¼ºåŒ–é˜²å®ˆç‰ˆ
            getMoveScore(move, board) {
                const {row, col} = move;
                let score = 0;
                
                // ä½ç½®æƒé‡
                score += POSITION_WEIGHTS[row][col] * 10;
                
                // æ£€æŸ¥æ˜¯å¦èƒ½å½¢æˆå¨èƒ
                board[row][col] = AI_PLAYER;
                const aiScore = this.evaluatePosition(board, row, col);
                board[row][col] = PLAYER;
                const playerScore = this.evaluatePosition(board, row, col);
                board[row][col] = EMPTY;
                
                // ä¼˜åŒ–ï¼šè¿›æ”»æƒé‡æ›´é«˜ï¼Œé˜²å®ˆæƒé‡é€‚ä¸­
                score += aiScore * 3.0; // AIè¿›æ”»
                score += playerScore * 1.5; // é˜²å®ˆå¯¹æ‰‹å¨èƒ
                
                // ç´§æ€¥é˜²å®ˆæ£€æŸ¥
                if (this.isUrgentDefense(move, board)) {
                    score += 50000; // ç´§æ€¥é˜²å®ˆä¼˜å…ˆçº§æœ€é«˜
                }
                
                return score;
            }
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦ç´§æ€¥é˜²å®ˆ
            isUrgentDefense(move, board) {
                const {row, col} = move;
                
                // æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦æœ‰æ´»ä¸‰å¨èƒ
                board[row][col] = PLAYER;
                const threatLevel = this.getThreatLevel(board, row, col);
                board[row][col] = EMPTY;
                
                return threatLevel >= 3; // æ´»ä¸‰æˆ–æ›´é«˜å¨èƒ
            }
            
            // è·å–å¨èƒç­‰çº§ï¼ˆä¿®æ­£ç‰ˆï¼‰
            getThreatLevelOld(board, row, col) {
                const player = board[row][col];
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                let maxThreat = 0;
                for (const [dx, dy] of directions) {
                    const threat = this.getDirectionalThreat(board, row, col, dx, dy, player);
                    maxThreat = Math.max(maxThreat, threat);
                }
                return maxThreat;
            }

            // è·å–æŸä¸ªæ–¹å‘çš„å¨èƒç­‰çº§ï¼ˆä¿®æ­£ç‰ˆï¼ŒåŒºåˆ†æ´»å››/å†²å››ï¼‰
            getDirectionalThreat(board, row, col, dx, dy, player) {
                let count = 1;
                let openEnds = 0;
                // æ­£å‘
                let r = row + dx, c = col + dy;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                    count++;
                    r += dx;
                    c += dy;
                }
                // æ£€æŸ¥æ­£å‘ç«¯ç‚¹
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                    openEnds++;
                }
                // åå‘
                r = row - dx;
                c = col - dy;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
                    count++;
                    r -= dx;
                    c -= dy;
                }
                // æ£€æŸ¥åå‘ç«¯ç‚¹
                if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
                    openEnds++;
                }
                // å¨èƒç­‰çº§ï¼š5=äº”è¿ç , 4=æ´»å››/å†²å››, 3=æ´»ä¸‰, 2=æ´»äºŒ, 1=çœ ä¸‰
                if (count >= 5) return 5;
                if (count === 4 && openEnds === 2) return 4; // æ´»å››
                if (count === 4 && openEnds === 1) return 4; // å†²å››
                if (count === 3 && openEnds === 2) return 3;
                if (count === 2 && openEnds === 2) return 2;
                if (count === 3 && openEnds === 1) return 1;
                return 0;
            }
            
            // è·å–æç¤ºä½ç½®
            getHint() {
                return this.getBestMove();
            }
            
            // è·å–æ‰€æœ‰å¯èƒ½çš„è½å­ä½ç½®ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
            getPossibleMoves(board) {
                const moves = [];
                const center = Math.floor(BOARD_SIZE / 2);
                
                // å¦‚æœæ£‹ç›˜ä¸ºç©ºï¼Œè¿”å›ä¸­å¿ƒç‚¹
                if (this.game.getMoveHistory().length === 0) {
                    return [{row: center, col: center}];
                }
                
                // åªåœ¨å·²æœ‰æ£‹å­çš„å‘¨å›´æœç´¢
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            // æ£€æŸ¥å‘¨å›´åŒºåŸŸï¼ˆæ ¹æ®éš¾åº¦çº§åˆ«è°ƒæ•´åŠå¾„ï¼‰
                            for (let i = Math.max(0, row - this.searchRadius); i <= Math.min(BOARD_SIZE - 1, row + this.searchRadius); i++) {
                                for (let j = Math.max(0, col - this.searchRadius); j <= Math.min(BOARD_SIZE - 1, col + this.searchRadius); j++) {
                                    // è·³è¿‡å››ä¸ªè§’è½
                                    if ((i === 0 || i === BOARD_SIZE-1) && (j === 0 || j === BOARD_SIZE-1)) continue;
                                    if (board[i][j] === EMPTY) {
                                        // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦æœ‰ä»·å€¼
                                        if (this.isValuablePosition(i, j, board)) {
                                            moves.push({row: i, col: j});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // å»é‡
                const uniqueMoves = Array.from(new Set(moves.map(move => `${move.row},${move.col}`)))
                    .map(str => {
                        const [row, col] = str.split(',');
                        return {row: parseInt(row), col: parseInt(col)};
                    });
                
                // å¦‚æœæ£‹ç›˜ä¸ºç©ºï¼Œè¿”å›ä¸­å¿ƒç‚¹
                if (uniqueMoves.length === 0) {
                    uniqueMoves.push({row: center, col: center});
                }
                
                return uniqueMoves;
            }
            
            // åˆ¤æ–­ä½ç½®æ˜¯å¦æœ‰ä»·å€¼ - å¼ºåŒ–é˜²å®ˆç‰ˆ
            isValuablePosition(row, col, board) {
                // æ£€æŸ¥æ˜¯å¦èƒ½å½¢æˆå¨èƒæˆ–é˜»æ­¢å¨èƒ
                board[row][col] = AI_PLAYER;
                const aiScore = this.evaluatePosition(board, row, col);
                board[row][col] = PLAYER;
                const playerScore = this.evaluatePosition(board, row, col);
                board[row][col] = EMPTY;
                
                // é™ä½é˜ˆå€¼ï¼Œè®©AIè€ƒè™‘æ›´å¤šé˜²å®ˆä½ç½®
                return aiScore > 50 || playerScore > 50;
            }
            
            // æ£€æŸ¥å…¨å±€å¨èƒ - æ–°å¢å‡½æ•°
            checkGlobalThreats(board) {
                const threats = {
                    ai: { liveFour: 0, liveThree: 0, doubleThree: 0 },
                    player: { liveFour: 0, liveThree: 0, doubleThree: 0 }
                };
                
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            const player = board[row][col];
                            const threatInfo = this.getDetailedThreatInfo(board, row, col);
                            
                            if (player === AI_PLAYER) {
                                threats.ai.liveFour += threatInfo.liveFour;
                                threats.ai.liveThree += threatInfo.liveThree;
                                threats.ai.doubleThree += threatInfo.doubleThree;
                            } else {
                                threats.player.liveFour += threatInfo.liveFour;
                                threats.player.liveThree += threatInfo.liveThree;
                                threats.player.doubleThree += threatInfo.doubleThree;
                            }
                        }
                    }
                }
                
                return threats;
            }
            
            // è·å–è¯¦ç»†çš„å¨èƒä¿¡æ¯
            getDetailedThreatInfo(board, row, col) {
                const player = board[row][col];
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                let liveFour = 0, liveThree = 0, doubleThree = 0;
                
                for (const [dx, dy] of directions) {
                    const threat = this.getDirectionalThreat(board, row, col, dx, dy, player);
                    if (threat === 4) liveFour++;
                    else if (threat === 3) liveThree++;
                }
                
                // æ£€æŸ¥åŒä¸‰
                if (liveThree >= 2) doubleThree = 1;
                
                return { liveFour, liveThree, doubleThree };
            }
            
            // æå¤§æå°ç®—æ³•ï¼ˆå¸¦Alpha-Betaå‰ªæå’Œæ—¶é—´æ§åˆ¶ï¼‰
            minimax(board, depth, isMaximizing, alpha, beta, startTime) {
                // æ—¶é—´æ§åˆ¶æ£€æŸ¥
                if (performance.now() - startTime > this.timeLimit) {
                    return 0; // æ—¶é—´ä¸å¤Ÿï¼Œè¿”å›ä¸­æ€§å€¼
                }
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
                if (depth === 0) {
                    return this.evaluateBoard(board);
                }
                
                // ç½®æ¢è¡¨æŸ¥æ‰¾
                const boardHash = this.getBoardHash(board);
                const ttEntry = this.transpositionTable.get(boardHash);
                if (ttEntry && ttEntry.depth >= depth) {
                    return ttEntry.score;
                }
                
                const possibleMoves = this.getPossibleMoves(board);
                
                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (const move of possibleMoves) {
                        const {row, col} = move;
                        board[row][col] = AI_PLAYER;
                        
                        const evaluation = this.minimax(board, depth - 1, false, alpha, beta, startTime);
                        board[row][col] = EMPTY;
                        
                        maxEval = Math.max(maxEval, evaluation);
                        alpha = Math.max(alpha, evaluation);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    
                    // å­˜å‚¨åˆ°ç½®æ¢è¡¨
                    this.transpositionTable.set(boardHash, {score: maxEval, depth: depth});
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of possibleMoves) {
                        const {row, col} = move;
                        board[row][col] = PLAYER;
                        
                        const evaluation = this.minimax(board, depth - 1, true, alpha, beta, startTime);
                        board[row][col] = EMPTY;
                        
                        minEval = Math.min(minEval, evaluation);
                        beta = Math.min(beta, evaluation);
                        if (beta <= alpha) break; // Alpha-Betaå‰ªæ
                    }
                    
                    // å­˜å‚¨åˆ°ç½®æ¢è¡¨
                    this.transpositionTable.set(boardHash, {score: minEval, depth: depth});
                    return minEval;
                }
            }
            
            // è·å–æ£‹ç›˜å“ˆå¸Œå€¼ï¼ˆç”¨äºç½®æ¢è¡¨ï¼‰
            getBoardHash(board) {
                let hash = 0;
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        hash = (hash * 3 + board[row][col]) % 1000000007;
                    }
                }
                return hash;
            }
            
            // è¯„ä¼°æ£‹ç›˜çŠ¶æ€ - ä¼˜åŒ–ç‰ˆ
            evaluateBoard(board) {
                // æ£€æŸ¥ç¼“å­˜
                const boardHash = this.getBoardHash(board);
                const cachedEval = this.evaluationCache.get(boardHash);
                if (cachedEval !== undefined) {
                    performanceMetrics.cacheHits++;
                    return cachedEval;
                }
                
                performanceMetrics.totalEvaluations++;
                let score = 0;
                
                // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„äº”è¿ç æ–¹å‘
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            // ä¸ºæ¯ä¸ªä½ç½®è®¡ç®—åˆ†æ•°
                            score += this.evaluatePosition(board, row, col);
                        }
                    }
                }
                
                // ç¼“å­˜ç»“æœ
                this.evaluationCache.set(boardHash, score);
                
                return score;
            }
            
            // å¢å¼ºç‰ˆè¯„ä¼°å‡½æ•° - å¼ºåŒ–é˜²å®ˆç‰ˆ
            evaluatePosition(board, row, col) {
                const player = board[row][col];
                const directions = [
                    [0, 1], [1, 0], [1, 1], [1, -1] // æ°´å¹³ã€å‚ç›´ã€å¯¹è§’çº¿ã€åå¯¹è§’çº¿
                ];
                
                let totalScore = 0;
                
                for (const [dx, dy] of directions) {
                    let count = 1; // å½“å‰ä½ç½®å·²ç»æœ‰ä¸€ä¸ªæ£‹å­
                    let openEnds = 0;
                    let blocked = false;
                    
                    // æ­£å‘æ£€æŸ¥
                    let r = row + dx, c = col + dy;
                    let consecutive = true;
                    
                    // è®°å½•è¿ç»­æ£‹å­
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            blocked = true;
                            consecutive = false;
                        }
                        r += dx;
                        c += dy;
                    }
                    
                    // åå‘æ£€æŸ¥
                    r = row - dx;
                    c = col - dy;
                    consecutive = true;
                    
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            blocked = true;
                            consecutive = false;
                        }
                        r -= dx;
                        c -= dy;
                    }
                    
                    // æ ¹æ®è¿ç»­æ£‹å­å’Œå¼€æ”¾ç«¯åˆ†é…åˆ†æ•° - å¼ºåŒ–é˜²å®ˆæƒé‡
                    if (count >= 5) {
                        totalScore += 1000000; // èƒœåˆ© - æé«˜æƒé‡
                    } else if (count === 4) {
                        if (openEnds === 2) totalScore += 100000; // æ´»å›› - å¤§å¹…æé«˜
                        else if (openEnds === 1) totalScore += 30000; // å†²å››
                    } else if (count === 3) {
                        if (openEnds === 2) totalScore += 15000; // æ´»ä¸‰ - å¤§å¹…æé«˜
                        else if (openEnds === 1) totalScore += 3000; // çœ ä¸‰
                    } else if (count === 2) {
                        if (openEnds === 2) totalScore += 1500; // æ´»äºŒ
                        else if (openEnds === 1) totalScore += 400; // çœ äºŒ
                    } else if (count === 1) {
                        if (openEnds === 2) totalScore += 200; // æ´»ä¸€
                    }
                    
                    // åŒä¸‰å’ŒåŒå››æ£€æµ‹ - æé«˜æƒé‡
                    if (count === 3 && openEnds === 2) {
                        totalScore += this.checkDoubleThreat(board, row, col, player) * 10000;
                    } else if (count === 4 && openEnds >= 1) {
                        totalScore += this.checkDoubleThreat(board, row, col, player) * 20000;
                    }
                }
                
                // ä½ç½®æƒé‡åŠ æˆ
                totalScore *= POSITION_WEIGHTS[row][col];
                
                // è§’è½æƒ©ç½š
                if ((row === 0 || row === BOARD_SIZE-1) && (col === 0 || col === BOARD_SIZE-1)) {
                    totalScore *= 0.05; // æå¤§é™ä½è§’è½åˆ†æ•°
                } else if (row === 0 || row === BOARD_SIZE-1 || col === 0 || col === BOARD_SIZE-1) {
                    totalScore *= 0.7; // è¾¹ç¼˜ä½ç½®é™ä½æƒé‡
                }
                
                // å¦‚æœæ˜¯æ•Œæ–¹æ£‹å­ï¼Œåˆ†æ•°ä¸ºè´Ÿï¼Œä½†æƒé‡æ›´é«˜ï¼ˆå¼ºåŒ–é˜²å®ˆï¼‰
                if (player === PLAYER) {
                    totalScore = -totalScore * 1.8; // å¤§å¹…æé«˜é˜²å®ˆæƒé‡
                }
                
                return totalScore;
            }
            
            // æ£€æŸ¥åŒé‡å¨èƒï¼ˆåŒä¸‰ã€åŒå››ï¼‰
            checkDoubleThreat(board, row, col, player) {
                let threats = 0;
                const directions = [
                    [0, 1], [1, 0], [1, 1], [1, -1]
                ];
                
                for (const [dx, dy] of directions) {
                    let count = 1;
                    let openEnds = 0;
                    
                    // æ­£å‘
                    let r = row + dx, c = col + dy;
                    let consecutive = true;
                    
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            consecutive = false;
                        }
                        r += dx;
                        c += dy;
                    }
                    
                    // åå‘
                    r = row - dx;
                    c = col - dy;
                    consecutive = true;
                    
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            consecutive = false;
                        }
                        r -= dx;
                        c -= dy;
                    }
                    
                    // æ£€æŸ¥å¨èƒç±»å‹
                    if (count >= 4 && openEnds >= 1) {
                        threats++;
                    } else if (count === 3 && openEnds >= 2) {
                        threats++;
                    }
                }
                
                return threats >= 2 ? 1 : 0;
            }
            
            // æ–°å¢ï¼šæŸ¥æ‰¾AIè‡ªèº«è¿›æ”»æœºä¼šï¼ˆæ´»ä¸‰å˜æ´»å››/å†²å››ï¼‰
            findAttackMove(board) {
                const attackMoves = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            
                            board[row][col] = AI_PLAYER;
                            const threatLevel = this.getThreatLevel(board, row, col);
                            board[row][col] = EMPTY;
                            if (threatLevel >= 4) { // æ´»å››æˆ–æ›´é«˜
                                attackMoves.push({row, col, priority: 100000});
                            } else if (threatLevel === 3) { // æ´»ä¸‰
                                attackMoves.push({row, col, priority: 50000});
                            }
                        }
                    }
                }
                attackMoves.sort((a, b) => b.priority - a.priority);
                if (attackMoves.length > 0) {
                    const move = {row: attackMoves[0].row, col: attackMoves[0].col};
                    if (board[move.row][move.col] === EMPTY) return move;
                }
                return null;
            }
            // æ–°å¢ï¼šæŸ¥æ‰¾AIè‡ªèº«äº”è¿ç /æ´»å››æœºä¼š
            findWinMove(board) {
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            
                            board[row][col] = AI_PLAYER;
                            const threatLevel = this.getThreatLevel(board, row, col);
                            board[row][col] = EMPTY;
                            if (threatLevel >= 4) {
                                if (board[row][col] === EMPTY) return {row, col};
                            }
                        }
                    }
                }
                return null;
            }
            // æ–°å¢ï¼šæŸ¥æ‰¾åŒå››å¨èƒ
            findDoubleFourThreat(board) {
                const threats = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            // æ¨¡æ‹Ÿç©å®¶è½å­
                            board[row][col] = PLAYER;
                            const threatInfo = this.getDetailedThreatInfo(board, row, col);
                            board[row][col] = EMPTY;
                            // åŒå››å¨èƒï¼šä¸¤ä¸ªæˆ–æ›´å¤šå››è¿ç å¨èƒ
                            if (threatInfo.liveFour >= 2) {
                                threats.push({row, col, priority: 200000});
                            }
                        }
                    }
                }
                // æŒ‰ä¼˜å…ˆçº§æ’åº
                threats.sort((a, b) => b.priority - a.priority);
                return threats.length > 0 ? threats[0] : null;
            }
            // æ–°å¢ï¼šæŸ¥æ‰¾å››ä¸‰å¨èƒ
            findFourThreeThreat(board) {
                const threats = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            // æ¨¡æ‹Ÿç©å®¶è½å­
                            board[row][col] = PLAYER;
                            const threatInfo = this.getDetailedThreatInfo(board, row, col);
                            board[row][col] = EMPTY;
                            // å››ä¸‰å¨èƒï¼šè‡³å°‘ä¸€ä¸ªå››è¿ç å’Œä¸€ä¸ªæ´»ä¸‰
                            if (threatInfo.liveFour >= 1 && threatInfo.liveThree >= 1) {
                                threats.push({row, col, priority: 180000});
                            }
                        }
                    }
                }
                // æŒ‰ä¼˜å…ˆçº§æ’åº
                threats.sort((a, b) => b.priority - a.priority);
                return threats.length > 0 ? threats[0] : null;
            }
            // æ–°å¢ï¼šæŸ¥æ‰¾åŒæ´»ä¸‰å¨èƒ
            findDoubleLiveThreeThreat(board) {
                const threats = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            // æ¨¡æ‹Ÿç©å®¶è½å­
                            board[row][col] = PLAYER;
                            const threatInfo = this.getDetailedThreatInfo(board, row, col);
                            board[row][col] = EMPTY;
                            // åŒæ´»ä¸‰å¨èƒï¼šä¸¤ä¸ªæˆ–æ›´å¤šæ´»ä¸‰
                            if (threatInfo.liveThree >= 2) {
                                threats.push({row, col, priority: 160000});
                            }
                        }
                    }
                }
                // æŒ‰ä¼˜å…ˆçº§æ’åº
                threats.sort((a, b) => b.priority - a.priority);
                return threats.length > 0 ? threats[0] : null;
            }
            
            // æ–°å¢ï¼šæŸ¥æ‰¾ç©å®¶ä¸‹ä¸€æ­¥èƒ½å½¢æˆäº”è¿çš„ä½ç½®
            findMustBlockMoveOld(board) {
                // æ”¶é›†æ‰€æœ‰ç©å®¶ä¸‹å­èƒ½äº”é€£çš„é»
                const winPoints = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            if ((row === 0 || row === BOARD_SIZE-1) && (col === 0 || col === BOARD_SIZE-1)) continue;
                            board[row][col] = PLAYER;
                            const willWin = this.game.checkWin(row, col);
                            board[row][col] = EMPTY;
                            this.game.winLine = null;
                            if (willWin) {
                                winPoints.push({row, col});
                            }
                        }
                    }
                }
                if (winPoints.length === 0) return null;
                // å¦‚æœåªæœ‰ä¸€å€‹å¨è„…ï¼Œç›´æ¥æ“‹
                if (winPoints.length === 1) return winPoints[0];
                // å¤šå€‹å¨è„…ï¼Œæ‰¾äº¤å‰é»ï¼ˆç†è«–ä¸Šäº”å­æ£‹åªæœ‰ä¸€å€‹äº¤å‰é»èƒ½åŒæ™‚æ“‹å¤šå€‹å¨è„…ï¼‰
                // é€™è£¡ç›´æ¥æ“‹ç¬¬ä¸€å€‹ï¼Œæˆ–å¯é€²éšåˆ†æ
                return winPoints[0];
            }
            
            // æ–°å¢ï¼šæŸ¥æ‰¾æ½œåœ¨å¨èƒï¼ˆæ´»äºŒã€è·³æ´»ä¸‰ç­‰ï¼‰
            findPotentialThreatMove(board) {
                const potentialMoves = [];
                const center = Math.floor(BOARD_SIZE / 2);
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] === EMPTY) {
                            // è·³è¿‡è§’è½ä½ç½®
                            if ((row === 0 || row === BOARD_SIZE-1) && 
                                (col === 0 || col === BOARD_SIZE-1)) {
                                continue;
                            }
                            // æ¨¡æ‹Ÿç©å®¶è½å­
                            board[row][col] = PLAYER;
                            // æ£€æŸ¥æ´»äºŒå¨èƒ
                            const liveTwoThreat = this.checkLiveTwoThreat(board, row, col, PLAYER);
                            // æ£€æŸ¥è·³æ´»äºŒå¨èƒ
                            const jumpTwoThreat = this.checkJumpTwoThreat(board, row, col, PLAYER);
                            board[row][col] = EMPTY;
                            if (liveTwoThreat || jumpTwoThreat) {
                                // è®¡ç®—å¨èƒåˆ†æ•°ï¼šä¸­å¿ƒä½ç½®æƒé‡æ›´é«˜
                                const distanceFromCenter = Math.abs(row - center) + Math.abs(col - center);
                                const positionWeight = 1.0 - (distanceFromCenter / (BOARD_SIZE * 2));
                                let threatScore = 0;
                                if (liveTwoThreat) threatScore += 8000;
                                if (jumpTwoThreat) threatScore += 6000;
                                potentialMoves.push({
                                    row, 
                                    col, 
                                    score: threatScore * positionWeight
                                });
                            }
                        }
                    }
                }
                // æŒ‰å¨èƒåˆ†æ•°é™åºæ’åº
                potentialMoves.sort((a, b) => b.score - a.score);
                return potentialMoves.length > 0 ? potentialMoves[0] : null;
            }
            // æ£€æŸ¥æ´»äºŒå¨èƒ
            checkLiveTwoThreat(board, row, col, player) {
                const directions = [[0,1],[1,0],[1,1],[1,-1]];
                for (const [dx, dy] of directions) {
                    // æ£€æŸ¥è¿ç»­æ£‹å­
                    let count = 1; // å½“å‰ä½ç½®
                    let openEnds = 0;
                    // æ­£å‘
                    let r = row + dx;
                    let c = col + dy;
                    let consecutive = true;
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            consecutive = false;
                        }
                        r += dx;
                        c += dy;
                    }
                    // åå‘
                    r = row - dx;
                    c = col - dy;
                    consecutive = true;
                    while (consecutive && r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
                        if (board[r][c] === player) {
                            count++;
                        } else if (board[r][c] === EMPTY) {
                            openEnds++;
                            consecutive = false;
                        } else {
                            consecutive = false;
                        }
                        r -= dx;
                        c -= dy;
                    }
                    // æ£€æŸ¥æ´»äºŒå¨èƒ
                    if (count === 2 && openEnds >= 2) {
                        return true;
                    }
                }
                return false;
            }
            // æ£€æŸ¥è·³æ´»äºŒå¨èƒ
            checkJumpTwoThreat(board, row, col, player) {
                const directions = [[0,1],[1,0],[1,1],[1,-1]];
                for (const [dx, dy] of directions) {
                    // æ£€æŸ¥æ­£å‘è·³æ´»äºŒ
                    let nextR = row + dx;
                    let nextC = col + dy;
                    let jumpR = row + 2 * dx;
                    let jumpC = col + 2 * dy;
                    if (jumpR >= 0 && jumpR < BOARD_SIZE && jumpC >= 0 && jumpC < BOARD_SIZE) {
                        if (board[jumpR][jumpC] === player && board[nextR][nextC] === EMPTY) {
                            // æ£€æŸ¥ä¸¤ç«¯æ˜¯å¦å¼€æ”¾
                            let openEnds = 0;
                            // è·³æ£‹ä½ç½®çš„å‰æ–¹
                            let beyondJumpR = jumpR + dx;
                            let beyondJumpC = jumpC + dy;
                            if (beyondJumpR >= 0 && beyondJumpR < BOARD_SIZE && beyondJumpC >= 0 && beyondJumpC < BOARD_SIZE) {
                                if (board[beyondJumpR][beyondJumpC] === EMPTY) openEnds++;
                            }
                            // å½“å‰ä½ç½®çš„åæ–¹
                            let behindR = row - dx;
                            let behindC = col - dy;
                            if (behindR >= 0 && behindR < BOARD_SIZE && behindC >= 0 && behindC < BOARD_SIZE) {
                                if (board[behindR][behindC] === EMPTY) openEnds++;
                            }
                            if (openEnds >= 2) {
                                return true;
                            }
                        }
                    }
                    // æ£€æŸ¥åå‘è·³æ´»äºŒ
                    nextR = row - dx;
                    nextC = col - dy;
                    jumpR = row - 2 * dx;
                    jumpC = col - 2 * dy;
                    if (jumpR >= 0 && jumpR < BOARD_SIZE && jumpC >= 0 && jumpC < BOARD_SIZE) {
                        if (board[jumpR][jumpC] === player && board[nextR][nextC] === EMPTY) {
                            let openEnds = 0;
                            // è·³æ£‹ä½ç½®çš„åæ–¹
                            let beyondJumpR = jumpR - dx;
                            let beyondJumpC = jumpC - dy;
                            if (beyondJumpR >= 0 && beyondJumpR < BOARD_SIZE && beyondJumpC >= 0 && beyondJumpC < BOARD_SIZE) {
                                if (board[beyondJumpR][beyondJumpC] === EMPTY) openEnds++;
                            }
                            // å½“å‰ä½ç½®çš„å‰æ–¹
                            let frontR = row + dx;
                            let frontC = col + dy;
                            if (frontR >= 0 && frontR < BOARD_SIZE && frontC >= 0 && frontC < BOARD_SIZE) {
                                if (board[frontR][frontC] === EMPTY) openEnds++;
                            }
                            if (openEnds >= 2) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            // --- æ–°å¢ï¼šæŸ¥æ‰¾æ£‹ç›˜ä¸Šå·²å­˜åœ¨çš„å†²å››å¨èƒ ---
            findExistingFourThreat(board) {
                const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== PLAYER) continue;
                        for (const [dx, dy] of directions) {
                            // ç¡®ä¿æ˜¯è¿ç»­æ£‹å­çš„èµ·å§‹ç‚¹
                            const prevRow = row - dx;
                            const prevCol = col - dy;
                            if (prevRow >= 0 && prevRow < BOARD_SIZE && prevCol >= 0 && prevCol < BOARD_SIZE && 
                                board[prevRow][prevCol] === PLAYER) {
                                continue;
                            }
                            let count = 1;
                            let r = row + dx;
                            let c = col + dy;
                            // ç»Ÿè®¡è¿ç»­æ£‹å­æ•°
                            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && 
                                   board[r][c] === PLAYER) {
                                count++;
                                r += dx;
                                c += dy;
                            }
                            // è®¡ç®—ç«¯ç‚¹ä½ç½®
                            const forwardEnd = { row: r, col: c };
                            // åˆ¤æ–­ç«¯ç‚¹æ˜¯å¦å¼€æ”¾
                            let forwardOpen = false;
                            if (forwardEnd.row >= 0 && forwardEnd.row < BOARD_SIZE && 
                                forwardEnd.col >= 0 && forwardEnd.col < BOARD_SIZE) {
                                if (board[forwardEnd.row][forwardEnd.col] === EMPTY) {
                                    forwardOpen = true;
                                }
                            }
                            // åˆ¤æ–­åæ–¹å‘ç«¯ç‚¹
                            const backwardEndRow = row - dx;
                            const backwardEndCol = col - dy;
                            let backwardOpen = false;
                            if (backwardEndRow >= 0 && backwardEndRow < BOARD_SIZE && 
                                backwardEndCol >= 0 && backwardEndCol < BOARD_SIZE) {
                                if (board[backwardEndRow][backwardEndCol] === EMPTY) {
                                    backwardOpen = true;
                                }
                            }
                            // å†²å››æ£€æµ‹ï¼šè¿ç»­å››é¢—æ£‹å­ä¸”åªæœ‰ä¸€ç«¯å¼€æ”¾
                            if (count === 4) {
                                if (forwardOpen && !backwardOpen) {
                                    return { row: forwardEnd.row, col: forwardEnd.col };
                                }
                                if (!forwardOpen && backwardOpen) {
                                    return { row: backwardEndRow, col: backwardEndCol };
                                }
                            }
                        }
                    }
                }
                return null;
            }
            // --- æ–°å¢ï¼šæ£€æµ‹ç‰¹å®šå¨èƒæ¨¡å¼ï¼ˆç©ºé»‘é»‘ç©ºé»‘ç©ºï¼‰ ---
            findSpecificPatternThreat(board) {
                const patterns = [
                    // æ°´å¹³
                    { pattern: [EMPTY, PLAYER, PLAYER, EMPTY, PLAYER, EMPTY], directions: [[0, 1]] },
                    // å‚ç›´
                    { pattern: [EMPTY, PLAYER, PLAYER, EMPTY, PLAYER, EMPTY], directions: [[1, 0]] },
                    // å¯¹è§’çº¿
                    { pattern: [EMPTY, PLAYER, PLAYER, EMPTY, PLAYER, EMPTY], directions: [[1, 1]] },
                    // åå¯¹è§’çº¿
                    { pattern: [EMPTY, PLAYER, PLAYER, EMPTY, PLAYER, EMPTY], directions: [[1, -1]] }
                ];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        for (const {pattern, directions} of patterns) {
                            for (const [dx, dy] of directions) {
                                let match = true;
                                let threatPoint = null;
                                for (let i = 0; i < pattern.length; i++) {
                                    const r = row + dx * i;
                                    const c = col + dy * i;
                                    if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
                                        match = false;
                                        break;
                                    }
                                    if (pattern[i] === EMPTY && board[r][c] === EMPTY && !threatPoint) {
                                        threatPoint = {row: r, col: c};
                                    }
                                    if (pattern[i] !== board[r][c]) {
                                        match = false;
                                        break;
                                    }
                                }
                                if (match && threatPoint && board[threatPoint.row][threatPoint.col] === EMPTY) {
                                    return threatPoint;
                                }
                            }
                        }
                    }
                }
                return null;
            }
        }
        
        // æ¸²æŸ“ç±»
        class Renderer {
            constructor(canvas, game) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.game = game;
                this.highlight = null;
                this.hintPosition = null;
                this.lastAIMove = null; // AIæœ€åä¸€æ­¥çš„ä½ç½®
                this.resizeCanvas();
                this.winLine = null;
            }
            
            // è°ƒæ•´ç”»å¸ƒå¤§å°
            resizeCanvas() {
                const cellSize = calculateCellSize();
                const boardSize = BOARD_SIZE * cellSize;
                const dpr = window.devicePixelRatio || 1;

                // è®¾ç½®ç”»å¸ƒå®é™…åƒç´ å°ºå¯¸
                this.canvas.width = boardSize * dpr;
                this.canvas.height = boardSize * dpr;

                // è®¾ç½®ç”»å¸ƒCSSæ˜¾ç¤ºå°ºå¯¸
                this.canvas.style.width = boardSize + "px";
                this.canvas.style.height = boardSize + "px";

                // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡
                this.ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®
                this.ctx.scale(dpr, dpr);

                // é‡ç»˜æ£‹ç›˜
                this.drawBoard();
            }
            
            // ç»˜åˆ¶æ£‹ç›˜
            drawBoard() {
                const ctx = this.ctx;
                const cellSize = calculateCellSize();
                const boardSize = BOARD_SIZE * cellSize;
                const offset = cellSize / 2;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶æ£‹ç›˜èƒŒæ™¯
                ctx.fillStyle = '#dcb35c';
                ctx.fillRect(0, 0, boardSize, boardSize);
                
                // ç»˜åˆ¶ç½‘æ ¼çº¿
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                
                for (let i = 0; i < BOARD_SIZE; i++) {
                    // æ¨ªçº¿
                    ctx.beginPath();
                    ctx.moveTo(offset, i * cellSize + offset);
                    ctx.lineTo(boardSize - offset, i * cellSize + offset);
                    ctx.stroke();
                    
                    // ç«–çº¿
                    ctx.beginPath();
                    ctx.moveTo(i * cellSize + offset, offset);
                    ctx.lineTo(i * cellSize + offset, boardSize - offset);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å¤©å…ƒå’Œæ˜Ÿä½
                const starPoints = [3, 9, 15];
                ctx.fillStyle = '#000';
                
                for (const x of starPoints) {
                    for (const y of starPoints) {
                        ctx.beginPath();
                        ctx.arc(
                            x * cellSize + offset,
                            y * cellSize + offset,
                            4, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                // ç»˜åˆ¶æ£‹å­
                const board = this.game.getBoard();
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (board[row][col] !== EMPTY) {
                            this.drawPiece(row, col, board[row][col]);
                        }
                    }
                }
                
                // ç»˜åˆ¶æç¤ºä½ç½®
                if (this.hintPosition) {
                    const {row, col} = this.hintPosition;
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.5)';
                    ctx.beginPath();
                    ctx.arc(
                        col * cellSize + offset,
                        row * cellSize + offset,
                        cellSize / 3, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // ç»˜åˆ¶é«˜äº®ä½ç½®
                if (this.highlight) {
                    const {row, col} = this.highlight;
                    ctx.fillStyle = 'rgba(253, 187, 45, 0.3)';
                    ctx.beginPath();
                    ctx.arc(
                        col * cellSize + offset,
                        row * cellSize + offset,
                        cellSize / 2.5, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                
                // ç»˜åˆ¶AIæœ€åä¸€æ­¥çš„æ ‡ç¤º
                if (this.lastAIMove) {
                    const {row, col} = this.lastAIMove;
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(
                        col * cellSize + offset,
                        row * cellSize + offset,
                        cellSize / 2 + 2, 0, Math.PI * 2
                    );
                    ctx.stroke();
                    
                    // æ·»åŠ é—ªçƒåŠ¨ç”»æ•ˆæœ
                    ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(
                        col * cellSize + offset,
                        row * cellSize + offset,
                        cellSize / 2 + 4, 0, Math.PI * 2
                    );
                    ctx.stroke();
                }
                // æ–°å¢ï¼šç»˜åˆ¶èƒœåˆ©çº¢çº¿
                if (this.winLine && this.winLine.length === 5) {
                    this.drawWinLine(this.winLine);
                }
            }
            
            // ç»˜åˆ¶æ£‹å­
            drawPiece(row, col, player) {
                const ctx = this.ctx;
                const cellSize = calculateCellSize();
                const offset = cellSize / 2;
                const x = col * cellSize + offset;
                const y = row * cellSize + offset;
                const radius = cellSize / 2 - 2;
                
                // è·å–ç©å®¶çš„æ£‹å­é¢œè‰²
                const color = this.game.getPlayerColor(player);
                
                // åˆ›å»ºæ£‹å­æ¸å˜æ•ˆæœ
                const gradient = ctx.createRadialGradient(
                    x - radius/3, y - radius/3, 1,
                    x, y, radius
                );
                
                if (color === BLACK) {
                    gradient.addColorStop(0, "#111");
                    gradient.addColorStop(1, "#000");
                } else {
                    gradient.addColorStop(0, "#FFF");
                    gradient.addColorStop(1, "#DDD");
                }
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // æ·»åŠ æ£‹å­å…‰æ³½æ•ˆæœ
                ctx.fillStyle = color === BLACK ? "rgba(255, 255, 255, 0.15)" : "rgba(0, 0, 0, 0.1)";
                ctx.beginPath();
                ctx.arc(x - radius/3, y - radius/3, radius/3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // è®¾ç½®é«˜äº®ä½ç½®
            setHighlight(row, col) {
                this.highlight = {row, col};
                this.drawBoard();
            }
            
            // è®¾ç½®æç¤ºä½ç½®
            setHintPosition(row, col) {
                this.hintPosition = {row, col};
                this.drawBoard();
            }
            
            // æ¸…é™¤æç¤º
            clearHint() {
                this.hintPosition = null;
                this.drawBoard();
            }
            
            // è®¾ç½®AIæœ€åä¸€æ­¥
            setLastAIMove(row, col) {
                this.lastAIMove = {row, col};
                this.drawBoard();
            }
            
            // æ¸…é™¤AIæœ€åä¸€æ­¥æ ‡ç¤º
            clearLastAIMove() {
                this.lastAIMove = null;
                this.drawBoard();
            }
            
            // æ–°å¢ï¼šç»˜åˆ¶èƒœåˆ©çº¢çº¿
            drawWinLine(line) {
                const ctx = this.ctx;
                const cellSize = calculateCellSize();
                const offset = cellSize / 2;
                ctx.save();
                ctx.strokeStyle = '#ff2222';
                ctx.lineWidth = 6;
                ctx.shadowColor = '#ff2222';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                const start = line[0];
                const end = line[4];
                ctx.moveTo(start.col * cellSize + offset, start.row * cellSize + offset);
                ctx.lineTo(end.col * cellSize + offset, end.row * cellSize + offset);
                ctx.stroke();
                ctx.restore();
            }
            
            // æ–°å¢ï¼šè®¾ç½®èƒœåˆ©çº¿
            setWinLine(line) {
                this.winLine = line;
                this.drawBoard();
            }
        }
        
        // UIæ§åˆ¶å™¨ç±»
        class UIController {
            constructor(game, ai, renderer) {
                this.game = game;
                this.ai = ai;
                this.renderer = renderer;
                this.canvas = renderer.canvas;
                this.isPlayerTurn = true;
                this.currentDifficulty = 2;
                this.isMultiTouch = false;
                this.lastTouchTime = 0;
                this.playerFirstChoice = true; // æ–°å¢ï¼šè®°å½•ç”¨æˆ·é€‰æ‹©çš„å…ˆæ‰‹
                this.setupEventListeners();
                
                // æ·»åŠ çª—å£å¤§å°è°ƒæ•´ç›‘å¬
                window.addEventListener('resize', () => {
                    this.renderer.resizeCanvas();
                });
                
                // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
                if (isMobileDevice()) {
                    this.ai.enableMobileMode();
                    performanceMetrics.mobileMode = true;
                    console.log("ç§»åŠ¨è®¾å¤‡æ¨¡å¼å·²å¯ç”¨");
                }
            }
            
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
            setupEventListeners() {
                // æ£‹ç›˜ç‚¹å‡»äº‹ä»¶
                this.canvas.addEventListener('click', (e) => {
                    if (!this.isPlayerTurn || this.game.gameOver || performanceMetrics.isZooming) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const cellSize = calculateCellSize();
                    const col = Math.floor(x / cellSize);
                    const row = Math.floor(y / cellSize);
                    
                    if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                        this.handlePlayerMove(row, col);
                    }
                });
                
                // è§¦æ‘¸äº‹ä»¶å¤„ç† - ç®€åŒ–ç‰ˆï¼Œç¡®ä¿ç¼©æ”¾åŠŸèƒ½æ­£å¸¸
                let touchStartTime = 0;
                let touchStartX = 0;
                let touchStartY = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length > 1) {
                        // å¤šç‚¹è§¦æ§ - æ˜¾ç¤ºç¼©æ”¾æç¤ºï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸º
                        const zoomIndicator = document.getElementById('zoomIndicator');
                        zoomIndicator.style.display = 'block';
                        zoomIndicator.classList.add('zooming');
                        zoomIndicator.textContent = 'ğŸ–ï¸ åŒæŒ‡ç¼©æ”¾ä¸­';
                        return;
                    }
                    
                    // å•æŒ‡è§¦æ‘¸ - è®°å½•èµ·å§‹ä½ç½®å’Œæ—¶é—´
                    if (e.touches.length === 1) {
                        touchStartTime = Date.now();
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 1) {
                        // å¤šç‚¹è§¦æ§ - æ˜¾ç¤ºç¼©æ”¾æç¤º
                        const zoomIndicator = document.getElementById('zoomIndicator');
                        zoomIndicator.style.display = 'block';
                        zoomIndicator.classList.add('zooming');
                        zoomIndicator.textContent = 'ğŸ–ï¸ åŒæŒ‡ç¼©æ”¾ä¸­';
                        return;
                    }
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    // éšè—ç¼©æ”¾æç¤º
                    const zoomIndicator = document.getElementById('zoomIndicator');
                    zoomIndicator.style.display = 'none';
                    zoomIndicator.classList.remove('zooming');
                    
                    // å¦‚æœæ˜¯å¤šç‚¹è§¦æ§ç»“æŸï¼Œä¸å¤„ç†ç‚¹å‡»
                    if (e.touches.length > 0) {
                        return;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„å•æŒ‡ç‚¹å‡»
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - touchStartTime;
                    
                    // åªå¤„ç†çŸ­æ—¶é—´çš„ç‚¹å‡»ï¼ˆé¿å…ä¸æ»šåŠ¨å†²çªï¼‰
                    if (touchDuration > 50 && touchDuration < 500) {
                        if (!this.isPlayerTurn || this.game.gameOver) return;
                        
                        const rect = this.canvas.getBoundingClientRect();
                        const touch = e.changedTouches[0];
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        
                        const cellSize = calculateCellSize();
                        const col = Math.floor(x / cellSize);
                        const row = Math.floor(y / cellSize);
                        
                        if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                            this.handlePlayerMove(row, col);
                        }
                    }
                });
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('playerFirstBtn').addEventListener('click', () => {
                    this.setFirstPlayer(true);
                });
                
                document.getElementById('aiFirstBtn').addEventListener('click', () => {
                    this.setFirstPlayer(false);
                });
                
                document.getElementById('hintBtn').addEventListener('click', () => {
                    this.showHint();
                });
                
                document.getElementById('undoBtn').addEventListener('click', () => {
                    this.undoMove();
                });
                
                // éš¾åº¦æ»‘å—
                document.getElementById('difficultySlider').addEventListener('input', (e) => {
                    const difficulty = parseInt(e.target.value);
                    this.setDifficulty(difficulty);
                    this.currentDifficulty = difficulty;
                });
                
                // é¼ æ ‡æ‚¬åœé«˜äº®ï¼ˆä»…åœ¨éç§»åŠ¨è®¾å¤‡ä¸Šï¼‰
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.game.gameOver || performanceMetrics.mobileMode) return;
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const cellSize = calculateCellSize();
                    const col = Math.floor(x / cellSize);
                    const row = Math.floor(y / cellSize);
                    
                    if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                        if (this.game.board[row][col] === EMPTY) {
                            this.renderer.setHighlight(row, col);
                        } else {
                            this.renderer.setHighlight(null);
                        }
                    } else {
                        this.renderer.setHighlight(null);
                    }
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.renderer.setHighlight(null);
                });
                
                // ä¿®å¤æ¸¸æˆç»“æŸçª—å£å…³é—­é—®é¢˜
                document.getElementById('closeWinBtn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const winMsg = document.getElementById('winMessage');
                    if (winMsg) {
                        winMsg.classList.add('hidden');
                        console.log('æ¸¸æˆç»“æŸçª—å£å·²å…³é—­');
                    }
                });
                
                document.getElementById('newGameBtn').addEventListener('click', () => {
                    this.startNewGame(this.playerFirstChoice); // ä¿®æ­£ï¼šå§‹ç»ˆç”¨ç”¨æˆ·é€‰æ‹©çš„å…ˆæ‰‹
                });
            }
            
            // è®¾ç½®å…ˆæ‰‹ç©å®¶
            setFirstPlayer(playerFirst) {
                this.playerFirstChoice = playerFirst; // ä¿®æ­£ï¼šè®°å½•ç”¨æˆ·é€‰æ‹©
                document.getElementById('playerFirstBtn').classList.toggle('active', playerFirst);
                document.getElementById('aiFirstBtn').classList.toggle('active', !playerFirst);
                this.startNewGame(playerFirst);
            }
            
            // å¼€å§‹æ–°æ¸¸æˆ
            startNewGame(playerFirst = true) {
                this.game.reset();
                
                // è®¾ç½®æ£‹å­é¢œè‰²
                if (playerFirst) {
                    // ç©å®¶å…ˆæ‰‹ï¼šç©å®¶æ‰§é»‘ï¼ŒAIæ‰§ç™½
                    this.game.setPieceColors(PLAYER, AI_PLAYER);
                } else {
                    // AIå…ˆæ‰‹ï¼šAIæ‰§é»‘ï¼Œç©å®¶æ‰§ç™½
                    this.game.setPieceColors(AI_PLAYER, PLAYER);
                    this.game.setCurrentPlayer(AI_PLAYER);
                }
                
                this.ai.clearCache(); // æ¸…ç†AIç¼“å­˜
                this.renderer.clearHint();
                this.renderer.clearLastAIMove(); // æ¸…é™¤AIæœ€åä¸€æ­¥æ ‡ç¤º
                this.isPlayerTurn = playerFirst;
                this.renderer.resizeCanvas();
                this.updateUI();
                
                // éšè—æ¸¸æˆç»“æŸå¼¹çª—
                const winMsg = document.getElementById('winMessage');
                if (winMsg) {
                    winMsg.classList.add('hidden');
                }
                document.getElementById('evaluatedPoints').textContent = '0';
                document.getElementById('cacheHits').textContent = '0';
                document.getElementById('threatLevel').textContent = 'æ— ';
                document.getElementById('defenseMode').textContent = 'æ­£å¸¸';
                document.getElementById('aiProgressBar').style.width = '0%';
                document.getElementById('aiProgressText').textContent = 'å‡†å¤‡å¼€å§‹æ€è€ƒ...';
                document.getElementById('zoomIndicator').style.display = 'none';
                document.getElementById('cornerWarning').style.display = 'none';
                document.getElementById('threatIndicator').style.display = 'none';
                
                if (!playerFirst) {
                    this.makeAIMove();
                }
                this.renderer.winLine = null;
                this.renderer.drawBoard();
            }
            
            // å¤„ç†ç©å®¶ç§»åŠ¨
            handlePlayerMove(row, col) {
                if (this.game.makeMove(row, col)) {
                    // æ¸…é™¤AIæœ€åä¸€æ­¥çš„æ ‡ç¤º
                    this.renderer.clearLastAIMove();
                    this.updateUI();
                    
                    if (this.game.gameOver) {
                        this.showGameResult();
                    } else {
                        this.isPlayerTurn = false;
                        // ç§»åŠ¨è®¾å¤‡ä¸Šå¢åŠ å»¶è¿Ÿï¼Œç¡®ä¿UIæ›´æ–°
                        setTimeout(() => this.makeAIMove(), performanceMetrics.mobileMode ? 300 : 100);
                    }
                }
            }
            
            // AIç§»åŠ¨
            makeAIMove() {
                if (this.game.gameOver) return;
                
                // æ˜¾ç¤ºAIæ€è€ƒä¸­
                const aiThinking = document.getElementById('aiThinking');
                const aiDepth = document.getElementById('aiDepth');
                aiDepth.textContent = this.ai.depth;
                aiThinking.style.display = 'block';
                
                // é‡ç½®è¿›åº¦æ¡
                document.getElementById('aiProgressBar').style.width = '0%';
                document.getElementById('aiProgressText').textContent = 'å‡†å¤‡å¼€å§‹æ€è€ƒ...';
                
                // ç§»åŠ¨è®¾å¤‡ä¸Šå¢åŠ å»¶è¿Ÿï¼Œç¡®ä¿UIæ›´æ–°
                const delay = performanceMetrics.mobileMode ? 100 : 0;
                
                setTimeout(() => {
                    const startTime = performance.now();
                    const move = this.ai.getBestMove();
                    const timeTaken = performance.now() - startTime;
                    
                    // ç¡®ä¿è‡³å°‘æ˜¾ç¤º500msï¼Œè®©ç”¨æˆ·çœ‹åˆ°è¿›åº¦
                    const minDisplayTime = Math.max(0, 500 - timeTaken);
                    
                    setTimeout(() => {
                        aiThinking.style.display = 'none';
                        
                        if (move && this.game.makeMove(move.row, move.col)) {
                            // è®¾ç½®AIæœ€åä¸€æ­¥çš„æ ‡ç¤º
                            this.renderer.setLastAIMove(move.row, move.col);
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯è§’è½è½å­
                            if ((move.row === 0 || move.row === BOARD_SIZE-1) && 
                                (move.col === 0 || move.col === BOARD_SIZE-1)) {
                                document.getElementById('cornerWarning').style.display = 'block';
                            } else {
                                document.getElementById('cornerWarning').style.display = 'none';
                            }
                            
                            this.updateUI();
                            
                            if (this.game.gameOver) {
                                this.showGameResult();
                            } else {
                                this.isPlayerTurn = true;
                            }
                        }
                    }, minDisplayTime);
                }, delay);
            }
            
            // æ˜¾ç¤ºæç¤º
            showHint() {
                if (this.game.gameOver || !this.isPlayerTurn) return;
                
                const hint = this.ai.getHint();
                if (hint) {
                    this.renderer.setHintPosition(hint.row, hint.col);
                    
                    // 3ç§’åæ¸…é™¤æç¤º
                    setTimeout(() => {
                        this.renderer.clearHint();
                    }, 3000);
                }
            }
            
            // æ’¤é”€ä¸€æ­¥
            undoMove() {
                if (this.game.undo()) {
                    this.renderer.drawBoard();
                    this.updateUI();
                    this.isPlayerTurn = true;
                }
            }
            
            // è®¾ç½®éš¾åº¦
            setDifficulty(level) {
                this.ai.setDifficulty(level);
                const difficulty = DIFFICULTY_LEVELS[level - 1];
                document.getElementById('difficultyValue').textContent = difficulty.name;
                document.getElementById('aiLevelDisplay').textContent = difficulty.name;
                document.getElementById('difficultyLevel').textContent = `${level}/5`;
            }
            
            // æ›´æ–°UIçŠ¶æ€
            updateUI() {
                // æ›´æ–°å½“å‰ç©å®¶æ˜¾ç¤º
                const currentPlayer = this.game.getCurrentPlayer();
                const playerColor = this.game.getPlayerColor(currentPlayer);
                const colorText = playerColor === BLACK ? 'é»‘æ£‹' : 'ç™½æ£‹';
                const playerText = currentPlayer === PLAYER ? `ç©å®¶ (${colorText})` : `AI (${colorText})`;
                document.getElementById('currentPlayer').textContent = playerText;
                
                // æ›´æ–°ç§»åŠ¨è®¡æ•°
                document.getElementById('moveCount').textContent = this.game.getMoveHistory().length;
                
                // æ›´æ–°å†å²è®°å½•
                this.updateHistoryList();
                
                // æ›´æ–°å›åˆçŠ¶æ€æ˜¾ç¤º
                const turnStatus = this.isPlayerTurn ? 'ç­‰å¾…ç©å®¶è½å­' : 'AIæ€è€ƒä¸­';
                document.getElementById('currentPlayer').textContent = `${playerText} - ${turnStatus}`;
                
                // æ›´æ–°å¨èƒæ˜¾ç¤º
                this.ai.updateThreatDisplay(this.game.getBoard());
            }
            
            // æ›´æ–°å†å²è®°å½•åˆ—è¡¨
            updateHistoryList() {
                const historyList = document.getElementById('historyList');
                historyList.innerHTML = '';
                const moves = this.game.getMoveHistory();
                const moveTexts = [];
                moves.forEach((move, index) => {
                    const moveElement = document.createElement('div');
                    moveElement.className = 'history-item';
                    const playerColor = this.game.getPlayerColor(move.player);
                    const colorText = playerColor === BLACK ? 'é»‘æ£‹' : 'ç™½æ£‹';
                    const moveText = `#${index+1}: ${move.player === PLAYER ? 'ç©å®¶' : 'AI'} (${colorText}) è½å­äº (${move.row+1}, ${move.col+1})`;
                    moveElement.textContent = moveText;
                    moveTexts.push(moveText);
                    // å–®æ­¥è¤‡è£½æŒ‰éˆ•ï¼ˆå¦‚éœ€ä¿ç•™ï¼‰
                    // ...
                    historyList.appendChild(moveElement);
                });
                // è¤‡è£½å…¨éƒ¨æŒ‰éˆ•äº‹ä»¶
                const copyAllBtn = document.getElementById('copyAllHistoryBtn');
                if (copyAllBtn) {
                    copyAllBtn.onclick = () => {
                        const allText = moveTexts.join('\n');
                        if (navigator.clipboard) {
                            navigator.clipboard.writeText(allText);
                        } else {
                            // å…¼å®¹èˆŠç€è¦½å™¨
                            const textarea = document.createElement('textarea');
                            textarea.value = allText;
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                        }
                        copyAllBtn.textContent = 'å·²è¤‡è£½!';
                        setTimeout(() => { copyAllBtn.textContent = 'è¤‡è£½å…¨éƒ¨'; }, 1000);
                    };
                }
                // æ»šåŠ¨åˆ°åº•éƒ¨
                historyList.scrollTop = historyList.scrollHeight;
            }
            
            // æ˜¾ç¤ºæ¸¸æˆç»“æœ
            showGameResult() {
                const winMessage = document.getElementById('winMessage');
                const winTitle = document.getElementById('winTitle');
                const winText = document.getElementById('winText');
                if (winMessage) {
                    winMessage.classList.remove('hidden');
                }
                // æ–°å¢ï¼šæ˜¾ç¤ºèƒœåˆ©çº¢çº¿
                const winLine = this.game.getWinLine();
                if (winLine && winLine.length === 5) {
                    this.renderer.setWinLine(winLine);
                }
                if (this.game.winner === PLAYER) {
                    winTitle.textContent = 'æ­å–œï¼';
                    winText.textContent = 'æ‚¨èµ¢å¾—äº†æ¯”èµ›ï¼';
                } else if (this.game.winner === AI_PLAYER) {
                    winTitle.textContent = 'æ¸¸æˆç»“æŸ';
                    winText.textContent = 'AIèµ¢å¾—äº†æ¯”èµ›';
                } else {
                    winTitle.textContent = 'å¹³å±€ï¼';
                    winText.textContent = 'æ£‹ç›˜å·²æ»¡ï¼Œæ²¡æœ‰èµ¢å®¶';
                }
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        window.onload = function() {
            const canvas = document.getElementById('boardCanvas');
            const game = new Game();
            const ai = new AI(game);
            const renderer = new Renderer(canvas, game);
            
            // åˆå§‹åŒ–UIæ§åˆ¶å™¨
            const uiController = new UIController(game, ai, renderer);
            
            // é»˜è®¤ç©å®¶å…ˆæ‰‹
            uiController.startNewGame(true);
            
            // è®¾ç½®é»˜è®¤éš¾åº¦
            uiController.setDifficulty(2);
        };
    </script>
</body>
</html>