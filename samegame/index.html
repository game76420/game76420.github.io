<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Same Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .game-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        .game-board {
            display: grid;
            gap: 2px;
            background-color: #00bf00;
            padding: 2px;
            border-radius: 5px;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .cell.marble {
            border-radius: 50%;
            position: relative;
        }

        .cell.marble::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            width: 30%;
            height: 30%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
        }

        .cell.marble::after {
            content: '';
            position: absolute;
            bottom: 20%;
            right: 20%;
            width: 30%;
            height: 30%;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        /* Remove highlight and shadow for empty cells in Marble style */
        .cell.marble.empty::before,
        .cell.marble.empty::after {
            display: none;
        }

        /* Simple elimination styles */
        .cell.eliminating {
            opacity: 0;
            transition: opacity 0.1s ease-out;
            pointer-events: none;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            padding: 10px;
            background-color: #C0C0C0;
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        .menu-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .menu-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .menu-button:hover {
            background-color: #45a049;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            min-width: 300px;
        }

        .score-list {
            list-style: none;
            padding: 0;
        }

        .score-list li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        @media (max-width: 600px) {
            body {
                padding: 0;
            }
            .game-container {
                padding: 4px;
                border-radius: 0;
                min-width: unset;
                width: 100vw;
                box-sizing: border-box;
                margin: 0;
            }
            .menu-bar {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
                width: 100%;
            }
            .menu-button {
                padding: 16px 0;
                font-size: 1.2em;
                width: 100%;
                min-height: 48px;
            }
            .game-board {
                gap: 2px;
                padding: 2px;
                border-radius: 3px;
                width: 100vw;
                min-width: unset;
                max-width: 100vw;
                justify-content: center;
            }
            .cell {
                width: 36px;
                height: 36px;
                font-size: 1.1em;
                min-width: 32px;
                min-height: 32px;
            }
            .status-bar {
                flex-direction: column;
                gap: 6px;
                font-size: 1.1em;
                padding: 8px;
                margin-top: 10px;
                width: 100%;
            }
            .modal-content {
                min-width: unset;
                width: 98vw;
                padding: 10px;
                border-radius: 8px;
            }
            .modal {
                align-items: flex-end;
                padding-bottom: 10vh;
            }
            h2 {
                font-size: 1.3em;
            }
            #score-list li {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="menu-bar">
            <button class="menu-button" onclick="newGame()">新遊戲</button>
            <button class="menu-button" onclick="replay()">重播</button>
            <button class="menu-button" onclick="undo()">復原</button>
            <button class="menu-button" onclick="showScore()">分數</button>
            <button class="menu-button" onclick="toggleSound()">音效：開啟</button>
            <select class="menu-button" onchange="setSize(this.value)">
                <option value="normal">一般尺寸</option>
                <option value="large">大尺寸</option>
            </select>
            <select class="menu-button" onchange="setStyle(this.value)">
                <option value="panel">方塊風格</option>
                <option value="marble">彈珠風格</option>
            </select>
        </div>
        <div id="game-board" class="game-board"></div>
        <div class="status-bar">
            <div id="mark-label">標記：0（點數：0）</div>
            <div id="time-label">時間：0秒</div>
            <div id="score-label">分數：0</div>
        </div>
    </div>

    <!-- Score Modal -->
    <div id="score-modal" class="modal">
        <div class="modal-content">
            <h2>最佳 10 分數</h2>
            <ul id="score-list" class="score-list"></ul>
            <div style="text-align: center; margin-top: 20px;">
                <button class="menu-button" onclick="clearScores()">清除</button>
                <button class="menu-button" onclick="closeModal('score-modal')">確定</button>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" class="modal">
        <div class="modal-content">
            <h2>遊戲說明</h2>
            <p>規則：<br>點擊相同顏色的連通方塊群可消除，消除越多分數越高。<br>分數公式：S(n) = (n-1)*(n-2)+2</p>
            <div style="text-align: center; margin-top: 20px;">
                <button class="menu-button" onclick="closeModal('info-modal')">確定</button>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const LETTERS = ['A', 'B', 'C', 'D', 'E'];
        const COLORS = {
            'A': '#0000FF',  // Blue
            'B': '#FF0000',  // Red
            'C': '#FF00FF',  // Magenta/Pink
            'D': '#FFFF00',  // Yellow
            'E': '#00FFFF',  // Cyan
        };
        const CELL_SIZE = 32;

        // Game state
        let gameState = {
            size: 'normal',
            style: 'panel',
            soundEnabled: true,
            board: [],
            initBoard: [],
            prevBoard: null,
            prevScore: 0,
            markedGroup: null,
            markedColor: null,
            score: 0,
            timerStarted: false,
            startTime: 0,
            scores: [],
            rows: 10,
            cols: 20
        };

        // Sound effect
        const eliminationSound = new Audio('abcd.wav');
        // Preload audio for better performance
        eliminationSound.load();

        // Initialize game
        function initGame() {
            loadScores();
            setBoardSize();
            generateBoard();
            drawBoard();
            updateStatus();
        }

        // 監聽螢幕方向改變，自動重設盤面
        let lastOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
        window.addEventListener('resize', function() {
            const currentOrientation = window.innerWidth > window.innerHeight ? 'landscape' : 'portrait';
            if (currentOrientation !== lastOrientation) {
                lastOrientation = currentOrientation;
                // 重新開始遊戲以適應新方向
                newGame();
            }
        });

        // Set board size
        function setBoardSize() {
            let rows, cols;
            if (gameState.size === 'normal') {
                rows = 10;
                cols = 20;
            } else {
                rows = 15;
                cols = 25;
            }
            // 手機板自動對調長短邊
            if (window.innerWidth < 700 && window.innerWidth < window.innerHeight) {
                // 直向手機，rows/cols 對調
                [rows, cols] = [cols, rows];
            }
            gameState.rows = rows;
            gameState.cols = cols;
            const gameBoard = document.getElementById('game-board');
            gameBoard.style.gridTemplateColumns = `repeat(${gameState.cols}, ${CELL_SIZE}px)`;
            gameBoard.style.gridTemplateRows = `repeat(${gameState.rows}, ${CELL_SIZE}px)`;
        }

        // Generate new board
        function generateBoard() {
            gameState.initBoard = Array(gameState.rows).fill().map(() => 
                Array(gameState.cols).fill().map(() => Math.floor(Math.random() * 5))
            );
            gameState.board = gameState.initBoard.map(row => [...row]);
        }

        // Draw board
        function drawBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';

            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${gameState.style}`;
                    cell.id = `cell-${r}-${c}`; // Add unique ID for each cell
                    
                    if (gameState.board[r][c] !== null) {
                        const letter = LETTERS[gameState.board[r][c]];
                        const color = COLORS[letter];
                        
                        if (gameState.markedGroup && gameState.markedGroup.has(`${r},${c}`)) {
                            cell.style.backgroundColor = 'white';
                            cell.style.color = color;
                        } else {
                            cell.style.backgroundColor = color;
                            cell.style.color = 'black';
                        }
                        
                        // Only show letters in Panel style
                        if (gameState.style === 'panel') {
                            cell.textContent = letter;
                        }
                        
                        cell.onclick = () => handleClick(r, c);
                    } else {
                        // Add empty class for Marble style
                        if (gameState.style === 'marble') {
                            cell.classList.add('empty');
                        }
                        // Add click handler for empty cells
                        cell.onclick = () => handleClick(r, c);
                    }
                    
                    gameBoard.appendChild(cell);
                }
            }
        }

        // Handle cell click
        function handleClick(row, col) {
            // If clicking on empty cell, clear selection
            if (gameState.board[row][col] === null) {
                gameState.markedGroup = null;
                gameState.markedColor = null;
                drawBoard();
                updateStatus();
                return;
            }

            const group = findGroup(row, col);
            if (group.size > 1) {
                if (gameState.markedGroup && 
                    gameState.markedGroup.size === group.size && 
                    Array.from(gameState.markedGroup).every(pos => group.has(pos))) {
                    // Save previous state
                    gameState.prevBoard = gameState.board.map(row => [...row]);
                    gameState.prevScore = gameState.score;

                    // Start timer if not started
                    if (!gameState.timerStarted) {
                        gameState.timerStarted = true;
                        gameState.startTime = Date.now();
                        updateTimer();
                    }

                    // Eliminate group
                    eliminateGroup(group);
                } else {
                    // Mark group
                    gameState.markedGroup = group;
                    gameState.markedColor = gameState.board[row][col];
                    drawBoard();
                    updateStatus();
                }
            } else {
                gameState.markedGroup = null;
                gameState.markedColor = null;
                drawBoard();
                updateStatus();
            }
        }

        // Find connected group
        function findGroup(row, col) {
            const target = gameState.board[row][col];
            const visited = new Set();
            const stack = [[row, col]];

            while (stack.length > 0) {
                const [r, c] = stack.pop();
                const key = `${r},${c}`;
                
                if (visited.has(key) || gameState.board[r][c] !== target) continue;
                
                visited.add(key);
                
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dr, dc] of directions) {
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < gameState.rows && nc >= 0 && nc < gameState.cols && 
                        gameState.board[nr][nc] === target) {
                        stack.push([nr, nc]);
                    }
                }
            }
            
            return visited;
        }

        // Eliminate group
        function eliminateGroup(group) {
            // Convert group to array and sort for consistent elimination order
            const groupArray = Array.from(group).sort();
            
            // Update score immediately
            const n = group.size;
            if (n >= 2) {
                gameState.score += (n - 1) * (n - 2) + 2;
            }
            
            // Clear marked group immediately
            gameState.markedGroup = null;
            gameState.markedColor = null;
            
            // Update status immediately
            updateStatus();
            
            // Eliminate cells with delay for sequential effect
            groupArray.forEach((key, index) => {
                setTimeout(() => {
                    const [r, c] = key.split(',').map(Number);
                    
                    // Play sound for each elimination
                    if (gameState.soundEnabled) {
                        try {
                            // Clone the audio for overlapping sounds
                            const sound = eliminationSound.cloneNode();
                            sound.volume = 0.3; // Reduce volume to prevent overwhelming
                            sound.currentTime = 0; // Reset to beginning
                            sound.play().catch(e => console.log('Audio play failed:', e));
                        } catch (e) {
                            console.log('Audio creation failed:', e);
                        }
                    }
                    
                    // Add elimination class and remove from board
                    const cell = document.getElementById(`cell-${r}-${c}`);
                    if (cell) {
                        cell.classList.add('eliminating');
                    }
                    gameState.board[r][c] = null;
                    
                }, index * 100); // 100ms delay between each elimination
            });
            
            // Collapse board and check game over after all eliminations complete
            setTimeout(() => {
                collapseBoard();
                drawBoard();
                
                // Check game over
                if (!hasMoves()) {
                    setTimeout(() => {
                        alert('Game Over!');
                        tryUpdateScores();
                        showScore();
                    }, 100);
                }
            }, groupArray.length * 100 + 200); // Wait for all eliminations + extra time
        }

        // Collapse board
        function collapseBoard() {
            // Fall down
            for (let c = 0; c < gameState.cols; c++) {
                const stack = [];
                for (let r = 0; r < gameState.rows; r++) {
                    if (gameState.board[r][c] !== null) {
                        stack.push(gameState.board[r][c]);
                    }
                }
                for (let r = gameState.rows - 1; r >= 0; r--) {
                    gameState.board[r][c] = stack.pop() ?? null;
                }
            }

            // Shift left
            let writeCol = 0;
            for (let readCol = 0; readCol < gameState.cols; readCol++) {
                if (gameState.board.some(row => row[readCol] !== null)) {
                    if (writeCol !== readCol) {
                        for (let r = 0; r < gameState.rows; r++) {
                            gameState.board[r][writeCol] = gameState.board[r][readCol];
                            gameState.board[r][readCol] = null;
                        }
                    }
                    writeCol++;
                }
            }
        }

        // Check if there are any valid moves
        function hasMoves() {
            for (let r = 0; r < gameState.rows; r++) {
                for (let c = 0; c < gameState.cols; c++) {
                    if (gameState.board[r][c] !== null) {
                        const group = findGroup(r, c);
                        if (group.size > 1) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Update status display
        function updateStatus() {
            const markLabel = document.getElementById('mark-label');
            const scoreLabel = document.getElementById('score-label');

            if (gameState.markedGroup) {
                const n = gameState.markedGroup.size;
                const point = n >= 2 ? (n - 1) * (n - 2) + 2 : 0;
                markLabel.textContent = `標記：${n}（點數：${point}）`;
            } else {
                markLabel.textContent = '標記：0（點數：0）';
            }

            scoreLabel.textContent = `分數：${gameState.score}`;
        }

        // Update timer
        function updateTimer() {
            if (!gameState.timerStarted) {
                document.getElementById('time-label').textContent = '時間：0秒';
                return;
            }

            const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
            document.getElementById('time-label').textContent = `時間：${elapsed}秒`;
            setTimeout(updateTimer, 1000);
        }

        // Game control functions
        function newGame() {
            tryUpdateScores();
            setBoardSize();
            generateBoard();
            gameState.prevBoard = null;
            gameState.prevScore = 0;
            gameState.markedGroup = null;
            gameState.markedColor = null;
            gameState.score = 0;
            gameState.timerStarted = false;
            gameState.startTime = 0;
            document.getElementById('time-label').textContent = '時間：0秒';
            drawBoard();
            updateStatus();
        }

        function replay() {
            tryUpdateScores();
            gameState.board = gameState.initBoard.map(row => [...row]);
            gameState.prevBoard = null;
            gameState.prevScore = 0;
            gameState.markedGroup = null;
            gameState.markedColor = null;
            gameState.score = 0;
            gameState.timerStarted = false;
            gameState.startTime = 0;
            document.getElementById('time-label').textContent = '時間：0秒';
            drawBoard();
            updateStatus();
        }

        function undo() {
            if (gameState.prevBoard) {
                gameState.board = gameState.prevBoard.map(row => [...row]);
                gameState.score = gameState.prevScore;
                gameState.markedGroup = null;
                gameState.markedColor = null;
                drawBoard();
                updateStatus();
            } else {
                alert('No moves to undo!');
            }
        }

        // Score management
        function loadScores() {
            const scores = localStorage.getItem('samegame_scores');
            gameState.scores = scores ? JSON.parse(scores) : Array(10).fill(0);
        }

        function saveScores() {
            localStorage.setItem('samegame_scores', JSON.stringify(gameState.scores));
        }

        function tryUpdateScores() {
            if (gameState.score > 0) {
                gameState.scores.push(gameState.score);
                gameState.scores.sort((a, b) => b - a);
                gameState.scores = gameState.scores.slice(0, 10);
                saveScores();
            }
        }

        function showScore() {
            const scoreList = document.getElementById('score-list');
            scoreList.innerHTML = '';
            gameState.scores.forEach((score, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${score}`;
                scoreList.appendChild(li);
            });
            document.getElementById('score-modal').style.display = 'flex';
        }

        function clearScores() {
            gameState.scores = Array(10).fill(0);
            saveScores();
            showScore();
        }

        // UI control functions
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const button = document.querySelector('button[onclick="toggleSound()"]');
            button.textContent = `音效：${gameState.soundEnabled ? '開啟' : '關閉'}`;
        }

        function setSize(size) {
            gameState.size = size;
            newGame();
        }

        function setStyle(style) {
            gameState.style = style;
            drawBoard();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Initialize game when page loads
        window.onload = initGame;
    </script>
</body>
</html> 
