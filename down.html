5k<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>NS-Shaft 簡化版</title>
  <style>
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #002244;
    }
    #hud {
      width: 95vw;
      max-width: 420px;
      margin: 0 auto;
      color: #fff;
      font-family: 'Arial Black', Arial, sans-serif;
      font-size: 4vw;
      letter-spacing: 2px;
      user-select: none;
      text-shadow: 2px 2px 4px #000;
      height: 40px;
      line-height: 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-sizing: border-box;
      padding: 0 8px;
      white-space: nowrap;
    }
    #hud .hud-hp {
      display: flex;
      gap: 2px;
      flex-wrap: nowrap;
      min-width: 60px;
      max-width: 152px;
      height: 18px;
    }
    #hud .hud-score {
      font-weight: bold;
      flex: 1;
      text-align: center;
    }
    #controls {
      width: 95vw;
      max-width: 420px;
      display: flex;
      justify-content: space-between;
      margin: 0 auto;
      gap: 16px;
      user-select: none;
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0,0,0,0.7);
      padding: 8px 0 8px 0;
      border-radius: 16px 16px 0 0;
    }
    .ctrl-btn {
      flex: 1;
      height: 48px;
      font-size: 2rem;
      background: #222;
      color: #fff;
      border: 2px solid #888;
      border-radius: 12px;
      margin: 0 8px;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s;
      touch-action: manipulation;
    }
    .ctrl-btn:active {
      background: #444;
    }
    #game {
      width: 100vw;
      max-width: 480px;
      height: 90vh;
      max-height: 100vh;
      background: #002244;
      display: block;
      margin: 0 auto;
      touch-action: none;
      padding-bottom: 64px; /* 預留空間給底部按鈕 */
    }
    @media (max-width: 600px) {
      #hud {
        font-size: 16px;
        height: auto;
        line-height: normal;
        padding: 6px 0 6px 0;
      }
      .ctrl-btn {
        height: 40px;
        font-size: 1.5rem;
      }
      #game {
        height: 90vh;
        max-height: 100vh;
        padding-bottom: 64px;
      }
    }
  </style>
</head>
<body>
<div id="hud"></div>
<canvas id="game"></canvas>
<div id="controls">
  <button class="ctrl-btn" id="btn-left">◀️</button>
  <button class="ctrl-btn" id="pause-btn">⏯️</button>
  <button class="ctrl-btn" id="btn-right">▶️</button>
</div>
<div id="gameover-modal" style="display:none;position:fixed;z-index:1000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:32px 24px 24px 24px;border-radius:18px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:center;">
    <div id="gameover-msg" style="color:#fff;font-size:1.5rem;margin-bottom:18px;"></div>
    <button id="restart-btn" style="font-size:1.2rem;padding:10px 32px;background:#ff0;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;">重新開始</button>
  </div>
</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// 響應式調整canvas解析度
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.offsetWidth;
  const h = canvas.offsetHeight;
  canvas.width = w * ratio;
  canvas.height = h * ratio;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);
}

// 不要用 const WIDTH/HEIGHT，改成 function
function getWidth() {
  return canvas.width / (window.devicePixelRatio || 1);
}
function getHeight() {
  return canvas.height / (window.devicePixelRatio || 1);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let player, platforms, keys, lastPlatformTouched;
let gameSpeed = 1;
let lastPlayerFloorY = null;
let platformPassedCount = 0; // 記錄經過的平台數
let highScore = 0;
let paused = false;

// 讀取最高分數
if (localStorage.getItem('ns_shaft_highscore')) {
  highScore = parseInt(localStorage.getItem('ns_shaft_highscore')) || 0;
}

function initGame() {
  platforms = [];
  const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
  const platformHeight = 10;
  const numPlatforms = 8;
  const platformSpacing = getHeight() / numPlatforms; // 固定間距

  for (let i = 0; i < numPlatforms; i++) {
    let type;
    if (i === numPlatforms - 1) {
      type = "normal"; // 最底下的平台固定為普通平台
    } else {
      // 更平均的平台類型分配
      let rand = Math.random();
      if (rand < 0.2) type = "normal";      // 20% 普通平台
      else if (rand < 0.4) type = "jump";   // 20% 彈跳平台
      else if (rand < 0.6) type = "spike";  // 20% 尖刺平台
      else if (rand < 0.8) type = "vanish"; // 20% 消失平台
      else if (rand < 0.9) type = "conveyorL"; // 10% 左傳輸帶
      else type = "conveyorR";              // 10% 右傳輸帶
    }
    
    // 生成平台位置，確保不重疊
    let x, attempts = 0;
    do {
      x = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (attempts < 20 && platforms.some(p => 
      Math.abs(p.y - (i * platformSpacing)) < 20 && // 同一高度附近
      Math.abs(p.x - x) < platformWidth + 10 // 水平重疊檢查
    ));
    
    platforms.push({
      x: x,
      y: i * platformSpacing,
      width: platformWidth,
      height: platformHeight,
      type: type,
      vanishTimer: null,
      hidden: false
    });
  }

  // 讓精靈一開始站在最底下那個平台正上方
  const firstPlatform = platforms[platforms.length - 1];
  const playerWidth = Math.floor(platformWidth / 3); // 精靈寬度為平台寬度的1/3
  const playerHeight = playerWidth; // 精靈高度等於寬度，保持正方形
  player = {
    x: firstPlatform.x + (firstPlatform.width - playerWidth) / 2,
    y: firstPlatform.y - playerHeight,
    width: playerWidth,
    height: playerHeight,
    vx: 0,
    vy: 0,
    speed: 4.0,
    gravity: 0.3,
    jumpForce: -8,
    onGround: false,
    hp: 12,
    score: 0,
    fallThrough: false, // 新增穿透狀態
    hurtTimer: 0, // 受傷計時器
    isHurt: false // 受傷狀態
  };

  lastPlatformTouched = null;

  keys = {};

  document.addEventListener("keydown", e => keys[e.key] = true);
  document.addEventListener("keyup", e => keys[e.key] = false);

  gameSpeed = 1;
  lastPlayerFloorY = player.y;
  platformPassedCount = 0;

  drawHUD();
  requestAnimationFrame(gameLoop);
}

function drawPlayer() {
  // --- COLOR DEFINITIONS to match the image ---
  const hatColor = "#FFFFFF";
  const hatStripeColor = "#FF0000";
  const hatLightColor = "#FFFF00";
  const skinColor = "#F2D1B3"; // Skin tone from image
  const shirtColor = "#FFFF00";
  const collarColor = "#000000";
  const pantsColor = "#FFFFFF";
  const shoeColor = "#D2691E"; // Brown for shoes/sandals
  
  // --- HURT FLASH EFFECT ---
  let useHurtColors = false;
  if (player.isHurt && player.hurtTimer > 0) {
    if (Math.floor(player.hurtTimer / 50) % 2 === 0) {
      useHurtColors = true;
    }
  }

  const currentHatColor = useHurtColors ? "#CC0000" : hatColor;
  const currentStripeColor = useHurtColors ? "#FF6666" : hatStripeColor;
  const currentLightColor = useHurtColors ? "#FF6666" : hatLightColor;
  const currentSkinColor = useHurtColors ? "#FFCCCC" : skinColor;
  const currentShirtColor = useHurtColors ? "#FF0000" : shirtColor;
  const currentPantsColor = useHurtColors ? "#FFCCCC" : pantsColor;
  const currentShoeColor = useHurtColors ? "#FF6666" : shoeColor;

  // --- CONTEXT & TRANSLATION ---
  // We draw relative to the player's top-left corner (0,0)
  ctx.save();
  ctx.translate(player.x, player.y);

  const pW = player.width;
  const pH = player.height;

  // --- DRAWING (bottom to top) ---

  // Feet / Shoes
  const shoeHeight = pH * 0.1;
  const shoeWidth = pW * 0.35;
  const legXOffset = pW * 0.05; // Gap from edge for legs
  const legY = pH - shoeHeight;
  ctx.fillStyle = currentShoeColor;
  // Left shoe
  ctx.fillRect(legXOffset, legY, shoeWidth, shoeHeight);
  // Right shoe
  ctx.fillRect(pW - legXOffset - shoeWidth, legY, shoeWidth, shoeHeight);

  // Legs / Pants
  const legHeight = pH * 0.3;
  const legYPos = pH - shoeHeight - legHeight;
  ctx.fillStyle = currentPantsColor;
  // Left leg
  ctx.fillRect(legXOffset, legYPos, shoeWidth, legHeight);
  // Right leg
  ctx.fillRect(pW - legXOffset - shoeWidth, legYPos, shoeWidth, legHeight);
  // Fill middle part of pants to connect legs
  ctx.fillRect(legXOffset + shoeWidth, legYPos, pW - 2 * (legXOffset + shoeWidth), legHeight);

  // Body / Shirt
  const bodyHeight = pH * 0.4;
  const bodyWidth = pW;
  const bodyY = legYPos - bodyHeight;
  const bodyX = 0;
  ctx.fillStyle = currentShirtColor;
  ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
  
  // Arms
  const armHeight = pH * 0.3;
  const armWidth = pW * 0.2;
  const armY = bodyY + bodyHeight * 0.2;
  ctx.fillStyle = currentSkinColor;
  // Left arm
  ctx.fillRect(0 - armWidth*0.5, armY, armWidth, armHeight);
  // Right arm
  ctx.fillRect(pW - armWidth*0.5, armY, armWidth, armHeight);

  // Head
  const headHeight = pH * 0.35;
  const headWidth = pW * 0.7;
  const headY = bodyY - headHeight;
  const headX = (pW - headWidth) / 2;
  ctx.fillStyle = currentSkinColor;
  ctx.fillRect(headX, headY, headWidth, headHeight);

  // Collar (V-shape)
  ctx.fillStyle = collarColor;
  const collarVHeight = bodyHeight * 0.25;
  ctx.beginPath();
  ctx.moveTo(pW / 2, bodyY + collarVHeight);
  ctx.lineTo(pW / 2 - pW * 0.15, bodyY);
  ctx.lineTo(pW / 2 + pW * 0.15, bodyY);
  ctx.closePath();
  ctx.fill();

  // Hat
  const hatHeight = pH * 0.15;
  const hatY = headY - hatHeight;
  const hatWidth = pW * 0.9;
  const hatX = (pW - hatWidth) / 2;
  // Main hat shape (arc)
  ctx.fillStyle = currentHatColor;
  ctx.beginPath();
  ctx.arc(pW/2, hatY + hatHeight, hatWidth/2, Math.PI, 2 * Math.PI);
  ctx.fill();
  
  // Hat Stripes (Red parts)
  ctx.fillStyle = currentStripeColor;
  const stripeHeight = hatHeight;
  const stripeWidth = pW * 0.12;
  const stripeY = hatY;
  ctx.fillRect(hatX + pW * 0.1, stripeY, stripeWidth, stripeHeight);
  ctx.fillRect(pW - (hatX + pW * 0.1) - stripeWidth, stripeY, stripeWidth, stripeHeight);

  // Hat Light (Yellow part)
  ctx.fillStyle = currentLightColor;
  const lightSize = pW * 0.2;
  ctx.fillRect(pW/2 - lightSize/2, hatY, lightSize, lightSize);

  // Eyes (眯眯眼)
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = Math.max(1, pH * 0.05);
  const eyeWidth = headWidth * 0.3;
  const eyeY = headY + headHeight * 0.5;
  const eyeLX = headX + headWidth * 0.1;
  const eyeRX = headX + headWidth * 0.9;
  ctx.beginPath();
  ctx.moveTo(eyeLX, eyeY);
  ctx.lineTo(eyeLX + eyeWidth, eyeY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(eyeRX - eyeWidth, eyeY);
  ctx.lineTo(eyeRX, eyeY);
  ctx.stroke();

  ctx.restore();
}

function drawTopSpikes() {
  ctx.fillStyle = "#cccccc"; // 灰色
  for (let i = 0; i < getWidth(); i += 10) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i + 5, 12);
    ctx.lineTo(i + 10, 0);
    ctx.closePath();
    ctx.fill();
  }
}

function drawPlatforms() {
  for (let idx = 0; idx < platforms.length; idx++) {
    let p = platforms[idx];
    if (p.hidden) continue;
    if (p.type === "normal") {
      // 藍色平台，陰影深藍
      ctx.fillStyle = "#3399ff";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.fillStyle = "#003366";
      ctx.fillRect(p.x, p.y + p.height - 3, p.width, 3); // 藍色陰影
      ctx.strokeStyle = "#001a44";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
    } else if (p.type === "jump") {
      // 綠色底
      ctx.fillStyle = "#00e000";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#007700";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // 畫白色彈簧線圈
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      let springY = p.y + p.height / 2 + 1;
      for (let i = 0; i < p.width - 8; i += 8) {
        ctx.moveTo(p.x + 4 + i, springY - 2);
        ctx.lineTo(p.x + 8 + i, springY + 2);
        ctx.lineTo(p.x + 12 + i, springY - 2);
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (p.type === "spike") {
      // 尖刺平台：先繪製平台本身，再繪製尖刺
      ctx.fillStyle = "#cccccc"; // 灰色平台
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#999999";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // 在平台上方繪製尖刺
      ctx.fillStyle = "#cccccc"; // 與頂部尖刺相同的顏色
      for (let i = 0; i < p.width; i += 10) {
        ctx.beginPath();
        ctx.moveTo(p.x + i, p.y + p.height);
        ctx.lineTo(p.x + i + 5, p.y + p.height - 20); // 增加尖刺高度到20像素
        ctx.lineTo(p.x + i + 10, p.y + p.height);
        ctx.closePath();
        ctx.fill();
      }
    } else if (p.type === "vanish") {
      // 消失平台：淺灰色
      ctx.fillStyle = "#eeeeee";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#bbbbbb";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
    } else if (p.type === "conveyorL" || p.type === "conveyorR") {
      // 傳輸帶平台：灰色底+深色橫條+白色箭頭
      ctx.fillStyle = "#bbbbbb";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#888888";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // 畫深色橫條
      ctx.strokeStyle = "#666";
      for (let i = 4; i < p.width; i += 12) {
        ctx.beginPath();
        ctx.moveTo(p.x + i, p.y + 2);
        ctx.lineTo(p.x + i, p.y + p.height - 2);
        ctx.stroke();
      }
      // 畫三個白色箭頭
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      let arrowY = p.y + p.height / 2;
      
      // 計算三個箭頭的位置，均勻分布在平台上
      const arrowSpacing = p.width / 4; // 將平台寬度分成4份，箭頭在第1、2、3份的中心
      
      if (p.type === "conveyorL") {
        // 左傳送帶：箭頭指向左邊
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX + 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX + 6, arrowY + 4);
        }
      } else {
        // 右傳送帶：箭頭指向右邊
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX - 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX - 6, arrowY + 4);
        }
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  }
}

function drawHUD() {
  if (!player) return;
  const hud = document.getElementById('hud');
  const maxHp = 12;
  let hpHtml = '';
  for (let i = 0; i < maxHp; i++) {
    if (i < player.hp) {
      hpHtml += '<span style="display:inline-block;width:5px;height:16px;background:yellow;border:1px solid #cc0;margin-right:1px;"></span>';
    } else {
      hpHtml += '<span style="display:inline-block;width:5px;height:16px;background:#333;border:1px solid #222;margin-right:1px;"></span>';
    }
  }
  hud.innerHTML =
    `<span class="hud-hp">${hpHtml}</span>
     <span class="hud-score" style="color:#00ff00;font-size:28px;text-shadow:2px 2px 6px #000,0 0 8px #0f0;letter-spacing:3px;">地下${String(player.score).padStart(4, "0")}階</span>
     <span style="color:#fff;font-size:16px;text-shadow:1px 1px 2px #000;">最高: ${highScore}</span>`;
}

function updatePlayer() {
  player.vy += player.gravity;
  player.y += player.vy;

  // 頂端尖刺碰撞 - 精靈帽子頂端碰到尖刺就受傷
  const hatTopY = player.y; // 帽子頂端位置（精靈的y座標就是帽子頂端）
  if (hatTopY <= 12) { // 尖刺高度是12像素
    if (lastPlatformTouched !== 'topSpike') {
      player.hp -= 5;
      lastPlatformTouched = 'topSpike';
      player.isHurt = true;
      player.hurtTimer = 1000;
      // 將正下方平台設為 hidden
      platforms.forEach(p => {
        const overlap =
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height <= p.y + p.height &&
          player.y + player.height >= p.y;
        if (overlap && (p.type === 'normal' || p.type === 'spike' || p.type === 'conveyorL' || p.type === 'conveyorR')) {
          p.hidden = true;
        }
      });
    }
    player.y = 12; // 將精靈帽子頂端停在尖刺下方
    player.vy = 0;
    player.fallThrough = true; // 開啟穿透狀態
  } else if (lastPlatformTouched === 'topSpike') {
    lastPlatformTouched = null;
    player.fallThrough = false; // 離開頂端，恢復正常
  }

  if (keys["ArrowLeft"]) player.vx = -player.speed;
  else if (keys["ArrowRight"]) player.vx = player.speed;
  else player.vx = 0;

  player.x += player.vx;
  if (player.x < 0) player.x = 0;
  if (player.x + player.width > getWidth()) player.x = getWidth() - player.width;

  player.onGround = false;
  // 若在穿透狀態，跳過平台碰撞
  if (!player.fallThrough) {
    for (let p of platforms) {
      if (p.hidden) continue;
      if (player.vy >= 0 &&
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height > p.y &&
          player.y + player.height < p.y + p.height + player.vy) {
        player.y = p.y - player.height;
        player.onGround = true;
        if (p.type === "spike") {
          if (lastPlatformTouched !== p) {
            player.hp -= 5;
            lastPlatformTouched = p;
            player.isHurt = true;
            player.hurtTimer = 1000;
          }
          player.vy = 0;
        } else if (p.type === "jump") {
          player.vy = player.jumpForce;
          player.hp = Math.min(player.hp + 1, 12); // 每次跳都補一滴
          lastPlatformTouched = p;
        } else if (p.type === "normal") {
          player.vy = 0;
          if (lastPlatformTouched !== p) {
            player.hp = Math.min(player.hp + 1, 12);
            lastPlatformTouched = p;
          }
        } else if (p.type === "vanish") {
          player.vy = 0;
          if (p.vanishTimer === null) {
            p.vanishTimer = Date.now();
            player.hp = Math.min(player.hp + 1, 12);
          } else if (Date.now() - p.vanishTimer >= 200) {
            p.hidden = true;
            break;
          }
          lastPlatformTouched = p;
        } else if (p.type === "conveyorL" || p.type === "conveyorR") {
          player.vy = 0;
          if (p.type === "conveyorL") {
            player.x -= 1.5;
          } else {
            player.x += 1.5;
          }
          if (lastPlatformTouched !== p) {
            player.hp = Math.min(player.hp + 1, 12);
            lastPlatformTouched = p;
          }
        }
      } else if (p.type === "vanish") {
        // 離開平台時重設 vanishTimer
        p.vanishTimer = null;
      }
    }
  }

  if (player.y > getHeight() || (player.hp <= 0 && !player.fallThrough)) {
    setTimeout(() => {
      // 更新最高分數
      if (player.score > highScore) {
        highScore = player.score;
        localStorage.setItem('ns_shaft_highscore', highScore);
      }
      showGameOverModal(player.score, player.score >= highScore);
    }, 100);
    return false;
  }
  return true;
}

function updatePlatforms() {
  // 平台速度隨分數增加而變快
  const baseSpeed = 1.5;
  const speedIncrement = 0.05; // 每層增加的速度
  const platformSpeed = baseSpeed + (player.score * speedIncrement);
  
  for (let p of platforms) {
    p.y -= platformSpeed;
  }
  
  // 處理消失與重生
  for (let i = 0; i < platforms.length; i++) {
    let p = platforms[i];
    if (p.y + p.height < 0) {
      // 只要平台（不論 hidden 與否）離開畫面頂端就計數
      platformPassedCount++;
      if (platformPassedCount % 5 === 0) {
        player.score++;
      }
      // 平台重生
      const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
      const platformHeight = 10;
      const platformSpacing = getHeight() / 8; // 固定間距
      
      // 找到最下方的平台，在其下方固定間距處生成新平台
      let lowestPlatform = null;
      for (let otherP of platforms) {
        if (otherP !== p && (lowestPlatform === null || otherP.y > lowestPlatform.y)) {
          lowestPlatform = otherP;
        }
      }
      
      let newY, newX;
      if (lowestPlatform) {
        // 在最下方平台下方固定間距處生成
        newY = lowestPlatform.y + platformSpacing;
      } else {
        // 如果沒有其他平台，在畫面底部生成
        newY = getHeight();
      }
      
      // 生成X位置，避免與玩家重疊
      let tryCount = 0;
      do {
        newX = Math.random() * (getWidth() - platformWidth);
        tryCount++;
      } while (
        tryCount < 20 &&
        player.x + player.width > newX &&
        player.x < newX + platformWidth &&
        player.y + player.height <= newY + platformHeight &&
        player.y + player.height >= newY
      );
      
      p.y = newY;
      p.x = newX;
      
      // 平均的平台類型分配
      let rand = Math.random();
      if (rand < 0.2) p.type = "normal";      // 20% 普通平台
      else if (rand < 0.4) p.type = "jump";   // 20% 彈跳平台
      else if (rand < 0.6) p.type = "spike";  // 20% 尖刺平台
      else if (rand < 0.8) p.type = "vanish"; // 20% 消失平台
      else if (rand < 0.9) p.type = "conveyorL"; // 10% 左傳輸帶
      else p.type = "conveyorR";              // 10% 右傳輸帶
      
      p.vanishTimer = null;
      p.hidden = false; // 重生時恢復顯示
    }
  }
  
  // 檢查平台數量，如果少於8個就補充
  const targetPlatformCount = 8;
  while (platforms.length < targetPlatformCount) {
    const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
    const platformHeight = 10;
    const platformSpacing = getHeight() / 8; // 固定間距
    
    // 找到最下方的平台，在其下方固定間距處生成新平台
    let lowestPlatform = null;
    for (let p of platforms) {
      if (lowestPlatform === null || p.y > lowestPlatform.y) {
        lowestPlatform = p;
      }
    }
    
    let newY, newX;
    if (lowestPlatform) {
      // 在最下方平台下方固定間距處生成
      newY = lowestPlatform.y + platformSpacing;
    } else {
      // 如果沒有其他平台，在畫面底部生成
      newY = getHeight();
    }
    
    // 生成X位置，避免與玩家重疊
    let attempts = 0;
    do {
      newX = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (
      attempts < 20 &&
      player.x + player.width > newX &&
      player.x < newX + platformWidth &&
      player.y + player.height <= newY + platformHeight &&
      player.y + player.height >= newY
    );
    
    // 生成新平台
    let newPlatform = {
      x: newX,
      y: newY,
      width: platformWidth,
      height: platformHeight,
      type: "normal", // 預設為普通平台
      vanishTimer: null,
      hidden: false
    };
    
    // 平均分配平台類型
    let rand = Math.random();
    if (rand < 0.2) newPlatform.type = "normal";      // 20% 普通平台
    else if (rand < 0.4) newPlatform.type = "jump";   // 20% 彈跳平台
    else if (rand < 0.6) newPlatform.type = "spike";  // 20% 尖刺平台
    else if (rand < 0.8) newPlatform.type = "vanish"; // 20% 消失平台
    else if (rand < 0.9) newPlatform.type = "conveyorL"; // 10% 左傳輸帶
    else newPlatform.type = "conveyorR";              // 10% 右傳輸帶
    
    platforms.push(newPlatform);
  }
}

function togglePause() {
  paused = !paused;
  if (!paused) requestAnimationFrame(gameLoop);
  // 可加暫停提示
  document.getElementById('pause-btn').innerText = paused ? '⏸️' : '⏯️';
}

function gameLoop() {
  if (paused) return;
  ctx.clearRect(0, 0, getWidth(), getHeight());
  // 畫深藍色漸層背景（更接近原作）
  let grad = ctx.createLinearGradient(0, 0, 0, getHeight());
  grad.addColorStop(0, "#001a33");
  grad.addColorStop(1, "#003366");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, getWidth(), getHeight());
  drawTopSpikes(); // 畫頂端尖刺
  if (!updatePlayer()) return;
  updatePlatforms();
  drawPlatforms();
  drawPlayer();
  drawHUD();
  // 加上遊戲區域邊框
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.strokeRect(0, 0, getWidth(), getHeight());
  ctx.lineWidth = 1;
  if (player.isHurt && player.hurtTimer > 0) {
    player.hurtTimer -= 16; // 約等於一幀16ms
    if (player.hurtTimer <= 0) {
      player.isHurt = false;
      player.hurtTimer = 0;
    }
  }
  requestAnimationFrame(gameLoop);
}

// 觸控與按鈕操作
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const pauseBtn = document.getElementById('pause-btn');

function setKey(key, val) {
  keys[key] = val;
}

// 移除 canvas 上的滑動偵測（原本的 canvas.addEventListener('touchstart'...) 及 touchend 事件）
// 改為全畫面觸控偵測
function handleTouch(e) {
  let left = false, right = false;
  const half = window.innerWidth / 2;
  for (let i = 0; i < e.touches.length; i++) {
    const x = e.touches[i].clientX;
    if (x < half) left = true;
    if (x >= half) right = true;
  }
  setKey('ArrowLeft', left);
  setKey('ArrowRight', right);
}

canvas.addEventListener('touchstart', handleTouch);
canvas.addEventListener('touchmove', handleTouch);
canvas.addEventListener('touchend', handleTouch);
canvas.addEventListener('touchcancel', handleTouch);

btnLeft.addEventListener('touchstart', e => { e.preventDefault(); setKey('ArrowLeft', true); });
btnLeft.addEventListener('touchend', e => { e.preventDefault(); setKey('ArrowLeft', false); });
btnLeft.addEventListener('mousedown', e => { setKey('ArrowLeft', true); });
btnLeft.addEventListener('mouseup', e => { setKey('ArrowLeft', false); });
btnLeft.addEventListener('mouseleave', e => { setKey('ArrowLeft', false); });

btnRight.addEventListener('touchstart', e => { e.preventDefault(); setKey('ArrowRight', true); });
btnRight.addEventListener('touchend', e => { e.preventDefault(); setKey('ArrowRight', false); });
btnRight.addEventListener('mousedown', e => { setKey('ArrowRight', true); });
btnRight.addEventListener('mouseup', e => { setKey('ArrowRight', false); });
btnRight.addEventListener('mouseleave', e => { setKey('ArrowRight', false); });

pauseBtn.addEventListener('click', togglePause);

// 遊戲結束自訂彈窗
function showGameOverModal(score, isNewRecord) {
  const modal = document.getElementById('gameover-modal');
  const msg = document.getElementById('gameover-msg');
  msg.innerHTML = `遊戲結束！<br>樓層: <b style="color:yellow;">${score}</b>${isNewRecord ? '<br><span style="color:#0f0;">新紀錄！</span>' : ''}`;
  modal.style.display = 'flex';
}

document.getElementById('restart-btn').addEventListener('click', () => {
  document.getElementById('gameover-modal').style.display = 'none';
  initGame();
});

// 按下Enter也能重新開始
window.addEventListener('keydown', function(e) {
  const modal = document.getElementById('gameover-modal');
  if (modal.style.display === 'flex' && (e.key === 'Enter' || e.keyCode === 13)) {
    modal.style.display = 'none';
    initGame();
  }
  if (e.key === 'p' || e.key === 'P') {
    togglePause();
  }
});

initGame();
</script>
</body>
</html>
