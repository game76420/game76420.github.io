<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>NS-Shaft ç°¡åŒ–ç‰ˆ</title>
  <style>
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #002244;
    }
    #hud {
      width: 95vw;
      max-width: 420px;
      margin: 0 auto;
      color: #fff;
      font-family: 'Arial Black', Arial, sans-serif;
      font-size: min(3vw, 14px);
      letter-spacing: 1px;
      user-select: none;
      text-shadow: 1px 1px 2px #000;
      height: auto;
      line-height: 1.1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-sizing: border-box;
      padding: 0 4px;
      white-space: nowrap;
      overflow: visible;
      position: static;
      margin-top: 6px;
      margin-bottom: 2px;
      z-index: auto;
    }
    #hud .hud-hp {
      display: flex;
      gap: 2px;
      flex-wrap: nowrap;
      min-width: 0;
      max-width: none;
      height: 14px;
    }
    #hud .hud-score {
      font-weight: bold;
      flex: 1;
      text-align: center;
      font-size: min(9vw, 40px) !important;
      letter-spacing: 2px;
      text-shadow: 2px 2px 6px #000,0 0 8px #0f0;
    }
    #hud-center span {
      line-height: 1.1 !important;
    }
    #hud-audio-panel button {
      font-size: 0.95rem !important;
      padding: 2px 6px !important;
      border-radius: 8px !important;
      margin-bottom: 2px;
    }
    #hud-audio-panel {
      gap: 2px !important;
    }
    #controls {
      width: 95vw;
      max-width: 420px;
      display: flex;
      justify-content: space-between;
      margin: 0 auto;
      gap: 16px;
      user-select: none;
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(0,0,0,0.7);
      padding: 8px 0 8px 0;
      border-radius: 16px 16px 0 0;
    }
    .ctrl-btn {
      flex: 1;
      height: 48px;
      font-size: 2rem;
      background: #222;
      color: #fff;
      border: 2px solid #888;
      border-radius: 12px;
      margin: 0 8px;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s;
      touch-action: manipulation;
    }
    .ctrl-btn:active {
      background: #444;
    }
    #game {
      width: 100vw;
      max-width: 480px;
      height: 90vh;
      max-height: 100vh;
      background: #002244;
      display: block;
      margin: 0 auto;
      touch-action: none;
      padding-bottom: 64px; /* é ç•™ç©ºé–“çµ¦åº•éƒ¨æŒ‰éˆ• */
    }
    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        height: auto;
        line-height: 1.1;
        padding: 2px 0 2px 0;
        margin-top: 2px;
        margin-bottom: 2px;
      }
      .ctrl-btn {
        height: 40px;
        font-size: 1.5rem;
      }
      #game {
        height: 90vh;
        max-height: 100vh;
        padding-bottom: 64px;
      }
      #hud .hud-score {
        font-size: 28px !important;
      }
      #hud-center span {
        font-size: 11px !important;
      }
      #hud .hud-hp {
        height: 10px !important;
      }
      #hud-audio-panel button {
        font-size: 0.8rem !important;
        padding: 1px 4px !important;
      }
    }
  </style>
</head>
<body>
<!-- éŸ³æ•ˆèˆ‡èƒŒæ™¯éŸ³æ¨‚ -->
<audio id="sfx-normal" src="Data_1.wav" preload="auto"></audio>
<audio id="sfx-jump" src="Data_3.wav" preload="auto"></audio>
<audio id="sfx-spike" src="Data_4.wav" preload="auto"></audio>
<audio id="sfx-vanish" src="Data_5.wav" preload="auto"></audio>
<audio id="sfx-dead" src="Data_6.wav" preload="auto"></audio>
<audio id="bgm" src="BGM.mp3" preload="auto" loop></audio>
<div id="hud">
  <span class="hud-hp" style="z-index:1;position:relative;justify-content:flex-start;flex:1;">
    <span id="hud-hp-bar" style="background:#ff0000;height:100%;display:block;"></span>
  </span>
  <div id="hud-center" style="display:flex;flex-direction:column;align-items:center;justify-content:center;flex:1 1 0%;min-width:0;max-width:100%;">
    <span id="hud-highscore" style="color:#fff;font-size:clamp(13px,2.8vw,20px);text-shadow:1px 1px 2px #000;white-space:normal;overflow:visible;text-overflow:clip;max-width:100%;display:block;text-align:center;line-height:1.2;word-break:break-all;"></span>
    <span class="hud-score" id="hud-score" style="color:#00ff00;font-size:clamp(18px,4vw,32px);text-shadow:2px 2px 6px #000,0 0 8px #0f0;letter-spacing:2px;white-space:normal;overflow:visible;text-overflow:clip;max-width:100%;margin:0 auto;text-align:center;line-height:1.2;word-break:break-all;"></span>
  </div>
  <span id="hud-audio-panel" style="display:flex;flex-direction:column;align-items:center;gap:6px;min-width:0;max-width:none;position:static;background:none;box-shadow:none;padding:0;border-radius:0;z-index:auto;">
    <button id="sfx-toggle" type="button" tabindex="-1" style="background:#222;color:#fff;border:2px solid #888;border-radius:12px;padding:4px 8px;font-size:1.1rem;box-shadow:0 2px 8px #0008;cursor:pointer;"></button>
    <button id="bgm-toggle" type="button" tabindex="-1" style="background:#222;color:#fff;border:2px solid #888;border-radius:12px;padding:4px 8px;font-size:1.1rem;box-shadow:0 2px 8px #0008;cursor:pointer;"></button>
  </span>
</div>
<canvas id="game"></canvas>
<div id="controls">
  <button class="ctrl-btn" id="btn-left">â—€ï¸</button>
  <button class="ctrl-btn" id="pause-btn">â¯ï¸</button>
  <button class="ctrl-btn" id="btn-right">â–¶ï¸</button>
</div>
<div id="gameover-modal" style="display:none;position:fixed;z-index:1000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:32px 24px 24px 24px;border-radius:18px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:center;user-select:none;">
    <div id="gameover-msg" style="color:#fff;font-size:1.5rem;margin-bottom:18px;user-select:none;"></div>
    <button id="restart-btn" style="font-size:1.2rem;padding:10px 32px;background:#ff0;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;user-select:none;">é‡æ–°é–‹å§‹</button>
  </div>
</div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// éŸ¿æ‡‰å¼èª¿æ•´canvasè§£æåº¦
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.offsetWidth;
  const h = canvas.offsetHeight;
  canvas.width = w * ratio;
  canvas.height = h * ratio;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);
}

// ä¸è¦ç”¨ const WIDTH/HEIGHTï¼Œæ”¹æˆ function
function getWidth() {
  return canvas.width / (window.devicePixelRatio || 1);
}
function getHeight() {
  return canvas.height / (window.devicePixelRatio || 1);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let player, platforms, keys, lastPlatformTouched;
let gameSpeed = 1;
let lastPlayerFloorY = null;
let platformPassedCount = 0; // è¨˜éŒ„ç¶“éçš„å¹³å°æ•¸
let highScore = 0;
let paused = false;
let firstInteraction = false;
let animationFrameId = null;

// è®€å–æœ€é«˜åˆ†æ•¸
if (localStorage.getItem('ns_shaft_highscore')) {
  highScore = parseInt(localStorage.getItem('ns_shaft_highscore')) || 0;
}

// å¹³å°é¡å‹èˆ‡ä¸Šé™
const PLATFORM_TYPES = ["normal", "jump", "spike", "vanish", "conveyorL", "conveyorR"];
const PLATFORM_TYPE_LIMIT = {
  normal: 99,      // æ™®é€šå¹³å°ä¸é™åˆ¶
  jump: 3,
  spike: 3,
  vanish: 3,
  conveyorL: 2,
  conveyorR: 2
};

function countPlatformTypes() {
  const count = {normal:0, jump:0, spike:0, vanish:0, conveyorL:0, conveyorR:0};
  for (let p of platforms) {
    if (!p.hidden && count.hasOwnProperty(p.type)) count[p.type]++;
  }
  return count;
}

function getAvailablePlatformTypes() {
  const counts = countPlatformTypes();
  return PLATFORM_TYPES.filter(type => counts[type] < PLATFORM_TYPE_LIMIT[type]);
}

// éŸ³æ•ˆæ± 
function createAudioPool(src, poolSize = 4) {
  const pool = [];
  for (let i = 0; i < poolSize; i++) {
    const audio = new Audio(src);
    audio.preload = "auto";
    pool.push(audio);
  }
  return pool;
}

const sfxPools = {
  normal: createAudioPool("Data_1.wav"),
  jump: createAudioPool("Data_3.wav"),
  spike: createAudioPool("Data_4.wav"),
  vanish: createAudioPool("Data_5.wav"),
  dead: createAudioPool("Data_6.wav"),
};

function playSfxPool(poolName) {
  if (sfxMuted) return;
  const pool = sfxPools[poolName];
  if (!pool) return;
  for (let audio of pool) {
    if (audio.paused || audio.ended) {
      audio.muted = sfxMuted;
      audio.currentTime = 0;
      audio.play();
      break;
    }
  }
}

// æ–°å¢éŸ³æ•ˆèˆ‡éŸ³æ¨‚éœéŸ³ç‹€æ…‹
let sfxMuted = false;
let bgmMuted = true;

// éŸ³æ•ˆæ’­æ”¾è¼”åŠ©ï¼ˆå¯é‡ç–Šæ’­æ”¾ï¼‰
function playSfx(audio) {
  if (!audio) return;
  audio.muted = sfxMuted; // ç¢ºä¿æ¯æ¬¡æ’­æ”¾æ™‚éƒ½åŒæ­¥éœéŸ³ç‹€æ…‹
  if (sfxMuted) return;
  try {
    audio.currentTime = 0;
    audio.play();
  } catch (e) {}
}

// èƒŒæ™¯éŸ³æ¨‚è‡ªå‹•æ’­æ”¾ï¼ˆéœ€ç”¨æˆ¶äº’å‹•å¾Œè§¸ç™¼ï¼‰
function tryPlayBgm() {
  if (bgm.paused && !bgmMuted) {
    bgm.volume = 0.5;
    bgm.play().catch(()=>{});
  }
}

function initGame() {
  // å…ˆç¢ºä¿ gameover-modal éš±è—ï¼Œé¿å…canvaså°ºå¯¸ç‚º0
  var modal = document.getElementById('gameover-modal');
  if (modal) modal.style.display = 'none';
  // å–æ¶ˆèˆŠçš„å‹•ç•«å¾ªç’°
  if (animationFrameId !== null) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  resizeCanvas();
  paused = false;
  platforms = [];
  const platformWidth = Math.floor(getWidth() * 0.25); // å¹³å°å¯¬åº¦ç‚ºç¸½å¯¬åº¦çš„25%
  const platformHeight = 10;
  const numPlatforms = 8;
  const platformSpacing = getHeight() / numPlatforms; // å›ºå®šé–“è·

  for (let i = 0; i < numPlatforms; i++) {
    let type;
    if (i === numPlatforms - 1) {
      type = "normal"; // æœ€åº•ä¸‹çš„å¹³å°å›ºå®šç‚ºæ™®é€šå¹³å°
    } else {
      // æ›´å¹³å‡çš„å¹³å°é¡å‹åˆ†é…
      let rand = Math.random();
      if (rand < 0.2) type = "normal";      // 20% æ™®é€šå¹³å°
      else if (rand < 0.4) type = "jump";   // 20% å½ˆè·³å¹³å°
      else if (rand < 0.6) type = "spike";  // 20% å°–åˆºå¹³å°
      else if (rand < 0.8) type = "vanish"; // 20% æ¶ˆå¤±å¹³å°
      else if (rand < 0.9) type = "conveyorL"; // 10% å·¦å‚³è¼¸å¸¶
      else type = "conveyorR";              // 10% å³å‚³è¼¸å¸¶
    }
    
    // ç”Ÿæˆå¹³å°ä½ç½®ï¼Œç¢ºä¿ä¸é‡ç–Š
    let x, attempts = 0;
    do {
      x = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (attempts < 20 && platforms.some(p => 
      Math.abs(p.y - (i * platformSpacing)) < 20 && // åŒä¸€é«˜åº¦é™„è¿‘
      Math.abs(p.x - x) < platformWidth + 10 // æ°´å¹³é‡ç–Šæª¢æŸ¥
    ));
    
    platforms.push({
      x: x,
      y: i * platformSpacing,
      width: platformWidth,
      height: platformHeight,
      type: type,
      vanishTimer: null,
      hidden: false
    });
  }

  // è®“ç²¾éˆä¸€é–‹å§‹ç«™åœ¨æœ€åº•ä¸‹é‚£å€‹å¹³å°æ­£ä¸Šæ–¹
  const firstPlatform = platforms[platforms.length - 1];
  const playerWidth = Math.floor(platformWidth / 3); // ç²¾éˆå¯¬åº¦ç‚ºå¹³å°å¯¬åº¦çš„1/3
  const playerHeight = playerWidth; // ç²¾éˆé«˜åº¦ç­‰æ–¼å¯¬åº¦ï¼Œä¿æŒæ­£æ–¹å½¢
  player = {
    x: firstPlatform.x + (firstPlatform.width - playerWidth) / 2,
    y: firstPlatform.y - playerHeight,
    width: playerWidth,
    height: playerHeight,
    vx: 0,
    vy: 0,
    speed: 4.0,
    gravity: 0.3,
    jumpForce: -8,
    onGround: false,
    hp: 12,
    score: 0,
    fallThrough: false, // æ–°å¢ç©¿é€ç‹€æ…‹
    hurtTimer: 0, // å—å‚·è¨ˆæ™‚å™¨
    isHurt: false, // å—å‚·ç‹€æ…‹
    direction: "front", // "left", "right", "front"
    runAnim: 0, // è·‘æ­¥å‹•ç•«ç”¨
  };

  lastPlatformTouched = null;

  keys = {};

  gameSpeed = 1;
  lastPlayerFloorY = player.y;
  platformPassedCount = 0;

  drawHUD();
  animationFrameId = requestAnimationFrame(gameLoop);
  // åªåœ¨ bgmMuted ç‚º false æ™‚æ‰æ’­æ”¾éŸ³æ¨‚
  sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
  sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
  sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
  sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
  sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
  bgm.muted = bgmMuted;
  if (!bgmMuted) {
    tryPlayBgm();
  } else {
    bgm.pause();
  }
}

function drawPlayer() {
  ctx.save();
  ctx.translate(player.x, player.y);

  const pW = player.width;
  const pH = player.height;

  // é¡è‰²å®šç¾©
  const hatColor = "#FFFFFF";
  const hatStripeColor = "#FF0000";
  const hatLightColor = "#FFFF00";
  const skinColor = "#F2D1B3";
  const shirtColor = "#FFFF00";
  const collarColor = "#000000";
  const pantsColor = "#FFFFFF";
  const shoeColor = "#D2691E";

  // å—å‚·é–ƒçˆ
  let useHurtColors = false;
  if (player.isHurt && player.hurtTimer > 0) {
    if (Math.floor(player.hurtTimer / 50) % 2 === 0) {
      useHurtColors = true;
    }
  }
  const currentHatColor = useHurtColors ? "#CC0000" : hatColor;
  const currentStripeColor = useHurtColors ? "#FF6666" : hatStripeColor;
  const currentLightColor = useHurtColors ? "#FF6666" : hatLightColor;
  const currentSkinColor = useHurtColors ? "#FFCCCC" : skinColor;
  const currentShirtColor = useHurtColors ? "#FF0000" : shirtColor;
  const currentPantsColor = useHurtColors ? "#FFCCCC" : pantsColor;
  const currentShoeColor = useHurtColors ? "#FF6666" : shoeColor;

  // ä¸»è¦æ¯”ä¾‹
  const bodyHeight = pH * 0.4;
  const bodyWidth = pW;
  const legHeight = pH * 0.3;
  const legWidth = pW * 0.35;
  const armHeight = pH * 0.3;
  const armWidth = pW * 0.2;
  const headHeight = pH * 0.35;
  const headWidth = pW * 0.7;
  const shoeHeight = pH * 0.1;
  const shoeWidth = legWidth;

  // ä½ç½®
  const legY = pH - shoeHeight;
  const legYPos = pH - shoeHeight - legHeight;
  const bodyY = legYPos - bodyHeight;
  const headY = bodyY - headHeight;
  const headX = (pW - headWidth) / 2;

  // è·‘æ­¥å‹•ä½œåƒæ•¸
  let leftArm, rightArm, leftLeg, rightLeg, headOffsetX, headOffsetY, bodySkew;
  if (player.direction === "left" || player.direction === "right") {
    // é¡åƒ
    if (player.direction === "right") {
      ctx.translate(pW, 0);
      ctx.scale(-1, 1);
    }
    // è·‘æ­¥å‹•ä½œ
    const anim = player.runAnim || 0;
    // é ­éƒ¨å’Œèº«é«”å‰å‚¾ã€ä¸Šä¸‹æ™ƒå‹•ï¼ˆå¹…åº¦åŠ å¤§ï¼‰
    headOffsetX = -pW * 0.18; // å‰å‚¾æ›´å¤š
    headOffsetY = pH * 0.10 + Math.sin(anim) * pH * 0.10; // ä¸Šä¸‹å¹…åº¦æ›´å¤§
    bodySkew = -0.28 + Math.sin(anim) * 0.12; // å‰å‚¾æ›´å¤š
    // æ‰‹è…³æ“ºå‹•ï¼ˆå¹…åº¦æ›´å¤§ï¼‰
    const armSwing = Math.sin(anim) * 1.2; // æ“ºå‹•å¹…åº¦åŠ å¤§
    const legSwing = Math.sin(anim + Math.PI) * 1.0; // è…¿éƒ¨å¹…åº¦åŠ å¤§
    leftArm = {x: -armWidth*0.5 + pW*0.08, y: bodyY + bodyHeight*0.18, angle: -1.0 + armSwing};
    rightArm = {x: pW - armWidth*0.5 - pW*0.08, y: bodyY + bodyHeight*0.28, angle: 1.0 - armSwing};
    leftLeg = {x: pW*0.08, y: legYPos, w: legWidth, h: legHeight, angle: 0.8 * Math.sin(anim)};
    rightLeg = {x: pW - legWidth - pW*0.08, y: legYPos, w: legWidth, h: legHeight, angle: -0.8 * Math.sin(anim)};
    // side å®šç¾©
    const side = player.direction === "left" ? -1 : 1;
  } else {
    // æ­£é¢ï¼ˆåƒç´ é¢¨ç«™å§¿ï¼Œé›™è…¿åˆ†é–‹ã€é›™æ‰‹ä¸‹å‚ï¼‰
    headOffsetX = 0;
    headOffsetY = 0;
    bodySkew = 0;
    // æ‡¸ç©ºæ™‚é›™æ‰‹ä¸Šä¸‹æ“ºå‹•
    let armAnim = 0;
    if (!player.onGround) {
      // ä½¿ç”¨ runAnim æˆ– vy ä¾†ç”¢ç”Ÿå‹•ç•«
      armAnim = Math.sin(Date.now() / 20) * 0.8; // é€Ÿåº¦èˆ‡å¹…åº¦
    }
    leftArm = {x: pW*0.01 - armWidth/2, y: bodyY + bodyHeight*0.18, angle: 0.25 + armAnim};
    rightArm = {x: pW - armWidth - pW*0.01 + armWidth/2, y: bodyY + bodyHeight*0.18, angle: -0.25 - armAnim};
    // è…¿éƒ¨åˆ†é–‹ï¼Œè…³å°–å¤–å…«
    leftLeg = {x: pW*0.08, y: legYPos, w: legWidth, h: legHeight, angle: 0.18};
    rightLeg = {x: pW - legWidth - pW*0.08, y: legYPos, w: legWidth, h: legHeight, angle: -0.18};
  }

  // Legs
  ctx.save();
  ctx.translate(leftLeg.x + leftLeg.w/2, leftLeg.y + leftLeg.h/2);
  ctx.rotate(leftLeg.angle || 0);
  ctx.fillStyle = currentPantsColor;
  ctx.fillRect(-leftLeg.w/2, -leftLeg.h/2, leftLeg.w, leftLeg.h);
  ctx.restore();

  ctx.save();
  ctx.translate(rightLeg.x + rightLeg.w/2, rightLeg.y + rightLeg.h/2);
  ctx.rotate(rightLeg.angle || 0);
  ctx.fillStyle = currentPantsColor;
  ctx.fillRect(-rightLeg.w/2, -rightLeg.h/2, rightLeg.w, rightLeg.h);
  ctx.restore();

  // Shoes
  ctx.fillStyle = currentShoeColor;
  ctx.fillRect(leftLeg.x, legY, shoeWidth, shoeHeight);
  ctx.fillRect(rightLeg.x, legY, shoeWidth, shoeHeight);

  // Body
  ctx.save();
  ctx.translate(pW/2, bodyY + bodyHeight/2);
  ctx.rotate(bodySkew);
  ctx.fillStyle = currentShirtColor;
  ctx.fillRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight);
  ctx.restore();

  // Armsï¼ˆé»ƒè‰²é•·è¢–ï¼‰
  // å·¦æ‰‹
  ctx.save();
  // æ—‹è½‰ä¸­å¿ƒè¨­åœ¨è‚©è†€ï¼ˆèº«é«”å´é‚Šä¸Šç·£ï¼‰
  const leftShoulderX = leftArm.x + armWidth / 2;
  const leftShoulderY = leftArm.y;
  ctx.translate(leftShoulderX, leftShoulderY);
  ctx.rotate(leftArm.angle || 0);
  // ç•«é•·è¢–
  ctx.fillStyle = currentShirtColor;
  ctx.fillRect(-armWidth/2, 0, armWidth, armHeight);
  // ç•«æ‰‹æŒ
  ctx.fillStyle = currentSkinColor;
  ctx.beginPath();
  ctx.arc(0, armHeight, armWidth*0.45, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // å³æ‰‹
  ctx.save();
  // æ—‹è½‰ä¸­å¿ƒè¨­åœ¨è‚©è†€ï¼ˆèº«é«”å´é‚Šä¸Šç·£ï¼‰
  const rightShoulderX = rightArm.x + armWidth / 2;
  const rightShoulderY = rightArm.y;
  ctx.translate(rightShoulderX, rightShoulderY);
  ctx.rotate(rightArm.angle || 0);
  // ç•«é•·è¢–
  ctx.fillStyle = currentShirtColor;
  ctx.fillRect(-armWidth/2, 0, armWidth, armHeight);
  // ç•«æ‰‹æŒ
  ctx.fillStyle = currentSkinColor;
  ctx.beginPath();
  ctx.arc(0, armHeight, armWidth*0.45, 0, Math.PI*2);
  ctx.arc(0, armHeight/2, armWidth*0.45, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Head
  ctx.save();
  ctx.translate(headX + headWidth/2 + (headOffsetX||0), headY + headHeight/2 + (headOffsetY||0));
  ctx.fillStyle = currentSkinColor;
  if (player.direction === "left" || player.direction === "right") {
    // å´è‡‰ï¼šæ©¢åœ“ç¨å¾®å£“æ‰ï¼Œè‡‰æœå·¦æˆ–å³
    ctx.beginPath();
    ctx.ellipse(0, 0, headWidth*0.55, headHeight/2, 0, 0, Math.PI*2);
    ctx.fill();

    // è‡‰é °ç´…æšˆ
    ctx.fillStyle = "#ffb6b6";
    ctx.beginPath();
    ctx.ellipse(-headWidth*0.25, headHeight*0.10, headWidth*0.10, headHeight*0.07, 0, 0, Math.PI*2);
    ctx.fill();

    // å–®çœ¼ï¼ˆæ©«ç·šï¼‰
    ctx.strokeStyle = "#222";
    ctx.lineWidth = Math.max(1, pH * 0.06);
    ctx.beginPath();
    let eyeX = -headWidth*0.25;
    ctx.moveTo(eyeX - headWidth*0.06, -headHeight*0.08);
    ctx.lineTo(eyeX + headWidth*0.06, -headHeight*0.08);
    ctx.stroke();

    // é¼»å­ï¼ˆå°é»ï¼‰
    ctx.fillStyle = "#e0a070";
    ctx.beginPath();
    ctx.arc(-headWidth*0.35, 0, headWidth*0.025, 0, Math.PI*2);
    ctx.fill();
  } else {
    // æ­£è‡‰
    ctx.beginPath();
    ctx.ellipse(0, 0, headWidth/2, headHeight/2, 0, 0, Math.PI*2);
    ctx.fill();
    // é›™çœ¼ï¼ˆåˆ†é–‹çš„æ©«ç·šï¼‰
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = Math.max(1, pH * 0.05);
    const eyeWidth = headWidth * 0.18;
    const eyeY = -headHeight * 0.08;
    const eyeXOffset = headWidth * 0.22;
    // å·¦çœ¼
    ctx.beginPath();
    ctx.moveTo(-eyeXOffset - eyeWidth/2, eyeY);
    ctx.lineTo(-eyeXOffset + eyeWidth/2, eyeY);
    ctx.stroke();
    // å³çœ¼
    ctx.beginPath();
    ctx.moveTo(eyeXOffset - eyeWidth/2, eyeY);
    ctx.lineTo(eyeXOffset + eyeWidth/2, eyeY);
    ctx.stroke();
  }
  ctx.restore();

  // Collar
  ctx.fillStyle = collarColor;
  ctx.beginPath();
  ctx.moveTo(pW / 2, bodyY + bodyHeight * 0.25);
  ctx.lineTo(pW / 2 - pW * 0.15, bodyY);
  ctx.lineTo(pW / 2 + pW * 0.15, bodyY);
  ctx.closePath();
  ctx.fill();

  // Hat
  const hatHeight = pH * 0.15;
  const hatY = headY + (headOffsetY||0) - hatHeight;
  const hatWidth = pW * 0.9;
  const hatX = (pW - hatWidth) / 2 + (headOffsetX||0);
  ctx.fillStyle = currentHatColor;
  ctx.beginPath();
  ctx.arc(pW/2 + (headOffsetX||0), hatY + hatHeight, hatWidth/2, Math.PI, 2 * Math.PI);
  ctx.fill();

  // Hat Stripe (ä¸€æ¢ç´…è‰²ç·š)
  ctx.strokeStyle = currentStripeColor;
  ctx.lineWidth = hatHeight * 0.28;
  ctx.beginPath();
  ctx.moveTo(hatX + hatWidth * 0.08, hatY + hatHeight * 0.7);
  ctx.lineTo(hatX + hatWidth * 0.92, hatY + hatHeight * 0.7);
  ctx.stroke();
  ctx.lineWidth = 1;

  // Hat Light
  ctx.fillStyle = currentLightColor;
  const lightSize = pW * 0.2;
  let lightX;
  if (player.direction === "left") {
    // æœ€å·¦å´
    lightX = hatX;
  } else if (player.direction === "right") {
    // é¡å°„å¾Œçš„æœ€å·¦å´ï¼ˆå¯¦éš›ä¸Šæ˜¯æœ€å³å´ï¼‰
    lightX = hatX;
  } else {
    // æ­£é¢ä¸­å¤®
    lightX = pW/2 - lightSize/2 + (headOffsetX||0);
  }
  ctx.fillRect(lightX, hatY, lightSize, lightSize);

  ctx.restore();
}

function drawTopSpikes() {
  ctx.fillStyle = "#cccccc"; // ç°è‰²
  for (let i = 0; i < getWidth(); i += 10) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i + 5, 12);
    ctx.lineTo(i + 10, 0);
    ctx.closePath();
    ctx.fill();
  }
}

function drawPlatforms() {
  for (let idx = 0; idx < platforms.length; idx++) {
    let p = platforms[idx];
    if (p.hidden) continue;
    if (p.type === "normal") {
      // è—è‰²å¹³å°ï¼Œé™°å½±æ·±è—
      ctx.fillStyle = "#3399ff";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.fillStyle = "#003366";
      ctx.fillRect(p.x, p.y + p.height - 3, p.width, 3); // è—è‰²é™°å½±
      ctx.strokeStyle = "#001a44";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
    } else if (p.type === "jump") {
      // ç¶ è‰²åº•
      ctx.fillStyle = "#00e000";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#007700";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // ç•«ç™½è‰²å½ˆç°§ç·šåœˆ
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      let springY = p.y + p.height / 2 + 1;
      for (let i = 0; i < p.width - 8; i += 8) {
        ctx.moveTo(p.x + 4 + i, springY - 2);
        ctx.lineTo(p.x + 8 + i, springY + 2);
        ctx.lineTo(p.x + 12 + i, springY - 2);
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    } else if (p.type === "spike") {
      // å°–åˆºå¹³å°ï¼šå…ˆç¹ªè£½å¹³å°æœ¬èº«ï¼Œå†ç¹ªè£½å°–åˆº
      ctx.fillStyle = "#cccccc"; // ç°è‰²å¹³å°
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#999999";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // åœ¨å¹³å°ä¸Šæ–¹ç¹ªè£½å°–åˆº
      ctx.fillStyle = "#cccccc"; // èˆ‡é ‚éƒ¨å°–åˆºç›¸åŒçš„é¡è‰²
      for (let i = 0; i < p.width; i += 10) {
        ctx.beginPath();
        ctx.moveTo(p.x + i, p.y + p.height);
        ctx.lineTo(p.x + i + 5, p.y + p.height - 20); // å¢åŠ å°–åˆºé«˜åº¦åˆ°20åƒç´ 
        ctx.lineTo(p.x + i + 10, p.y + p.height);
        ctx.closePath();
        ctx.fill();
      }
    } else if (p.type === "vanish") {
      // æ¶ˆå¤±å¹³å°ï¼šæ·ºç°è‰²
      ctx.fillStyle = "#eeeeee";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#bbbbbb";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
    } else if (p.type === "conveyorL" || p.type === "conveyorR") {
      // å‚³è¼¸å¸¶å¹³å°ï¼šç°è‰²åº•+æ·±è‰²æ©«æ¢+ç™½è‰²ç®­é ­
      ctx.fillStyle = "#bbbbbb";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#888888";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // ç•«å·¦å³åŠåœ“
      ctx.save();
      ctx.fillStyle = "#bbbbbb";
      // å·¦åŠåœ“
      ctx.beginPath();
      ctx.arc(p.x, p.y + p.height / 2, p.height / 2, Math.PI / 2, Math.PI * 3 / 2, false);
      ctx.fill();
      // å³åŠåœ“
      ctx.beginPath();
      ctx.arc(p.x + p.width, p.y + p.height / 2, p.height / 2, Math.PI * 3 / 2, Math.PI / 2, false);
      ctx.fill();
      ctx.restore();
      // ç•«æ·±è‰²æ©«æ¢
      ctx.strokeStyle = "#666";
      for (let i = 4; i < p.width; i += 12) {
        ctx.beginPath();
        ctx.moveTo(p.x + i, p.y + 2);
        ctx.lineTo(p.x + i, p.y + p.height - 2);
        ctx.stroke();
      }
      // ç•«ä¸‰å€‹ç™½è‰²ç®­é ­
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      let arrowY = p.y + p.height / 2;
      // è¨ˆç®—ä¸‰å€‹ç®­é ­çš„ä½ç½®ï¼Œå‡å‹»åˆ†å¸ƒåœ¨å¹³å°ä¸Š
      const arrowSpacing = p.width / 4; // å°‡å¹³å°å¯¬åº¦åˆ†æˆ4ä»½ï¼Œç®­é ­åœ¨ç¬¬1ã€2ã€3ä»½çš„ä¸­å¿ƒ
      if (p.type === "conveyorL") {
        // å·¦å‚³é€å¸¶ï¼šç®­é ­æŒ‡å‘å·¦é‚Š
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX + 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX + 6, arrowY + 4);
        }
      } else {
        // å³å‚³é€å¸¶ï¼šç®­é ­æŒ‡å‘å³é‚Š
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX - 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX - 6, arrowY + 4);
        }
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  }
}

function drawHUD() {
  if (!player) return;
  const maxHp = 12;
  let hpHtml = '';
  for (let i = 0; i < maxHp; i++) {
    if (i < player.hp) {
      if (player.hp <= 5) {
        hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:red;border:1px solid #c00;margin-right:2px;"></span>';
      } else {
        hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:yellow;border:1px solid #cc0;margin-right:2px;"></span>';
      }
    } else {
      hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:#333;border:1px solid #222;margin-right:2px;"></span>';
    }
  }
  // åªæ›´æ–°è¡€é‡æ¢å…§å®¹
  const hudHp = document.querySelector('#hud .hud-hp');
  if (hudHp) hudHp.innerHTML = hpHtml;
  // åªæ›´æ–°åˆ†æ•¸èˆ‡æœ€é«˜åˆ†
  const hudHighscore = document.getElementById('hud-highscore');
  if (hudHighscore) hudHighscore.textContent = 'æœ€é«˜: ' + highScore;
  const hudScore = document.getElementById('hud-score');
  if (hudScore) hudScore.textContent = 'åœ°ä¸‹' + String(player.score).padStart(4, "0") + 'éš';
  // åªæ›´æ–°éŸ³æ•ˆ/éŸ³æ¨‚æŒ‰éˆ•æ–‡å­—
  const sfxToggle = document.getElementById('sfx-toggle');
  const bgmToggle = document.getElementById('bgm-toggle');
  if (sfxToggle) sfxToggle.textContent = (sfxMuted ? 'ğŸ”‡' : 'ğŸ”Š') + ' éŸ³æ•ˆ';
  if (bgmToggle) bgmToggle.textContent = (bgmMuted ? 'ğŸ”‡' : 'ğŸµ') + ' éŸ³æ¨‚';
}

function updatePlayer() {
  player.vy += player.gravity;
  player.y += player.vy;

  // é ‚ç«¯å°–åˆºç¢°æ’ - ç²¾éˆå¸½å­é ‚ç«¯ç¢°åˆ°å°–åˆºå°±å—å‚·
  const hatTopY = player.y; // å¸½å­é ‚ç«¯ä½ç½®ï¼ˆç²¾éˆçš„yåº§æ¨™å°±æ˜¯å¸½å­é ‚ç«¯ï¼‰
  if (hatTopY <= 12) { // å°–åˆºé«˜åº¦æ˜¯12åƒç´ 
    if (lastPlatformTouched !== 'topSpike') {
      playSfxPool('spike'); // æ’­æ”¾è¢«åˆºåˆ°éŸ³æ•ˆ
      player.hp -= 5;
      lastPlatformTouched = 'topSpike';
      player.isHurt = true;
      player.hurtTimer = 1000;
      // å°‡æ­£ä¸‹æ–¹å¹³å°è¨­ç‚º hidden
      platforms.forEach(p => {
        const overlap =
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height <= p.y + p.height &&
          player.y + player.height >= p.y;
        if (overlap && (p.type === 'normal' || p.type === 'spike' || p.type === 'conveyorL' || p.type === 'conveyorR')) {
          p.hidden = true;
        }
      });
    }
    player.y = 12; // å°‡ç²¾éˆå¸½å­é ‚ç«¯åœåœ¨å°–åˆºä¸‹æ–¹
    player.vy = 0;
    player.fallThrough = true; // é–‹å•Ÿç©¿é€ç‹€æ…‹
  } else if (lastPlatformTouched === 'topSpike') {
    lastPlatformTouched = null;
    player.fallThrough = false; // é›¢é–‹é ‚ç«¯ï¼Œæ¢å¾©æ­£å¸¸
  }

  if (keys["ArrowLeft"]) player.vx = -player.speed;
  else if (keys["ArrowRight"]) player.vx = player.speed;
  else player.vx = 0;

  player.x += player.vx;
  if (player.x < 0) player.x = 0;
  if (player.x + player.width > getWidth()) player.x = getWidth() - player.width;

  player.onGround = false;
  // è‹¥åœ¨ç©¿é€ç‹€æ…‹ï¼Œè·³éå¹³å°ç¢°æ’
  if (!player.fallThrough) {
    for (let p of platforms) {
      if (p.hidden) continue;
      if (player.vy >= 0 &&
          player.x + player.width > p.x &&
          player.x < p.x + p.width &&
          player.y + player.height > p.y &&
          player.y + player.height < p.y + p.height + player.vy) {
        player.y = p.y - player.height;
        player.onGround = true;
        if (p.type === "spike") {
          if (lastPlatformTouched !== p) {
            playSfxPool('spike'); // æ’­æ”¾è¢«åˆºåˆ°éŸ³æ•ˆ
            player.hp -= 5;
            lastPlatformTouched = p;
            player.isHurt = true;
            player.hurtTimer = 1000;
          }
          player.vy = 0;
        } else if (p.type === "jump") {
          playSfxPool('jump'); // æ’­æ”¾å½ˆè·³éŸ³æ•ˆ
          // å–å¾—å¹³å°é–“è·
          const platformSpacing = getHeight() / 8; // ä½ çš„éŠæˆ²æ¯8å±¤åˆ†å¸ƒ
          const g = player.gravity;
          // è¨ˆç®—æ¯”ä¸€å±¤é«˜ä¸€é»é»çš„åˆé€Ÿåº¦ï¼ˆ1.15å€å¹³å°é–“è·ï¼‰
          const maxVy = -Math.sqrt(2 * g * platformSpacing * 1.15);
          player.vy = maxVy;
          player.hp = Math.min(player.hp + 1, 12); // æ¯æ¬¡è·³éƒ½è£œä¸€æ»´
          lastPlatformTouched = p;
        } else if (p.type === "normal") {
          if (lastPlatformTouched !== p) {
            playSfxPool('normal'); // æ’­æ”¾ä¸€èˆ¬å¹³å°éŸ³æ•ˆ
            player.hp = Math.min(player.hp + 1, 12);
            lastPlatformTouched = p;
          }
          player.vy = 0;
        } else if (p.type === "vanish") {
          player.vy = 0;
          if (p.vanishTimer === null) {
            playSfxPool('normal'); // å…ˆæ’­æ”¾ä¸€èˆ¬å¹³å°éŸ³æ•ˆ
            p.vanishTimer = Date.now();
            player.hp = Math.min(player.hp + 1, 12);
          } else if (Date.now() - p.vanishTimer >= 200) {
            p.hidden = true;
            playSfxPool('vanish'); // æ’­æ”¾æ¶ˆå¤±éŸ³æ•ˆ
            break;
          }
          lastPlatformTouched = p;
        } else if (p.type === "conveyorL" || p.type === "conveyorR") {
          player.vy = 0;
          if (p.type === "conveyorL") {
            player.x -= 1.5;
          } else {
            player.x += 1.5;
          }
          if (lastPlatformTouched !== p) {
            playSfxPool('normal'); // æ’­æ”¾ä¸€èˆ¬å¹³å°éŸ³æ•ˆ
            player.hp = Math.min(player.hp + 1, 12);
            lastPlatformTouched = p;
          }
        }
      } else if (p.type === "vanish") {
        // é›¢é–‹å¹³å°æ™‚é‡è¨­ vanishTimer
        p.vanishTimer = null;
      }
    }
  }

  if (player.y > getHeight() || (player.hp <= 0 && !player.fallThrough)) {
    setTimeout(() => {
      playSfxPool('dead'); // æ’­æ”¾æ­»äº¡éŸ³æ•ˆ
      // æ›´æ–°æœ€é«˜åˆ†æ•¸
      if (player.score > highScore) {
        highScore = player.score;
        localStorage.setItem('ns_shaft_highscore', highScore);
      }
      showGameOverModal(player.score, player.score >= highScore);
    }, 100);
    return false;
  }

  if (player.vx < 0) player.direction = "left";
  else if (player.vx > 0) player.direction = "right";
  else player.direction = "front";

  if (player.vx !== 0) {
    player.runAnim += Math.abs(player.vx) * 0.28;
  } else {
    player.runAnim = 0;
  }

  return true;
}

function updatePlatforms() {
  // å¹³å°é€Ÿåº¦éš¨åˆ†æ•¸å¢åŠ è€Œè®Šå¿«
  const baseSpeed = 1.5;
  const speedIncrement = 0.05; // æ¯å±¤å¢åŠ çš„é€Ÿåº¦
  const platformSpeed = baseSpeed + (player.score * speedIncrement);
  
  for (let p of platforms) {
    p.y -= platformSpeed;
  }
  
  // è™•ç†æ¶ˆå¤±èˆ‡é‡ç”Ÿ
  for (let i = 0; i < platforms.length; i++) {
    let p = platforms[i];
    if (p.y + p.height < 0) {
      // åªè¦å¹³å°ï¼ˆä¸è«– hidden èˆ‡å¦ï¼‰é›¢é–‹ç•«é¢é ‚ç«¯å°±è¨ˆæ•¸
      platformPassedCount++;
      if (platformPassedCount % 5 === 0) {
        player.score++;
      }
      // å¹³å°é‡ç”Ÿ
      const platformWidth = Math.floor(getWidth() * 0.25); // å¹³å°å¯¬åº¦ç‚ºç¸½å¯¬åº¦çš„25%
      const platformHeight = 10;
      const platformSpacing = getHeight() / 8; // å›ºå®šé–“è·
      // æ‰¾åˆ°æœ€ä¸‹æ–¹çš„å¹³å°ï¼Œåœ¨å…¶ä¸‹æ–¹å›ºå®šé–“è·è™•ç”Ÿæˆæ–°å¹³å°
      let lowestPlatform = null;
      for (let otherP of platforms) {
        if (otherP !== p && (lowestPlatform === null || otherP.y > lowestPlatform.y)) {
          lowestPlatform = otherP;
        }
      }
      let newY, newX;
      if (lowestPlatform) {
        newY = lowestPlatform.y + platformSpacing;
      } else {
        newY = getHeight();
      }
      let tryCount = 0;
      do {
        newX = Math.random() * (getWidth() - platformWidth);
        tryCount++;
      } while (
        tryCount < 20 &&
        player.x + player.width > newX &&
        player.x < newX + platformWidth &&
        player.y + player.height <= newY + platformHeight &&
        player.y + player.height >= newY
      );
      p.y = newY;
      p.x = newX;
      // å¹³å°é¡å‹åˆ†é…ï¼ˆæ›´å¹³å‡ï¼‰
      const availableTypes = getAvailablePlatformTypes();
      const type = availableTypes[Math.floor(Math.random() * availableTypes.length)] || "normal";
      p.type = type;
      p.vanishTimer = null;
      p.hidden = false; // é‡ç”Ÿæ™‚æ¢å¾©é¡¯ç¤º
    }
  }
  
  // æª¢æŸ¥å¹³å°æ•¸é‡ï¼Œå¦‚æœå°‘æ–¼8å€‹å°±è£œå……
  const targetPlatformCount = 8;
  while (platforms.length < targetPlatformCount) {
    const platformWidth = Math.floor(getWidth() * 0.25); // å¹³å°å¯¬åº¦ç‚ºç¸½å¯¬åº¦çš„25%
    const platformHeight = 10;
    const platformSpacing = getHeight() / 8; // å›ºå®šé–“è·
    
    // æ‰¾åˆ°æœ€ä¸‹æ–¹çš„å¹³å°ï¼Œåœ¨å…¶ä¸‹æ–¹å›ºå®šé–“è·è™•ç”Ÿæˆæ–°å¹³å°
    let lowestPlatform = null;
    for (let p of platforms) {
      if (lowestPlatform === null || p.y > lowestPlatform.y) {
        lowestPlatform = p;
      }
    }
    
    let newY, newX;
    if (lowestPlatform) {
      // åœ¨æœ€ä¸‹æ–¹å¹³å°ä¸‹æ–¹å›ºå®šé–“è·è™•ç”Ÿæˆ
      newY = lowestPlatform.y + platformSpacing;
    } else {
      // å¦‚æœæ²’æœ‰å…¶ä»–å¹³å°ï¼Œåœ¨ç•«é¢åº•éƒ¨ç”Ÿæˆ
      newY = getHeight();
    }
    
    // ç”ŸæˆXä½ç½®ï¼Œé¿å…èˆ‡ç©å®¶é‡ç–Š
    let attempts = 0;
    do {
      newX = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (
      attempts < 20 &&
      player.x + player.width > newX &&
      player.x < newX + platformWidth &&
      player.y + player.height <= newY + platformHeight &&
      player.y + player.height >= newY
    );
    
    // ç”Ÿæˆæ–°å¹³å°
    let newPlatform = {
      x: newX,
      y: newY,
      width: platformWidth,
      height: platformHeight,
      type: "normal", // é è¨­ç‚ºæ™®é€šå¹³å°
      vanishTimer: null,
      hidden: false
    };
    // å¹³å°é¡å‹åˆ†é…ï¼ˆæ›´å¹³å‡ï¼‰
    const availableTypes2 = getAvailablePlatformTypes();
    newPlatform.type = availableTypes2[Math.floor(Math.random() * availableTypes2.length)] || "normal";
    platforms.push(newPlatform);
  }
}

function togglePause() {
  paused = !paused;
  if (!paused) requestAnimationFrame(gameLoop);
  // å¯åŠ æš«åœæç¤º
  document.getElementById('pause-btn').innerText = paused ? 'â¸ï¸' : 'â¯ï¸';
}

function gameLoop() {
  if (paused) return;
  ctx.clearRect(0, 0, getWidth(), getHeight());
  // ç•«æ·±è—è‰²æ¼¸å±¤èƒŒæ™¯ï¼ˆæ›´æ¥è¿‘åŸä½œï¼‰
  let grad = ctx.createLinearGradient(0, 0, 0, getHeight());
  grad.addColorStop(0, "#001a33");
  grad.addColorStop(1, "#003366");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, getWidth(), getHeight());
  drawTopSpikes(); // ç•«é ‚ç«¯å°–åˆº
  if (!updatePlayer()) return;
  updatePlatforms();
  drawPlatforms();
  drawPlayer();
  drawHUD();
  // åŠ ä¸ŠéŠæˆ²å€åŸŸé‚Šæ¡†
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.strokeRect(0, 0, getWidth(), getHeight());
  ctx.lineWidth = 1;
  if (player.isHurt && player.hurtTimer > 0) {
    player.hurtTimer -= 16; // ç´„ç­‰æ–¼ä¸€å¹€16ms
    if (player.hurtTimer <= 0) {
      player.isHurt = false;
      player.hurtTimer = 0;
    }
  }
  animationFrameId = requestAnimationFrame(gameLoop);
}

// è§¸æ§èˆ‡æŒ‰éˆ•æ“ä½œ
const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const pauseBtn = document.getElementById('pause-btn');

function setKey(key, val) {
  keys[key] = val;
}

// ç§»é™¤ canvas ä¸Šçš„æ»‘å‹•åµæ¸¬ï¼ˆåŸæœ¬çš„ canvas.addEventListener('touchstart'...) åŠ touchend äº‹ä»¶ï¼‰
// æ”¹ç‚ºå…¨ç•«é¢è§¸æ§åµæ¸¬
function handleTouch(e) {
  let left = false, right = false;
  const half = window.innerWidth / 2;
  for (let i = 0; i < e.touches.length; i++) {
    const x = e.touches[i].clientX;
    if (x < half) left = true;
    if (x >= half) right = true;
  }
  setKey('ArrowLeft', left);
  setKey('ArrowRight', right);
}

window.addEventListener('touchstart', handleTouch);
window.addEventListener('touchmove', handleTouch);
window.addEventListener('touchend', function(e) {
  setKey('ArrowLeft', false);
  setKey('ArrowRight', false);
});
window.addEventListener('touchcancel', function(e) {
  setKey('ArrowLeft', false);
  setKey('ArrowRight', false);
});

btnLeft.addEventListener('touchstart', e => { e.preventDefault(); setKey('ArrowLeft', true); });
btnLeft.addEventListener('touchend', e => { e.preventDefault(); setKey('ArrowLeft', false); });
btnLeft.addEventListener('mousedown', e => { setKey('ArrowLeft', true); });
btnLeft.addEventListener('mouseup', e => { setKey('ArrowLeft', false); });
btnLeft.addEventListener('mouseleave', e => { setKey('ArrowLeft', false); });

btnRight.addEventListener('touchstart', e => { e.preventDefault(); setKey('ArrowRight', true); });
btnRight.addEventListener('touchend', e => { e.preventDefault(); setKey('ArrowRight', false); });
btnRight.addEventListener('mousedown', e => { setKey('ArrowRight', true); });
btnRight.addEventListener('mouseup', e => { setKey('ArrowRight', false); });
btnRight.addEventListener('mouseleave', e => { setKey('ArrowRight', false); });

pauseBtn.addEventListener('click', togglePause);

// é˜²æ­¢æš«åœéµè§¸æ§æ™‚è§¸ç™¼å·¦å³ç§»å‹•
pauseBtn.addEventListener('touchstart', e => {
  e.preventDefault();
  e.stopPropagation();
});
pauseBtn.addEventListener('touchend', e => {
  e.preventDefault();
  e.stopPropagation();
  setKey('ArrowLeft', false);
  setKey('ArrowRight', false);
});

// éŠæˆ²çµæŸè‡ªè¨‚å½ˆçª—
function showGameOverModal(score, isNewRecord) {
  const modal = document.getElementById('gameover-modal');
  const msg = document.getElementById('gameover-msg');
  msg.innerHTML = `éŠæˆ²çµæŸï¼<br>æ¨“å±¤: <b style="color:yellow;">${score}</b>${isNewRecord ? '<br><span style="color:#0f0;">æ–°ç´€éŒ„ï¼</span>' : ''}`;
  modal.style.display = 'flex';
}

document.getElementById('restart-btn').addEventListener('click', () => {
  document.getElementById('gameover-modal').style.display = 'none';
  initGame();
});

// ä¿®æ”¹window.keydownäº‹ä»¶
window.addEventListener('keydown', function(e) {
  const modal = document.getElementById('gameover-modal');
  if (modal.style.display === 'flex' && (e.key === 'Enter' || e.keyCode === 13)) {
    modal.style.display = 'none';
    initGame();
    e.preventDefault(); // é˜²æ­¢Enterè§¸ç™¼å…¶ä»–æŒ‰éˆ•
    return;
  }
  if (e.key === 'p' || e.key === 'P') {
    togglePause();
  }
});

window.addEventListener('DOMContentLoaded', function() {
  // åªæ›ä¸€æ¬¡äº‹ä»¶ç›£è½å™¨
  document.addEventListener("keydown", e => keys[e.key] = true);
  document.addEventListener("keyup", e => keys[e.key] = false);
  const sfxToggle = document.getElementById('sfx-toggle');
  const bgmToggle = document.getElementById('bgm-toggle');
  // å¼·åˆ¶ç§»é™¤èšç„¦
  if (sfxToggle) sfxToggle.blur();
  if (bgmToggle) bgmToggle.blur();
  // é˜»æ­¢èšç„¦
  [sfxToggle, bgmToggle].forEach(btn => {
    if (btn) {
      btn.addEventListener('mousedown', e => { btn.blur(); });
      btn.addEventListener('mouseup', e => { btn.blur(); });
      btn.addEventListener('click', e => { btn.blur(); });
      btn.addEventListener('keydown', e => { btn.blur(); if (e.key === 'Enter' || e.keyCode === 13) e.preventDefault(); });
    }
  });
  if (sfxToggle) {
    sfxToggle.addEventListener('click', function() {
      sfxMuted = !sfxMuted;
      sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
      sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
      sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
      sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
      sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
      drawHUD();
    });
  }
  if (bgmToggle) {
    bgmToggle.addEventListener('click', function() {
      bgmMuted = !bgmMuted;
      bgm.muted = bgmMuted;
      if (bgmMuted) {
        bgm.pause();
      } else {
        try { bgm.play(); } catch (e) {}
      }
      drawHUD();
    });
  }
  drawHUD(); // åˆå§‹åŒ–é¡¯ç¤º
});

function handleFirstInteraction() {
  if (!firstInteraction) {
    firstInteraction = true;
    // ä¸è¦å¼·åˆ¶æ”¹è®ŠéœéŸ³ç‹€æ…‹ï¼ŒåªåŒæ­¥ audio æ¨™ç±¤
    sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
    sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
    sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
    sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
    sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
    bgm.muted = bgmMuted;
    tryPlayBgm();
  }
}
window.addEventListener('click', handleFirstInteraction, { once: true });
window.addEventListener('touchstart', handleFirstInteraction, { once: true });

initGame();
</script>
</body>
</html>
