<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>NS-Shaft 簡化版</title>
  <style>
    html, body {
      width: 100vw;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      min-width: 100vw;
      justify-content: flex-start;
      align-items: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #002245;
    }
    #hud {
      width: 95vw;
      max-width: 420px;
      margin: 0 auto;
      color: #fff;
      font-family: 'Arial Black', Arial, sans-serif;
      font-size: min(3vw, 14px);
      letter-spacing: 1px;
      user-select: none;
      text-shadow: 1px 1px 2px #000;
      height: auto;
      line-height: 1.1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-sizing: border-box;
      padding: 0 4px;
      white-space: nowrap;
      overflow: visible;
      position: static;
      margin-top: 6px;
      margin-bottom: 2px;
      z-index: auto;
    }
    #hud .hud-hp {
      display: flex;
      gap: 2px;
      flex-wrap: nowrap;
      min-width: 0;
      max-width: none;
      height: 14px;
    }
    #hud .hud-score {
      font-weight: bold;
      flex: 1;
      text-align: center;
      font-size: min(9vw, 40px) !important;
      letter-spacing: 2px;
      text-shadow: 2px 2px 6px #000,0 0 8px #0f0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }
    #hud-center span {
      line-height: 1.1 !important;
    }
    #hud-audio-panel button {
      font-size: 0.95rem !important;
      padding: 2px 6px !important;
      border-radius: 8px !important;
      margin-bottom: 2px;
    }
    #hud-audio-panel {
      gap: 2px !important;
    }
    /* 移除控制按鈕樣式 */
    #game {
      width: 100vw;
      max-width: 480px;
      height: 90vh;
      max-height: 100vh;
      background: #002244;
      display: block;
      margin: 0 auto;
      touch-action: none;
      padding-bottom: 0; /* 移除底部按鈕的預留空間 */
    }
    /* 新增底部控制區域樣式 */
    #bottom-controls {
      position: fixed;
      left: 50%;
      bottom: 0;
      transform: translateX(-50%);
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 4px;
      z-index: 100;
      width: 100vw;
      max-width: 480px;
      justify-content: center;
      padding: 4px 0 4px 0;
      background: rgba(0,0,0,0.7);
      border-radius: 16px 16px 0 0;
      flex-wrap: nowrap;
    }
    #bottom-controls button {
      font-size: 0.7rem !important;
      padding: 1px 3px !important;
      border-radius: 7px !important;
      min-width: 0;
      max-width: 70px;
      height: 28px;
      line-height: 1.1;
      box-sizing: border-box;
      white-space: nowrap;
      background: #222;
      color: #fff;
      border: 2px solid #888;
      box-shadow: 0 2px 8px #0008;
      transition: background 0.2s;
      touch-action: manipulation;
    }
    #bottom-controls button:active {
      background: #444;
    }
    #bottom-controls #pause-toggle {
      max-width: 80px;
      padding: 1px 8px !important;
    }
    @media (max-width: 600px) {
      #hud {
        font-size: 12px;
        height: auto;
        line-height: 1.1;
        padding: 2px 0 2px 0;
        margin-top: 2px;
        margin-bottom: 2px;
      }
      #game {
        height: 90vh;
        max-height: 100vh;
        padding-bottom: 0; /* 移除底部按鈕的預留空間 */
      }
      #hud .hud-score {
        font-size: 28px !important;
      }
      #hud-center span {
        font-size: 11px !important;
      }
      #hud .hud-hp {
        height: 10px !important;
      }
      #hud-audio-panel button {
        font-size: 0.8rem !important;
        padding: 1px 4px !important;
      }
      /* 底部控制區域響應式設計 */
      #bottom-controls {
        gap: 1px;
        max-width: 100vw;
        padding: 2px 0 2px 0;
      }
      #bottom-controls button {
        font-size: 0.65rem !important;
        padding: 0 1px !important;
        border-radius: 6px !important;
        max-width: 28vw;
        height: 22px;
      }
      #bottom-controls #pause-toggle {
        max-width: 32vw;
        padding: 0 4px !important;
      }
    }
  </style>
</head>
<body>
<!-- 音效與背景音樂 -->
<audio id="sfx-normal" src="Data_1.wav" preload="auto"></audio>
<audio id="sfx-jump" src="Data_3.wav" preload="auto"></audio>
<audio id="sfx-spike" src="Data_4.wav" preload="auto"></audio>
<audio id="sfx-vanish" src="Data_5.wav" preload="auto"></audio>
<audio id="sfx-dead" src="Data_6.wav" preload="auto"></audio>
<audio id="bgm" src="BGM.mp3" preload="auto" loop></audio>
<div id="hud">
  <span class="hud-hp" style="z-index:1;position:relative;justify-content:flex-start;flex:0 0 auto;"></span>
  <div id="hud-center" style="display:flex;flex-direction:column;align-items:center;justify-content:center;flex:1 1 0%;min-width:0;max-width:100%;">
    <span id="hud-highscore" style="color:#fff;font-size:clamp(13px,2.8vw,20px);text-shadow:1px 1px 2px #000;white-space:normal;overflow:visible;text-overflow:clip;max-width:100%;display:block;text-align:center;line-height:1.2;word-break:break-all;"></span>
    <span class="hud-score" id="hud-score" style="color:#00ff00;font-size:clamp(18px,4vw,32px);text-shadow:2px 2px 6px #000,0 0 8px #0f0;letter-spacing:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:100%;margin:0 auto;text-align:center;line-height:1.2;word-break:break-all;"></span>
  </div>
</div>
<canvas id="game"></canvas>
<!-- 新增底部控制區 -->
<div id="bottom-controls">
  <button id="pause-toggle" type="button">⏸️ 暫停</button>
  <button id="sfx-toggle" type="button">🔊 音效</button>
  <button id="bgm-toggle" type="button">🎵 音樂</button>
  <button id="settings-toggle" type="button">⚙️ 設定</button>
  <button id="help-toggle" type="button">❓ 說明</button>
  <button id="about-toggle" type="button">ℹ️ 關於</button>
</div>
<div id="gameover-modal" style="display:none;position:fixed;z-index:1000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:32px 24px 24px 24px;border-radius:18px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:center;user-select:none;">
    <div id="gameover-msg" style="color:#fff;font-size:1.5rem;margin-bottom:18px;user-select:none;"></div>
    <button id="restart-btn" style="font-size:1.2rem;padding:10px 32px;background:#ff0;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;user-select:none;">重新開始</button>
  </div>
</div>

<!-- 操作說明彈窗 -->
<div id="help-modal" style="display:none;position:fixed;z-index:2000;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:28px 18px 18px 18px;border-radius:16px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:left;user-select:none;min-width:260px;">
    <div style="color:#ffe600;font-size:1.3rem;margin-bottom:12px;font-weight:bold;">NS-Shaft 操作說明</div>
    <div style="color:#fff;font-size:1rem;line-height:1.7;">
      <b>遊戲目標：</b>操控角色不斷往下跳，挑戰更深樓層分數！<br><br>
      <b>操作方式：</b><br>
      ● <b>左右方向鍵</b> 或 <b>觸控螢幕左右</b> 控制角色移動。<br>
      ● 角色會自動下落，踩到平台會停止。<br>
      ● 不同平台有特殊效果：<br>
      &nbsp;&nbsp;• 藍色平台：普通平台，恢復1點血量<br>
      &nbsp;&nbsp;• 綠色彈簧：彈跳平台，跳更高並恢復1點血量<br>
      &nbsp;&nbsp;• 灰色尖刺：受傷平台，扣5點血量<br>
      &nbsp;&nbsp;• 白色消失：踩踏後會消失的平台<br>
      &nbsp;&nbsp;• 傳送帶：會推動角色移動的平台<br>
      ● 血量歸零或掉落畫面底部遊戲結束。<br>
    </div>
    <div style="text-align:center;margin-top:18px;">
      <button id="help-close-btn" style="font-size:1rem;padding:6px 32px;background:#ffe600;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;">關閉</button>
    </div>
  </div>
</div>

<!-- 遊戲設定彈窗 -->
<div id="settings-modal" style="display:none;position:fixed;z-index:2100;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:28px 18px 18px 18px;border-radius:16px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:left;user-select:none;min-width:260px;">
    <div style="color:#ffe600;font-size:1.3rem;margin-bottom:12px;font-weight:bold;">遊戲設定</div>
    <div style="color:#fff;font-size:1rem;line-height:2;">
      <label style="display:block;margin-bottom:8px;">
        <span style="margin-right:8px;">遊戲速度：</span>
        <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
          <span style="font-size:0.8rem;color:#ccc;">慢</span>
          <button id="speed-decrease" type="button" style="width:32px;height:32px;border-radius:50%;border:2px solid #666;background:#333;color:#fff;font-size:1.2rem;font-weight:bold;cursor:pointer;">-</button>
          <div style="flex:1;height:20px;background:#333;border-radius:10px;border:1px solid #666;position:relative;display:flex;align-items:center;justify-content:center;">
            <div id="speed-display" style="font-size:0.9rem;color:#ffe600;font-weight:bold;">1.0</div>
          </div>
          <button id="speed-increase" type="button" style="width:32px;height:32px;border-radius:50%;border:2px solid #666;background:#333;color:#fff;font-size:1.2rem;font-weight:bold;cursor:pointer;">+</button>
          <span style="font-size:0.8rem;color:#ccc;">快</span>
        </div>
      </label>
      <!-- 新增行走速度控制 -->
      <label style="display:block;margin-bottom:8px;">
        <span style="margin-right:8px;">行走速度：</span>
        <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
          <span style="font-size:0.8rem;color:#ccc;">慢</span>
          <button id="walkspeed-decrease" type="button" style="width:32px;height:32px;border-radius:50%;border:2px solid #666;background:#333;color:#fff;font-size:1.2rem;font-weight:bold;cursor:pointer;">-</button>
          <div style="flex:1;height:20px;background:#333;border-radius:10px;border:1px solid #666;position:relative;display:flex;align-items:center;justify-content:center;">
            <div id="walkspeed-display" style="font-size:0.9rem;color:#ffe600;font-weight:bold;">6.0</div>
          </div>
          <button id="walkspeed-increase" type="button" style="width:32px;height:32px;border-radius:50%;border:2px solid #666;background:#333;color:#fff;font-size:1.2rem;font-weight:bold;cursor:pointer;">+</button>
          <span style="font-size:0.8rem;color:#ccc;">快</span>
        </div>
      </label>
    </div>
    <div style="text-align:center;margin-top:18px;">
      <button id="settings-close-btn" style="font-size:1rem;padding:6px 32px;background:#ffe600;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;">關閉</button>
    </div>
  </div>
</div>

<!-- 關於彈窗 -->
<div id="about-modal" style="display:none;position:fixed;z-index:2200;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;flex-direction:column;">
  <div style="background:#222;padding:28px 18px 18px 18px;border-radius:16px;box-shadow:0 4px 24px #000a;max-width:90vw;text-align:left;user-select:none;min-width:260px;">
    <div style="color:#ffe600;font-size:1.3rem;margin-bottom:12px;font-weight:bold;">關於 NS-Shaft 簡化版</div>
    <div style="color:#fff;font-size:1rem;line-height:1.7;">
      <b>遊戲版本：</b>1.0<br>
      <b>遊戲類型：</b>平台跳躍<br>
      <b>開發語言：</b>HTML5 + JavaScript<br>
      <br>
      <b>感謝支持：</b><br>
      中國信託帳戶 銀行代碼822<br>
      159540291165 戶名：張書維<br>
      <br>
      <b>聯絡方式：</b><br>
      作者Line：game76420<br>
      <br>
      <b>版權聲明：</b><br>
      © 2024 張書維. 保留所有權利。
    </div>
    <div style="text-align:center;margin-top:18px;">
      <button id="about-close-btn" style="font-size:1rem;padding:6px 32px;background:#ffe600;color:#222;border:none;border-radius:8px;box-shadow:0 2px 8px #0008;font-weight:bold;">關閉</button>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// 響應式調整canvas解析度
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.offsetWidth;
  const h = canvas.offsetHeight;
  canvas.width = w * ratio;
  canvas.height = h * ratio;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(ratio, ratio);
}

// 不要用 const WIDTH/HEIGHT，改成 function
function getWidth() {
  return canvas.width / (window.devicePixelRatio || 1);
}
function getHeight() {
  return canvas.height / (window.devicePixelRatio || 1);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let player, platforms, keys, lastPlatformTouched;
let bloodParticles = []; // 新增：用於存放噴血粒子
let debrisParticles = []; // 新增：用於存放平台碎塊
let gameSpeed = 1; // 修改預設速度為1
let lastPlayerFloorY = null;
let platformPassedCount = 0; // 記錄經過的平台數
let highScore = 0;
let paused = false;
let firstInteraction = false;
let animationFrameId = null;
let walkSpeed = 4.5;

// 新增：固定時間步長系統
const FIXED_TIMESTEP = 1/60; // 固定時間步長 60FPS
let lastTime = 0;
let accumulator = 0;

// 新增：統一平台間距計算函數
function getPlatformSpacing() {
  const platformWidth = Math.floor(getWidth() * 0.25);
  const playerWidth = Math.floor(platformWidth / 2);
  const playerHeight = playerWidth;
  return playerHeight * 1.4; // 平台間距 = 精靈身高 * 1.4
}

// 讀取最高分數
if (localStorage.getItem('ns_shaft_highscore')) {
  highScore = parseInt(localStorage.getItem('ns_shaft_highscore')) || 0;
}

// 平台類型與上限
const PLATFORM_TYPES = ["normal", "jump", "spike", "vanish", "conveyorL", "conveyorR"];
const PLATFORM_TYPE_LIMIT = {
  normal: 3,       // 限制普通平台也最多3個
  jump: 2,         // 減少彈跳平台數量
  spike: 2,        // 減少尖刺平台數量
  vanish: 2,       // 減少消失平台數量
  conveyorL: 1,    // 限制傳送帶
  conveyorR: 1     // 限制傳送帶
};

function countPlatformTypes() {
  const count = {normal:0, jump:0, spike:0, vanish:0, conveyorL:0, conveyorR:0};
  for (let p of platforms) {
    if (!p.hidden && count.hasOwnProperty(p.type)) count[p.type]++;
  }
  return count;
}

function getAvailablePlatformTypes() {
  const counts = countPlatformTypes();
  const available = PLATFORM_TYPES.filter(type => counts[type] < PLATFORM_TYPE_LIMIT[type]);
  // 如果沒有可用的平台類型，強制允許普通平台
  return available.length > 0 ? available : ['normal'];
}

// 新增函數：根據現有平台分布計算權重
function calculateTypeWeights() {
  const counts = countPlatformTypes();
  const weights = {};
  // 計算每種類型的權重（出現次數越少權重越高）
  for (const type of PLATFORM_TYPES) {
    const count = counts[type];
    const limit = PLATFORM_TYPE_LIMIT[type];
    if (count < limit) {
      weights[type] = (limit - count) / limit; // 權重為剩餘空間比例
    } else {
      weights[type] = 0;
    }
  }
  return weights;
}

// 新增函數：根據權重選擇平台類型
function selectPlatformType() {
  const weights = calculateTypeWeights();
  const available = PLATFORM_TYPES.filter(type => weights[type] > 0);
  if (available.length === 0) return 'normal';
  
  // 根據權重隨機選擇
  const totalWeight = available.reduce((sum, type) => sum + weights[type], 0);
  let random = Math.random() * totalWeight;
  
  for (const type of available) {
    random -= weights[type];
    if (random <= 0) return type;
  }
  return available[0];
}

// 音效池
function createAudioPool(src, poolSize = 4) {
  const pool = [];
  for (let i = 0; i < poolSize; i++) {
    const audio = new Audio(src);
    audio.preload = "auto";
    pool.push(audio);
  }
  return pool;
}

const sfxPools = {
  normal: createAudioPool("Data_1.wav"),
  jump: createAudioPool("Data_3.wav"),
  spike: createAudioPool("Data_4.wav"),
  vanish: createAudioPool("Data_5.wav"),
  dead: createAudioPool("Data_6.wav"),
};

function playSfxPool(poolName) {
  if (sfxMuted) return;
  const pool = sfxPools[poolName];
  if (!pool) return;
  for (let audio of pool) {
    if (audio.paused || audio.ended) {
      audio.muted = sfxMuted;
      audio.currentTime = 0;
      audio.play();
      break;
    }
  }
}

// 新增音效與音樂靜音狀態
let sfxMuted = false;
let bgmMuted = true;

// 音效播放輔助（可重疊播放）
function playSfx(audio) {
  if (!audio) return;
  audio.muted = sfxMuted; // 確保每次播放時都同步靜音狀態
  if (sfxMuted) return;
  try {
    audio.currentTime = 0;
    audio.play();
  } catch (e) {}
}

// 背景音樂自動播放（需用戶互動後觸發）
function tryPlayBgm() {
  if (bgm.paused && !bgmMuted) {
    bgm.volume = 0.5;
    bgm.play().catch(()=>{});
  }
}

function initGame() {
  // 先確保 gameover-modal 隱藏，避免canvas尺寸為0
  var modal = document.getElementById('gameover-modal');
  if (modal) modal.style.display = 'none';
  // 取消舊的動畫循環
  if (animationFrameId !== null) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  bloodParticles = []; // 新增：重置時清空粒子
  debrisParticles = []; // 新增：重置時清空粒子
  
  // 重置固定時間步長系統
  lastTime = 0;
  accumulator = 0;
  
  resizeCanvas();
  paused = false;
  platforms = [];
  const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
  const platformHeight = 12; // 增加厚度
  const playerWidth = Math.floor(platformWidth / 2);
  const playerHeight = playerWidth; // 精靈高度等於寬度，保持正方形
  const platformSpacing = getPlatformSpacing(); // 使用統一函數
  const numPlatforms = Math.ceil(getHeight() / platformSpacing);

  for (let i = 0; i < numPlatforms; i++) {
    let type;
    if (i === numPlatforms - 1) {
      type = "normal"; // 最底下的平台固定為普通平台
    } else {
      // 更平均的平台類型分配
      let rand = Math.random();
      if (rand < 0.2) type = "normal";      // 20% 普通平台
      else if (rand < 0.4) type = "jump";   // 20% 彈跳平台
      else if (rand < 0.6) type = "spike";  // 20% 尖刺平台
      else if (rand < 0.8) type = "vanish"; // 20% 消失平台
      else if (rand < 0.9) type = "conveyorL"; // 10% 左傳輸帶
      else type = "conveyorR";              // 10% 右傳輸帶
    }
    
    // 生成平台位置，確保不重疊
    let x, attempts = 0;
    do {
      x = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (attempts < 20 && platforms.some(p => 
      Math.abs(p.y - (i * platformSpacing)) < 20 && // 同一高度附近
      Math.abs(p.x - x) < platformWidth + 10 // 水平重疊檢查
    ));
    
    // 為消失平台生成固定裂痕
    let cracks = undefined;
    if (type === 'vanish') {
      cracks = [];
      for (let c = 0; c < 8; c++) {
        let x1 = Math.random() * platformWidth;
        let y1 = Math.random() * platformHeight;
        let x2 = x1 + (Math.random() - 0.5) * platformWidth * 0.5;
        let y2 = y1 + (Math.random() - 0.5) * platformHeight * 0.7;
        let branch = undefined;
        if (Math.random() < 0.5) {
          let x3 = x2 + (Math.random() - 0.5) * platformWidth * 0.2;
          let y3 = y2 + (Math.random() - 0.5) * platformHeight * 0.2;
          branch = [x3, y3];
        }
        cracks.push({x1, y1, x2, y2, branch});
      }
    }
    // 彈簧平台預設 squash=false
    let squash = (type === 'jump') ? false : undefined;
    let squashAnim = (type === 'jump') ? 1 : undefined; // 1=展開, 0=壓縮
    let targetSquash = (type === 'jump') ? 1 : undefined;
    let squashLock = (type === 'jump') ? 0 : undefined;
    let squashState = (type === 'jump') ? 'idle' : undefined;
    let squashTimer = (type === 'jump') ? 0 : undefined;
    platforms.push({
      x: x,
      y: i * platformSpacing,
      width: platformWidth,
      height: platformHeight,
      type: type,
      vanishTimer: null,
      hidden: false,
      cracks, // 只給vanish
      squash,  // 只給jump
      squashAnim, // 只給jump
      targetSquash, // 只給jump
      squashLock, // 只給jump
      squashState, // 'idle', 'compressing', 'hold', 'expanding'
      squashTimer // 秒數
    });
  }

  // 讓精靈一開始站在最底下那個平台正上方
  const firstPlatform = platforms[platforms.length - 1];
  const playerCollisionWidth = Math.floor(playerWidth * 0.5); // 精靈碰撞寬度為視覺寬度的50%
  player = {
    x: firstPlatform.x + (firstPlatform.width - playerWidth) / 2,
    y: firstPlatform.y - playerHeight,
    width: playerWidth, // 視覺寬度
    height: playerHeight,
    collisionWidth: playerCollisionWidth, // 碰撞寬度
    vx: 0,
    vy: 0,
    speed: walkSpeed,
    gravity: 0.3,
    jumpForce: -6, // 減少彈跳力
    onGround: false,
    hp: 12,
    score: 0,
    fallThrough: false, // 新增穿透狀態
    hurtTimer: 0, // 受傷計時器
    isHurt: false, // 受傷狀態
    direction: "front", // "left", "right", "front"
    runAnim: 0, // 跑步動畫用
    jumpProtection: false, // 彈跳保護狀態
    jumpProtectionTimer: 0, // 彈跳保護計時器
    fallStartTime: null, // 新增：記錄開始掉落的時間，用於手部擺動補間
  };

  lastPlatformTouched = null;

  keys = {};

  // gameSpeed = 1; // 移除這一行，保留玩家調整的速度
  lastPlayerFloorY = player.y;
  platformPassedCount = 0;

  // 只保留最小值限制，移除最大值限制
  gameSpeed = Math.max(0.1, gameSpeed);

  drawHUD();
  animationFrameId = requestAnimationFrame(gameLoop);
  // 只在 bgmMuted 為 false 時才播放音樂
  sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
  sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
  sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
  sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
  sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
  bgm.muted = bgmMuted;
  if (!bgmMuted) {
    tryPlayBgm();
  } else {
    bgm.pause();
  }
  
  // 初始化設定面板顯示值
  const speedDisplay = document.getElementById('speed-display');
  if (speedDisplay) {
    gameSpeed = Math.max(0.1, gameSpeed); // 只保留最小值限制
    speedDisplay.textContent = gameSpeed.toFixed(1);
  }
  
  const walkspeedDisplay = document.getElementById('walkspeed-display');
  if (walkspeedDisplay) walkspeedDisplay.textContent = walkSpeed.toFixed(1);
  
  // 移除不存在的音效音量顯示元素初始化
  // const sfxVolumeDisplay = document.getElementById('sfx-volume-display');
  // if (sfxVolumeDisplay) sfxVolumeDisplay.textContent = '100%';
  
  // const bgmVolumeDisplay = document.getElementById('bgm-volume-display');
  // if (bgmVolumeDisplay) bgmVolumeDisplay.textContent = '50%';
}

function drawPlayer() {
  ctx.save();
  const pW = player.width;
  const pH = player.height;

  if (player.direction === "left" || player.direction === "right") {
    // === ns-tower.html 側面精靈繪製 ===
    // 動畫參數
    const animSpeed = 12;
    const animCycle = (performance.now() / 1000) * animSpeed;
    // 身體上下擺動
    const bodyYOffset = (1 - Math.cos(animCycle * 2)) * (pH * 0.03);
    // 鞋子高度
    const shoeHeight = pH * 0.08;
    // 計算基礎Y座標，讓腳底貼齊平台
    const baseY = player.y - bodyYOffset - shoeHeight/2;
    ctx.translate(player.x, baseY);
    // 左右翻轉
    if (player.direction === "left") {
      ctx.scale(-1, 1);
      ctx.translate(-pW, 0);
    }
    // 四肢動畫週期
    const backArmCycle = animCycle + Math.PI;
    const frontArmCycle = animCycle;
    const backLegCycle = animCycle;
    const frontLegCycle = animCycle + Math.PI;
    // 四肢擺動角度 - 添加掉落時的補間動畫
    let armAngle = Math.sin(frontArmCycle) * 1.4;
    let legAngle = Math.sin(backLegCycle) * 1.2;
    
    // 掉落時手臂擺動增強
    if (player.vy > 0.5 && !player.onGround) {
      // 如果剛開始掉落，記錄時間
      if (!player.fallStartTime) {
        player.fallStartTime = performance.now();
      }
      
      const fallTime = (performance.now() - player.fallStartTime) / 1000;
      const swingProgress = Math.min(1, fallTime / 0.1); // 縮短過渡時間到0.1秒
      
      // 使用固定的擺動頻率，確保速度均勻
      const fixedSwingSpeed = 35.0; // 固定擺動速度（弧度/秒）
      const swingTime = fallTime * fixedSwingSpeed; // 累積的擺動時間
      
      // 掉落時手臂擺動幅度增大
      const fallArmRange = 2.0; // 掉落時更大的擺動幅度
      const fallArmAngle = Math.sin(swingTime) * fallArmRange; // 使用固定頻率
      
      // 補間：從正常擺動到掉落擺動
      const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
      const smoothProgress = easeOutQuart(swingProgress);
      armAngle = armAngle + (fallArmAngle - armAngle) * smoothProgress;
    }
    
    // 共用的四肢屬性
    const armX = pW / 2;
    const shoulderY = pH * 0.45;
    const armWidth = pW * 0.12;
    const armHeight = pH * 0.35; // 增加手臂長度
    const handRadius = armWidth * 0.5;
    const legWidth = pW * 0.18;
    const legHeight = pH * 0.30;
    const legBaseY = pH * 0.75;
    const legBaseX = pW / 2;
    const shoeWidth = legWidth * 1.25;
    // 身體傾斜
    const angle = 0.15;
    ctx.save();
    ctx.translate(pW / 2, pH / 2);
    ctx.rotate(angle);
    ctx.translate(-pW / 2, -pH / 2);
    // --- 繪製順序: 從後到前 ---
    // 後腿
    ctx.save();
    ctx.translate(legBaseX, legBaseY);
    ctx.rotate(legAngle);
    ctx.fillStyle = '#fff'; // 白色褲子
    ctx.fillRect(-legWidth / 2, 0, legWidth, legHeight);
    ctx.fillStyle = '#6B3503';
    ctx.fillRect(-shoeWidth / 2, legHeight - shoeHeight / 2, shoeWidth, shoeHeight);
    ctx.restore();
    // 後臂
    ctx.save();
    ctx.translate(armX, shoulderY);
    ctx.rotate(armAngle);
    ctx.fillStyle = '#FFFF00'; // 黃袖子
    ctx.fillRect(-armWidth / 2, 0, armWidth, armHeight);
    ctx.fillStyle = '#D1B497';
    ctx.beginPath();
    ctx.arc(0, armHeight + handRadius * 0.5, handRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    // 身體/衣服
    ctx.fillStyle = '#FFFF00'; // 黃衣服
    ctx.fillRect(pW * 0.35, pH * 0.45, pW * 0.3, pH * 0.30);
    // 領子
    ctx.fillStyle = '#000'; // 黑色
    ctx.fillRect(pW * 0.48, pH * 0.45, pW * 0.04, pH * 0.04);
    // 腰帶
    ctx.fillStyle = '#8B4513'; // 咖啡色
    ctx.fillRect(pW * 0.35, pH * 0.72, pW * 0.3, pH * 0.05);
    // 皮帶扣
    ctx.fillStyle = '#A0522D'; // 咖啡色 (Sienna)
    const buckleW = pW * 0.08;
    const buckleH = pH * 0.05;
    ctx.fillRect(pW * 0.5 - buckleW / 2, pH * 0.72, buckleW, buckleH);
    // 前腿
    ctx.save();
    ctx.translate(legBaseX, legBaseY);
    ctx.rotate(-legAngle);
    ctx.fillStyle = '#fff'; // 白色褲子
    ctx.fillRect(-legWidth / 2, 0, legWidth, legHeight);
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(-shoeWidth / 2, legHeight - shoeHeight / 2, shoeWidth, shoeHeight);
    ctx.restore();
    // 前臂
    ctx.save();
    ctx.translate(armX, shoulderY);
    ctx.rotate(-armAngle);
    ctx.fillStyle = '#FFFF00'; // 黃袖子
    ctx.fillRect(-armWidth / 2, 0, armWidth, armHeight);
    ctx.fillStyle = '#D1B497';
    ctx.beginPath();
    ctx.arc(0, armHeight + handRadius * 0.5, handRadius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    // 頭部和臉部細節
    ctx.fillStyle = '#F2D1B3';
    ctx.beginPath();
    ctx.arc(pW / 2, pH * 0.25, pW * 0.28, 0, Math.PI * 2); // 增加頭部寬度
    ctx.fill();
    // 頭髮
    ctx.save();
    ctx.fillStyle = '#000'; // 還原為黑色
    // 左邊頭髮
    ctx.beginPath();
    ctx.arc(pW * 0.32, pH * 0.25, pW * 0.13, Math.PI * 0.5, Math.PI * 1.5, false);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    // 帽子主體 (白帽子)
    ctx.fillStyle = '#fff'; // 白帽子
    ctx.beginPath();
    ctx.arc(pW / 2, pH * 0.25, pW * 0.29, Math.PI, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();
    // ===== 紅色綁帶（改為實心矩形） =====
    ctx.fillStyle = '#d00';
    const strapHeightSide = pH * 0.06;
    const strapYSide = pH * 0.13; // 再次向上移動
    ctx.fillRect(pW * 0.21, strapYSide, pW * 0.58, strapHeightSide);
    // ===== 黃色頭燈與黑色底座（側面） =====
    ctx.save();
    const lampBaseW = pW * 0.18, lampBaseH = pH * 0.13;
    const lampBaseX = pW - lampBaseW - pW * 0.12, lampBaseY = pH * 0.06; // 再次向上移動
    // 黑色底座
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.roundRect(lampBaseX, lampBaseY, lampBaseW, lampBaseH, lampBaseH * 0.3);
    ctx.fill();
    // 黃色燈
    ctx.fillStyle = '#ffe14d';
    const lampW = lampBaseW * 0.75, lampH = lampBaseH * 0.75;
    const lampX = lampBaseX + (lampBaseW - lampW) / 2;
    const lampY = lampBaseY + (lampBaseH - lampH) / 2;
    ctx.beginPath();
    ctx.roundRect(lampX, lampY, lampW, lampH, lampH * 0.3);
    ctx.fill();
    ctx.restore();
    // 眼睛和臉頰 (最上層)
    ctx.fillStyle = '#000'; // 還原為黑色
    const eyeY = pH * 0.3;
    const eyeHeight = pH * 0.035;
    ctx.fillRect(pW * 0.60, eyeY, pW * 0.1, eyeHeight);
    // 帽沿（紅帽沿）
    ctx.restore();
    ctx.restore(); // 恢復身體傾斜
    ctx.restore(); // 恢復主畫布
    // ===== 側面也繪製血條 =====
    const maxHp = 12;
    const barW = pW;
    const barH = pH * 0.15; // 提高血條高度
    const barX = player.x;
    const barY = player.y - pH * 0.25 - barH; // 調整位置，讓血條更高
    for (let i = 0; i < maxHp; i++) {
      let color = '#ff0';
      if (player.hp === maxHp) color = '#0f0';
      else if (player.hp <= 5) color = '#f00';
      ctx.fillStyle = i < player.hp ? color : '#333';
      ctx.fillRect(barX + i * (barW / maxHp), barY, (barW / maxHp) - 1, barH);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(barX + i * (barW / maxHp), barY, (barW / maxHp) - 1, barH);
    }
    return;
  }

  // === ns-tower.html 正面靜止狀態（兩眼兩腮紅，帽沿為橢圓弧） ===
  ctx.translate(player.x, player.y - pH * 0.08); // 微調腳底貼地

  // 身體（梯形：上寬下窄）
  ctx.fillStyle = '#FFFF00'; // 黃衣服
  ctx.beginPath();
  ctx.moveTo(pW * 0.30, pH * 0.45); // 左上角
  ctx.lineTo(pW * 0.70, pH * 0.45); // 右上角
  ctx.lineTo(pW * 0.65, pH * 0.75); // 右下角
  ctx.lineTo(pW * 0.35, pH * 0.75); // 左下角
  ctx.closePath();
  ctx.fill();

  // V領
  ctx.fillStyle = '#000'; // 黑色內襯
  ctx.beginPath();
  ctx.moveTo(pW*0.5, pH*0.58); // V點
  ctx.lineTo(pW*0.4, pH*0.45);
  ctx.lineTo(pW*0.6, pH*0.45);
  ctx.closePath();
  ctx.fill();

  // 腰帶
  ctx.fillStyle = '#8B4513'; // 咖啡色
  ctx.fillRect(pW * 0.35, pH * 0.72, pW * 0.3, pH * 0.05);
  // 皮帶扣
  ctx.fillStyle = '#A0522D'; // 咖啡色 (Sienna)
  const buckleW = pW * 0.08;
  const buckleH = pH * 0.05;
  ctx.fillRect(pW * 0.5 - buckleW / 2, pH * 0.72, buckleW, buckleH);

  // 腿
  const legWidth = pW * 0.18;
  const legHeight = pH * 0.30;
  const legBaseY = pH * 0.75;
  const legBaseX = pW / 2;
  const shoeWidth = legWidth * 1.25;
  const shoeHeight = pH * 0.08;
  // 左腿
  ctx.save();
  ctx.translate(legBaseX - legWidth * 0.45, legBaseY);
  ctx.rotate(0.1);
  ctx.fillStyle = '#fff'; // 白色褲子
  ctx.fillRect(-legWidth / 2, 0, legWidth, legHeight);
  ctx.fillStyle = '#6B3503';
  ctx.fillRect(-shoeWidth / 2, legHeight - shoeHeight / 2, shoeWidth, shoeHeight);
  ctx.restore();
  // 右腿
  ctx.save();
  ctx.translate(legBaseX + legWidth * 0.45, legBaseY);
  ctx.rotate(-0.1);
  ctx.fillStyle = '#fff'; // 白色褲子
  ctx.fillRect(-legWidth / 2, 0, legWidth, legHeight);
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(-shoeWidth / 2, legHeight - shoeHeight / 2, shoeWidth, shoeHeight);
  ctx.restore();
  // 褲檔（中間部分）
  ctx.fillStyle = '#fff'; // 白色褲子
  ctx.fillRect(pW * 0.45, pH * 0.75, pW * 0.1, pH * 0.15);

  // 手臂
  const armWidth = pW * 0.12;
  const armHeight = pH * 0.28;
  const handRadius = armWidth * 0.5;
  const armX = pW / 2;
  const shoulderY = pH * 0.45;

  let leftArmAngle = 0.7;
  let rightArmAngle = -0.7;

  // 新增：掉落時手臂揮動 - 添加補間動畫
  if (player.vy > 0.5 && !player.onGround) { // 增加一個vy閾值，避免小幅下降也觸發
    // 如果剛開始掉落，記錄時間
    if (!player.fallStartTime) {
      player.fallStartTime = performance.now();
    }
    
    // 計算擺動動畫的進度（0到1之間）
    const fallTime = (performance.now() - player.fallStartTime) / 1000;
    const swingProgress = Math.min(1, fallTime / 0.1); // 縮短過渡時間到0.1秒
    
    // 使用固定的擺動頻率，確保速度均勻
    const fixedSwingSpeed = 35.0; // 固定擺動速度（弧度/秒）
    const swingTime = fallTime * fixedSwingSpeed; // 累積的擺動時間
    const baseAngle = 0.7; // 揮動的中心角度 (同靜止站姿)
    
    // 擺動幅度隨時間變化：開始時較小，逐漸增大
    const baseFlapRange = 0.5;
    const amplitudeProgress = Math.min(1, fallTime / 0.2); // 縮短幅度過渡時間到0.2秒
    const flapRange = baseFlapRange * amplitudeProgress;
    
    // 使用固定的正弦波擺動，確保頻率恆定
    const flapAngle = baseAngle + Math.sin(swingTime) * flapRange;
    
    // 使用補間函數平滑過渡
    const easeOutQuart = (t) => 1 - Math.pow(1 - t, 4); // 緩出四次方函數
    const smoothProgress = easeOutQuart(swingProgress);
    
    // 補間：從靜止角度到擺動角度
    leftArmAngle = 0.7 + (flapAngle - 0.7) * smoothProgress;
    rightArmAngle = -0.7 + (-flapAngle - (-0.7)) * smoothProgress;
  } else {
    // 當不處於掉落狀態時，重置開始掉落的時間
    player.fallStartTime = null;
  }

  // 左臂
  ctx.save();
  ctx.translate(armX - armWidth, shoulderY);
  ctx.rotate(leftArmAngle);
  ctx.fillStyle = '#FFFF00'; // 黃袖子
  ctx.fillRect(-armWidth / 2, 0, armWidth, armHeight);
  ctx.fillStyle = '#D1B497'; // 手掌膚色
  ctx.beginPath();
  ctx.arc(0, armHeight + handRadius * 0.5, handRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  // 右臂
  ctx.save();
  ctx.translate(armX + armWidth, shoulderY);
  ctx.rotate(rightArmAngle);
  ctx.fillStyle = '#FFFF00'; // 黃袖子
  ctx.fillRect(-armWidth / 2, 0, armWidth, armHeight);
  ctx.fillStyle = '#F2D1B3';
  ctx.beginPath();
  ctx.arc(0, armHeight + handRadius * 0.5, handRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // 頭部（整個拉寬）
  ctx.save();
  ctx.translate(pW / 2, pH * 0.25); // 以頭部中心為基準縮放
  ctx.scale(1.13, 1); // X軸拉寬（縮小一點）
  ctx.translate(-pW / 2, -pH * 0.25);
  // 頭部
  ctx.fillStyle = '#F2D1B3';
  ctx.beginPath();
  ctx.arc(pW / 2, pH * 0.25, pW * 0.28, 0, Math.PI * 2); // 增加頭部寬度
  ctx.fill();
  // 頭髮（正面：兩邊都有）
  ctx.save();
  ctx.fillStyle = '#000';
  // 左邊頭髮
  ctx.beginPath();
  ctx.arc(pW * 0.32, pH * 0.25, pW * 0.13, Math.PI * 0.5, Math.PI * 1.5, false);
  ctx.closePath();
  ctx.fill();
  // 右邊頭髮
  ctx.beginPath();
  ctx.arc(pW * 0.68, pH * 0.25, pW * 0.13, Math.PI * 1.5, Math.PI * 0.5, false);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
  // 帽子主體（改為完整半圓，而非月牙形）
  ctx.save();
  ctx.beginPath();
  // 外圈大半圓
  ctx.arc(pW / 2, pH * 0.25, pW * 0.29, Math.PI, Math.PI * 2, false);
  ctx.closePath();
  ctx.fillStyle = '#fff'; // 白帽子
  ctx.fill();
  ctx.restore();
  // ===== 紅色帽帶（改為實心矩形） =====
  ctx.fillStyle = '#d00';
  const strapHeightFront = pH * 0.06;
  const strapYFront = pH * 0.15; // 再次向上移動
  const strapWidthFront = pW * 0.58;
  ctx.fillRect(pW / 2 - strapWidthFront / 2, strapYFront, strapWidthFront, strapHeightFront);
  // ===== 黃色頭燈與黑色底座 =====
  ctx.save();
  const lampBaseW_front = pW * 0.20, lampBaseH_front = pH * 0.13;
  const lampBaseX_front = pW / 2 - lampBaseW_front / 2, lampBaseY_front = pH * 0.11; // 再次向上移動
  // 黑色底座
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.roundRect(lampBaseX_front, lampBaseY_front, lampBaseW_front, lampBaseH_front, lampBaseH_front * 0.3);
  ctx.fill();
  // 黃色燈
  ctx.fillStyle = '#ffe14d';
  const lampW_front = lampBaseW_front * 0.7, lampH_front = lampBaseH_front * 0.7;
  const lampX_front = lampBaseX_front + (lampBaseW_front - lampW_front) / 2;
  const lampY_front = lampBaseY_front + (lampBaseH_front - lampH_front) / 2;
  ctx.beginPath();
  ctx.roundRect(lampX_front, lampY_front, lampW_front, lampH_front, lampH_front * 0.3);
  ctx.fill();
  ctx.restore();
  // 兩眼（正面：對稱）
  ctx.fillStyle = '#000';
  const eyeY = pH * 0.29;
  const eyeHeight = pH * 0.035;
  ctx.fillRect(pW * 0.36, eyeY, pW * 0.09, eyeHeight); // 調整眼睛位置和大小
  ctx.fillRect(pW * 0.55, eyeY, pW * 0.09, eyeHeight); // 調整眼睛位置和大小
  // ===== 新增鼻子（小圓點） =====
  ctx.fillStyle = '#E0B07A';
  ctx.beginPath();
  ctx.arc(pW * 0.5, pH * 0.34, pW * 0.025, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore(); // 還原頭部縮放
  ctx.restore();

  // ===== 在頭頂上方繪製血條 =====
  const maxHp = 12;
  const barW = pW;
  const barH = pH * 0.15; // 提高血條高度
  const barX = player.x;
  const barY = player.y - pH * 0.25 - barH; // 調整位置，讓血條更高
  for (let i = 0; i < maxHp; i++) {
    let color = '#ff0';
    if (player.hp === maxHp) color = '#0f0';
    else if (player.hp <= 5) color = '#f00';
    ctx.fillStyle = i < player.hp ? color : '#333';
    ctx.fillRect(barX + i * (barW / maxHp), barY, (barW / maxHp) - 1, barH);
    ctx.strokeStyle = '#222';
    ctx.strokeRect(barX + i * (barW / maxHp), barY, (barW / maxHp) - 1, barH);
  }
}

function drawTopSpikes() {
  ctx.fillStyle = "#cccccc"; // 灰色
  for (let i = 0; i < getWidth(); i += 10) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i + 5, 12);
    ctx.lineTo(i + 10, 0);
    ctx.closePath();
    ctx.fill();
  }
}

function drawPlatforms() {
  const conveyorAnimOffset = (performance.now() / 80) % 12; // 用於傳送帶動畫
  animateSpringPlatforms();
  for (let idx = 0; idx < platforms.length; idx++) {
    let p = platforms[idx];
    if (p.hidden) continue;
    if (p.type === "normal") {
      // 藍色平台
      ctx.fillStyle = "#3399ff";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#001a44";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
    } else if (p.type === "jump") {
      // 彈簧平台：黑底，兩側亮綠色邊框，四根彈簧（最左往左移動，最右往右移動，中間兩根平均）
      const normalHeight = p.height;
      const maxHeight = normalHeight * 2;
      const squashAnim = (typeof p.squashAnim === 'number') ? p.squashAnim : 1;
      const currentHeight = normalHeight + (maxHeight - normalHeight) * (1 - squashAnim);
      const yOffset = p.y + normalHeight - currentHeight;

      // 1. 黑色主體
      ctx.fillStyle = "#000";
      ctx.fillRect(p.x, yOffset, p.width, currentHeight);

      // 2. 上下亮綠色邊
      const borderWidth = Math.max(3, currentHeight * 0.18);
      ctx.fillStyle = "#39FF14";
      ctx.fillRect(p.x, yOffset, p.width, borderWidth); // 上
      ctx.fillRect(p.x, yOffset + currentHeight - borderWidth, p.width, borderWidth); // 下

      // 3. 四根彈簧
      ctx.save();
      ctx.beginPath();
      ctx.rect(p.x, yOffset, p.width, currentHeight);
      ctx.clip();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = Math.max(2, currentHeight * 0.13);
      const springCount = 4;
      // 計算等寬間距：將平台寬度分成5等份，彈簧在第1、2、3、4份的中心
      const springSpacing = p.width / 5;
      const springH = currentHeight - borderWidth * 2;
      const springW = springSpacing * 0.8; // 彈簧寬度為間距的80%
      const springY = yOffset + borderWidth;
      
      // 計算彈簧的X位置，確保四根彈簧之間的間距完全等寬
      // 從左到右：1.0, 2.0, 3.0, 4.0 倍間距，這樣間距都是1.0倍
      const springPositions = [
        p.x + springSpacing * 1.0, // 最左彈簧
        p.x + springSpacing * 2.0, // 第二根
        p.x + springSpacing * 3.0, // 第三根
        p.x + springSpacing * 4.0  // 最右彈簧
      ];
      
      for (let s = 0; s < springCount; s++) {
        const centerX = springPositions[s];
        ctx.beginPath();
        for (let t = 0; t <= 1; t += 0.05) {
          const wave = Math.sin(t * Math.PI * 4) * (springW / 2.5);
          const x = centerX + wave;
          const y = springY + t * springH;
          if (t === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      ctx.restore();
      ctx.lineWidth = 1;
    } else if (p.type === "spike") {
      // 尖刺平台：先繪製平台本身，再繪製尖刺
      ctx.fillStyle = "#cccccc"; // 灰色平台
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#999999";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // 在平台上方繪製尖刺 - 修正：根據平台寬度動態調整刺的數量和間距
      ctx.fillStyle = "#cccccc"; // 與頂部尖刺相同的顏色
      const spikeWidth = 10; // 每個刺的寬度
      const spikeSpacing = spikeWidth; // 刺之間的間距
      const totalSpikes = Math.floor(p.width / spikeSpacing); // 計算能放幾個刺
      const startX = p.x + (p.width - totalSpikes * spikeSpacing) / 2; // 居中對齊
      
      for (let i = 0; i < totalSpikes; i++) {
        const spikeX = startX + i * spikeSpacing;
        ctx.beginPath();
        ctx.moveTo(spikeX, p.y);
        ctx.lineTo(spikeX + spikeWidth / 2, p.y - 12); // 將尖刺繪製在平台上方，高度12
        ctx.lineTo(spikeX + spikeWidth, p.y);
        ctx.closePath();
        ctx.fill();
      }
    } else if (p.type === "vanish") {
      // 消失平台：淺灰色
      ctx.fillStyle = "#eeeeee";
      ctx.fillRect(p.x, p.y, p.width, p.height);
      ctx.strokeStyle = "#bbbbbb";
      ctx.strokeRect(p.x, p.y, p.width, p.height);
      // 繪製固定深灰色裂痕，並裁切在平台內
      ctx.save();
      ctx.beginPath();
      ctx.rect(p.x, p.y, p.width, p.height);
      ctx.clip();
      ctx.strokeStyle = "#999999";
      ctx.lineWidth = 1;
      for (const crack of FIXED_CRACKS) {
        ctx.beginPath();
        for (let i = 0; i < crack.points.length; i++) {
          const px = p.x + crack.points[i][0] * p.width;
          const py = p.y + crack.points[i][1] * p.height;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.restore();
    } else if (p.type === "conveyorL" || p.type === "conveyorR") {
      // 傳輸帶平台：改為繪製兩端為圓形的形狀
      const r = p.height / 2;
      ctx.beginPath();
      ctx.moveTo(p.x + r, p.y);
      ctx.lineTo(p.x + p.width - r, p.y);
      ctx.arc(p.x + p.width - r, p.y + r, r, -Math.PI / 2, Math.PI / 2, false);
      ctx.lineTo(p.x + r, p.y + p.height);
      ctx.arc(p.x + r, p.y + r, r, Math.PI / 2, -Math.PI / 2, false);
      ctx.closePath();
      
      ctx.fillStyle = "#bbbbbb";
      ctx.fill();
      ctx.strokeStyle = "#888888";
      ctx.stroke();

      // 畫會移動的深色橫條
      ctx.save();
      ctx.beginPath();
      ctx.rect(p.x, p.y, p.width, p.height);
      ctx.clip();
      ctx.strokeStyle = "#666";
      const animOffset = (p.type === "conveyorL") ? -conveyorAnimOffset : conveyorAnimOffset;
      // 擴大迴圈範圍，確保線條平滑移入移出
      for (let i = -12; i < p.width + 12; i += 12) {
        ctx.beginPath();
        ctx.moveTo(p.x + i + animOffset, p.y + 2);
        ctx.lineTo(p.x + i + animOffset, p.y + p.height - 2);
        ctx.stroke();
      }
      ctx.restore();
      // 畫三個黃色箭頭
      ctx.strokeStyle = "#ff0";
      ctx.lineWidth = 4;
      ctx.beginPath();
      let arrowY = p.y + p.height / 2;
      // 計算三個箭頭的位置，均勻分布在平台上
      const arrowSpacing = p.width / 4; // 將平台寬度分成4份，箭頭在第1、2、3份的中心
      if (p.type === "conveyorL") {
        // 左傳送帶：箭頭指向左邊
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX + 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX + 6, arrowY + 4);
        }
      } else {
        // 右傳送帶：箭頭指向右邊
        for (let i = 1; i <= 3; i++) {
          const arrowX = p.x + (arrowSpacing * i);
          ctx.moveTo(arrowX - 6, arrowY - 4);
          ctx.lineTo(arrowX, arrowY);
          ctx.lineTo(arrowX - 6, arrowY + 4);
        }
      }
      ctx.stroke();
      ctx.lineWidth = 1;
    }
  }
}

function drawHUD() {
  if (!player) return;
  const maxHp = 12;
  let hpHtml = '';
  for (let i = 0; i < maxHp; i++) {
    if (i < player.hp) {
      if (player.hp <= 5) {
        hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:red;border:1px solid #c00;margin-right:2px;"></span>';
      } else {
        hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:yellow;border:1px solid #cc0;margin-right:2px;"></span>';
      }
    } else {
      hpHtml += '<span style="display:inline-block;width:2px;height:16px;background:#333;border:1px solid #222;margin-right:2px;"></span>';
    }
  }
  // 只更新血量條內容
  const hudHp = document.querySelector('#hud .hud-hp');
  if (hudHp) hudHp.innerHTML = hpHtml;
  // 只更新分數與最高分
  const hudHighscore = document.getElementById('hud-highscore');
  if (hudHighscore) hudHighscore.textContent = '最高: ' + highScore;
  const hudScore = document.getElementById('hud-score');
  if (hudScore) hudScore.textContent = '地下' + String(player.score).padStart(4, "0") + '階';
  // 只更新音效/音樂按鈕文字
  const sfxToggle = document.getElementById('sfx-toggle');
  const bgmToggle = document.getElementById('bgm-toggle');
  if (sfxToggle) sfxToggle.textContent = (sfxMuted ? '🔇' : '🔊') + ' 音效';
  if (bgmToggle) bgmToggle.textContent = (bgmMuted ? '🔇' : '🎵') + ' 音樂';
  
  // 更新底部控制按鈕文字
  const pauseToggle = document.getElementById('pause-toggle');
  if (pauseToggle) pauseToggle.textContent = (paused ? '⏸️ 暫停' : '▶️ 繼續');
}

function updatePlayer() {
  // 即時更新行走速度
  player.speed = walkSpeed;
  
  // 使用固定時間步長更新物理
  const deltaTime = FIXED_TIMESTEP * 60; // 轉換為60FPS基準
  
  player.vy += player.gravity * deltaTime;
  let prevY = player.y;
  let nextY = player.y + player.vy * deltaTime;
  player.y = nextY;

  // 處理彈跳保護機制
  if (player.jumpProtection && player.jumpProtectionTimer > 0) {
    player.jumpProtectionTimer--;
    if (player.jumpProtectionTimer <= 0) {
      player.jumpProtection = false;
    }
  }

  // 頂端尖刺碰撞 - 精靈帽子頂端碰到尖刺就受傷
  const hatTopY = player.y; // 帽子頂端位置（精靈的y座標就是帽子頂端）
  if (hatTopY <= 12) { // 尖刺高度是12像素
    if (lastPlatformTouched !== 'topSpike') {
      playSfxPool('spike'); // 播放被刺到音效
      player.hp -= 5;
      lastPlatformTouched = 'topSpike';
      createBloodSplatter(player.x + player.width / 2, player.y, 60); // 從頭頂噴血
      player.isHurt = true;
      player.hurtTimer = 1000;
      // 將正下方平台設為 hidden
      platforms.forEach(p => {
        const playerCenterX = player.x + player.width / 2;
        const playerCollisionLeft = playerCenterX - player.collisionWidth / 2;
        const playerCollisionRight = playerCenterX + player.collisionWidth / 2;
        const overlap =
          playerCollisionRight > p.x &&
          playerCollisionLeft < p.x + p.width &&
          player.y + player.height <= p.y + p.height &&
          player.y + player.height >= p.y;
        if (overlap && (p.type === 'normal' || p.type === 'spike' || p.type === 'conveyorL' || p.type === 'conveyorR')) {
          p.hidden = true;
        }
      });
    }
    player.y = 12; // 將精靈帽子頂端停在尖刺下方
    player.vy = 0;
    player.fallThrough = true; // 開啟穿透狀態
  } else if (lastPlatformTouched === 'topSpike') {
    lastPlatformTouched = null;
    player.fallThrough = false; // 離開頂端，恢復正常
  }

  if (keys["ArrowLeft"]) player.vx = -player.speed;
  else if (keys["ArrowRight"]) player.vx = player.speed;
  else player.vx = 0;

  player.x += player.vx * deltaTime;
  
  // 計算精靈碰撞區域的中心點
  const playerCenterX = player.x + player.width / 2;
  const playerCollisionLeft = playerCenterX - player.collisionWidth / 2;
  const playerCollisionRight = playerCenterX + player.collisionWidth / 2;
  
  if (playerCollisionLeft < 0) player.x = player.collisionWidth / 2 - player.width / 2;
  if (playerCollisionRight > getWidth()) player.x = getWidth() - player.collisionWidth / 2 - player.width / 2;

  player.onGround = false;
  // 若在穿透狀態，跳過平台碰撞
  if (!player.fallThrough) {
    let landed = false;
    let landedPlatform = null;
    let minLandingY = Infinity;
    // 只在下落時做連續碰撞偵測
    if (player.vy > 0) {
      for (let p of platforms) {
        if (p.hidden) continue;
        // 彈簧平台壓縮判斷
        if (p.type === 'jump') p.targetSquash = 1;
        // 檢查水平重疊
        const horizontalOverlap = playerCollisionRight > p.x && playerCollisionLeft < p.x + p.width;
        if (!horizontalOverlap) continue;
        // 計算平台碰撞區間
        const prevBottom = prevY + player.height;
        const nextBottom = nextY + player.height;
        // 只要人物鞋底從平台上方進入平台碰撞區間就觸發落地
        if (
          prevBottom <= p.y + p.height &&
          nextBottom >= p.y &&
          prevBottom <= nextBottom // 確保是下落
        ) {
          if (p.y < minLandingY) {
            minLandingY = p.y;
            landedPlatform = p;
            landed = true;
          }
        }
      }
      if (landed && landedPlatform) {
        player.y = minLandingY - player.height;
        player.vy = 0;
        player.onGround = true;
      }
    } else {
      // 非下落時，維持原本的碰撞檢查（如彈跳保護等）
      for (let p of platforms) {
        if (p.hidden) continue;
        if (p.type === 'jump') p.targetSquash = 1;
        const horizontalOverlap = playerCollisionRight > p.x && playerCollisionLeft < p.x + p.width;
        if (horizontalOverlap) {
          const currentInPlatform = player.y + player.height >= p.y && player.y + player.height <= p.y + p.height;
          if (currentInPlatform) {
            if (!landed) {
              player.y = p.y - player.height;
              player.vy = 0;
              player.onGround = true;
              landed = true;
              landedPlatform = p;
            }
          }
        }
      }
    }
    // 處理平台效果
    if (landed && landedPlatform) {
      let p = landedPlatform;
      if (p.type === "spike") {
        if (lastPlatformTouched !== p) {
          playSfxPool('spike');
          player.hp -= 5;
          lastPlatformTouched = p;
          createBloodSplatter(player.x + player.width / 2, player.y + player.height, 60);
          player.isHurt = true;
          player.hurtTimer = 1000;
        }
      } else if (p.type === "jump") {
        const timeSinceLastJump = p.lastJumpTime ? Date.now() - p.lastJumpTime : 1000;
        if (timeSinceLastJump > 100) {
          playSfxPool('jump');
          p.targetSquash = 0;
          p.squashLock = 0.2;
          const platformSpacing = getPlatformSpacing();
          const g = player.gravity;
          const baseJumpMultiplier = 0.9;
          const speedAdjustment = Math.min(1.5, gameSpeed);
          const adjustedMultiplier = baseJumpMultiplier * speedAdjustment;
          const jumpHeight = player.height * 1.5;
          const maxVy = -Math.sqrt(2 * g * jumpHeight * adjustedMultiplier);
          player.vy = maxVy;
          player.hp = Math.min(player.hp + 1, 12);
          lastPlatformTouched = p;
          p.lastJumpTime = Date.now();
          player.jumpProtection = true;
          player.jumpProtectionTimer = 10;
          player.onGround = false;
        }
      } else if (p.type === "normal") {
        if (lastPlatformTouched !== p) {
          playSfxPool('normal');
          player.hp = Math.min(player.hp + 1, 12);
          lastPlatformTouched = p;
        }
      } else if (p.type === "vanish") {
        if (p.vanishTimer === null) {
          playSfxPool('normal');
          p.vanishTimer = Date.now();
          player.hp = Math.min(player.hp + 1, 12);
        } else if (Date.now() - p.vanishTimer >= 200) {
          p.hidden = true;
          createDebris(p.x, p.y, p.width, p.height, 80);
          playSfxPool('vanish');
        }
        lastPlatformTouched = p;
      } else if (p.type === "conveyorL" || p.type === "conveyorR") {
        if (p.type === "conveyorL") {
          player.x -= 1.5 * deltaTime;
        } else {
          player.x += 1.5 * deltaTime;
        }
        if (lastPlatformTouched !== p) {
          playSfxPool('normal');
          player.hp = Math.min(player.hp + 1, 12);
          lastPlatformTouched = p;
        }
      }
    } else {
      // 離開平台時重設 vanishTimer
      for (let p of platforms) {
        if (p.type === "vanish") {
          p.vanishTimer = null;
        }
      }
    }
  }

  if (player.y > getHeight() || (player.hp <= 0 && !player.fallThrough)) {
    setTimeout(() => {
      playSfxPool('dead');
      if (player.score > highScore) {
        highScore = player.score;
        localStorage.setItem('ns_shaft_highscore', highScore);
      }
      showGameOverModal(player.score, player.score >= highScore);
    }, 100);
    return false;
  }

  if (player.vx < 0) player.direction = "left";
  else if (player.vx > 0) player.direction = "right";
  else player.direction = "front";

  if (player.vx !== 0) {
    player.runAnim += Math.abs(player.vx) * 0.28 * deltaTime;
  } else {
    player.runAnim = 0;
  }

  return true;
}

function updatePlatforms() {
  // 平台速度隨分數增加而變快，並應用遊戲速度設定
  const baseSpeed = 1.5;
  // 修改：每階速度乘以1.01倍（指數增長）
  let platformSpeed = baseSpeed * Math.pow(1.01, player.score) * gameSpeed;
  
  // 使用固定時間步長
  const deltaTime = FIXED_TIMESTEP * 60; // 轉換為60FPS基準
  platformSpeed *= deltaTime;
  
  // 移除總體速度限制，允許無限制的速度
  // const maxTotalSpeed = 8.0; // 最大總體速度限制
  // platformSpeed = Math.min(platformSpeed, maxTotalSpeed);
  
  for (let p of platforms) {
    p.y -= platformSpeed;
  }
  
  // 處理消失與重生
  for (let i = 0; i < platforms.length; i++) {
    let p = platforms[i];
    if (p.y + p.height < 0) {
      // 只要平台（不論 hidden 與否）離開畫面頂端就計數
      platformPassedCount++;
      if (platformPassedCount % 5 === 0) {
        player.score++;
      }
      // 平台重生
      const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
      const platformHeight = 12; // 增加厚度
      const playerWidth = Math.floor(platformWidth / 2);
      const playerHeight = playerWidth;
      const platformSpacing = getPlatformSpacing(); // 使用統一函數
      // 找到最下方的平台，在其下方固定間距處生成新平台
      let lowestPlatform = null;
      for (let otherP of platforms) {
        if (otherP !== p && (lowestPlatform === null || otherP.y > lowestPlatform.y)) {
          lowestPlatform = otherP;
        }
      }
      let newY, newX;
      if (lowestPlatform) {
        newY = lowestPlatform.y + platformSpacing;
      } else {
        newY = getHeight();
      }
      let tryCount = 0;
      do {
        newX = Math.random() * (getWidth() - platformWidth);
        tryCount++;
      } while (
        tryCount < 20 &&
        (() => {
          const playerCenterX = player.x + player.width / 2;
          const playerCollisionLeft = playerCenterX - player.collisionWidth / 2;
          const playerCollisionRight = playerCenterX + player.collisionWidth / 2;
          return playerCollisionRight > newX &&
                 playerCollisionLeft < newX + platformWidth &&
                 player.y + player.height <= newY + platformHeight &&
                 player.y + player.height >= newY;
        })()
      );
      p.y = newY;
      p.x = newX;
      // 使用新的平台類型選擇邏輯
      p.type = selectPlatformType();
      p.vanishTimer = null;
      p.hidden = false;
      // 為消失平台生成固定裂痕
      if (p.type === 'vanish') {
        p.cracks = [];
        for (let c = 0; c < 8; c++) {
          let x1 = Math.random() * platformWidth;
          let y1 = Math.random() * platformHeight;
          let x2 = x1 + (Math.random() - 0.5) * platformWidth * 0.5;
          let y2 = y1 + (Math.random() - 0.5) * platformHeight * 0.7;
          let branch = undefined;
          if (Math.random() < 0.5) {
            let x3 = x2 + (Math.random() - 0.5) * platformWidth * 0.2;
            let y3 = y2 + (Math.random() - 0.5) * platformHeight * 0.2;
            branch = [x3, y3];
          }
          p.cracks.push({x1, y1, x2, y2, branch});
        }
      } else {
        p.cracks = undefined;
      }
      // 彈簧平台預設 squash=false
      if (p.type === 'jump') {
        p.squash = false;
        p.squashAnim = 1;
        p.targetSquash = 1;
        p.squashLock = 0;
      } else {
        p.squash = undefined;
        p.squashAnim = undefined;
        p.targetSquash = undefined;
        p.squashLock = undefined;
      }
    }
  }
  
  // 檢查平台數量，如果少於8個就補充
  const platformWidth = Math.floor(getWidth() * 0.25); // 平台寬度為總寬度的25%
  const platformHeight = 12; // 增加厚度
  const playerWidth = Math.floor(platformWidth / 2);
  const playerHeight = playerWidth;
  const platformSpacing = getPlatformSpacing(); // 平台間距 = 精靈身高 * 2
  const targetPlatformCount = Math.ceil(getHeight() / platformSpacing);
  while (platforms.length < targetPlatformCount) {
    // 找到最下方的平台，在其下方固定間距處生成新平台
    let lowestPlatform = null;
    for (let p of platforms) {
      if (lowestPlatform === null || p.y > lowestPlatform.y) {
        lowestPlatform = p;
      }
    }
    
    let newY, newX;
    if (lowestPlatform) {
      // 在最下方平台下方固定間距處生成
      newY = lowestPlatform.y + platformSpacing;
    } else {
      // 如果沒有其他平台，在畫面底部生成
      newY = getHeight();
    }
    
    // 生成X位置，避免與玩家重疊
    let attempts = 0;
    do {
      newX = Math.random() * (getWidth() - platformWidth);
      attempts++;
    } while (
      attempts < 20 &&
      (() => {
        const playerCenterX = player.x + player.width / 2;
        const playerCollisionLeft = playerCenterX - player.collisionWidth / 2;
        const playerCollisionRight = playerCenterX + player.collisionWidth / 2;
        return playerCollisionRight > newX &&
               playerCollisionLeft < newX + platformWidth &&
               player.y + player.height <= newY + platformHeight &&
               player.y + player.height >= newY;
      })()
    );
    
    // 生成新平台
    let newPlatform = {
      x: newX,
      y: newY,
      width: platformWidth,
      height: platformHeight,
      type: selectPlatformType(), // 使用新的平台類型選擇邏輯
      vanishTimer: null,
      hidden: false
    };
    platforms.push(newPlatform);
  }
}

function togglePause() {
  paused = !paused;
  if (paused) {
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
  } else {
    // 恢復時重設 lastTime，避免補算暫停期間的遊戲邏輯
    lastTime = 0;
    animationFrameId = requestAnimationFrame(gameLoop);
  }
  // 更新 HUD 顯示
  drawHUD();
}

function gameLoop(currentTime) {
  if (paused) return;
  
  // 固定時間步長系統
  if (lastTime === 0) {
    lastTime = currentTime;
  }
  
  const deltaTime = (currentTime - lastTime) / 1000; // 轉換為秒
  lastTime = currentTime;
  
  // 累積時間
  accumulator += deltaTime;
  
  // 執行固定時間步長的更新
  while (accumulator >= FIXED_TIMESTEP) {
    updatePlatforms();
    // 物理更新
    if (!updatePlayer()) return;
    updateBloodParticles();
    updateDebrisParticles();
    animateSpringPlatforms();
    
    accumulator -= FIXED_TIMESTEP;
  }
  
  // 渲染（不受時間步長影響）
  ctx.clearRect(0, 0, getWidth(), getHeight());
  // 畫深藍色漸層背景（更接近原作）
  let grad = ctx.createLinearGradient(0, 0, 0, getHeight());
  grad.addColorStop(0, "#001a33");
  grad.addColorStop(1, "#003366");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, getWidth(), getHeight());
  drawTopSpikes(); // 畫頂端尖刺
  
  drawBloodParticles();
  drawDebrisParticles();
  drawPlatforms();
  drawPlayer();
  drawHUD();
  // 加上遊戲區域邊框
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 4;
  ctx.strokeRect(0, 0, getWidth(), getHeight());
  ctx.lineWidth = 1;
  
  if (player.isHurt && player.hurtTimer > 0) {
    player.hurtTimer -= 16; // 約等於一幀16ms
    if (player.hurtTimer <= 0) {
      player.isHurt = false;
      player.hurtTimer = 0;
    }
  }
  
  // 只有沒暫停時才繼續排程下一幀
  if (!paused) {
    animationFrameId = requestAnimationFrame(gameLoop);
  }
}

// 觸控操作
function setKey(key, val) {
  keys[key] = val;
}

function handleTouch(e) {
  let left = false, right = false;
  const half = window.innerWidth / 2;
  for (let i = 0; i < e.touches.length; i++) {
    const x = e.touches[i].clientX;
    if (x < half) left = true;
    if (x >= half) right = true;
  }
  setKey('ArrowLeft', left);
  setKey('ArrowRight', right);
}

window.addEventListener('touchstart', handleTouch);
window.addEventListener('touchmove', handleTouch);
window.addEventListener('touchend', function(e) {
  setKey('ArrowLeft', false);
  setKey('ArrowRight', false);
});
window.addEventListener('touchcancel', function(e) {
  setKey('ArrowLeft', false);
  setKey('ArrowRight', false);
});

// 遊戲結束自訂彈窗
function showGameOverModal(score, isNewRecord) {
  const modal = document.getElementById('gameover-modal');
  const msg = document.getElementById('gameover-msg');
  msg.innerHTML = `遊戲結束！<br>樓層: <b style="color:yellow;">${score}</b>${isNewRecord ? '<br><span style="color:#0f0;">新紀錄！</span>' : ''}`;
  modal.style.display = 'flex';
}

document.getElementById('restart-btn').addEventListener('click', () => {
  document.getElementById('gameover-modal').style.display = 'none';
  initGame();
});

// 修改window.keydown事件
window.addEventListener('keydown', function(e) {
  const modal = document.getElementById('gameover-modal');
  if (modal.style.display === 'flex' && (e.key === 'Enter' || e.keyCode === 13)) {
    modal.style.display = 'none';
    initGame();
    e.preventDefault(); // 防止Enter觸發其他按鈕
    return;
  }
  if (e.key === 'p' || e.key === 'P') {
    togglePause();
  }
});

window.addEventListener('DOMContentLoaded', function() {
  // 只掛一次事件監聽器
  document.addEventListener("keydown", e => keys[e.key] = true);
  document.addEventListener("keyup", e => keys[e.key] = false);
  const sfxToggle = document.getElementById('sfx-toggle');
  const bgmToggle = document.getElementById('bgm-toggle');
  // 強制移除聚焦
  if (sfxToggle) sfxToggle.blur();
  if (bgmToggle) bgmToggle.blur();
  // 阻止聚焦
  [sfxToggle, bgmToggle].forEach(btn => {
    if (btn) {
      btn.addEventListener('mousedown', e => { btn.blur(); });
      btn.addEventListener('mouseup', e => { btn.blur(); });
      btn.addEventListener('click', e => { btn.blur(); });
      btn.addEventListener('keydown', e => { btn.blur(); if (e.key === 'Enter' || e.keyCode === 13) e.preventDefault(); });
    }
  });
  if (sfxToggle) {
    sfxToggle.addEventListener('click', function() {
      sfxMuted = !sfxMuted;
      sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
      sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
      sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
      sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
      sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
      drawHUD();
    });
  }
  if (bgmToggle) {
    bgmToggle.addEventListener('click', function() {
      bgmMuted = !bgmMuted;
      bgm.muted = bgmMuted;
      if (bgmMuted) {
        bgm.pause();
      } else {
        try { bgm.play(); } catch (e) {}
      }
      drawHUD();
    });
  }
  
  // 新增底部控制按鈕事件處理
  const pauseToggle = document.getElementById('pause-toggle');
  const settingsToggle = document.getElementById('settings-toggle');
  const helpToggle = document.getElementById('help-toggle');
  const aboutToggle = document.getElementById('about-toggle');
  
  // 暫停按鈕
  if (pauseToggle) {
    pauseToggle.addEventListener('click', function() {
      togglePause();
    });
  }
  
  // 設定按鈕
  if (settingsToggle) {
    settingsToggle.addEventListener('click', function() {
      document.getElementById('settings-modal').style.display = 'flex';
    });
  }
  
  // 說明按鈕
  if (helpToggle) {
    helpToggle.addEventListener('click', function() {
      document.getElementById('help-modal').style.display = 'flex';
    });
  }
  
  // 關於按鈕
  if (aboutToggle) {
    aboutToggle.addEventListener('click', function() {
      document.getElementById('about-modal').style.display = 'flex';
    });
  }
  
  // 關閉按鈕事件
  document.getElementById('help-close-btn').addEventListener('click', function() {
    document.getElementById('help-modal').style.display = 'none';
  });
  
  document.getElementById('settings-close-btn').addEventListener('click', function() {
    document.getElementById('settings-modal').style.display = 'none';
  });
  
  document.getElementById('about-close-btn').addEventListener('click', function() {
    document.getElementById('about-modal').style.display = 'none';
  });
  
  // 設定面板中的控制按鈕
  document.getElementById('speed-decrease').addEventListener('click', function() {
    gameSpeed = Math.max(0.1, gameSpeed - 0.1); // 只保留最小值限制，移除最大值限制
    document.getElementById('speed-display').textContent = gameSpeed.toFixed(1);
  });
  
  document.getElementById('speed-increase').addEventListener('click', function() {
    gameSpeed = gameSpeed + 0.1; // 移除最大值限制
    document.getElementById('speed-display').textContent = gameSpeed.toFixed(1);
  });
  
  // 移除不存在的音效音量控制按鈕事件監聽器
  // 這些按鈕在HTML中不存在，會導致錯誤
  
  // 點擊彈窗背景關閉
  [document.getElementById('help-modal'), document.getElementById('settings-modal'), document.getElementById('about-modal')].forEach(modal => {
    if (modal) {
      modal.addEventListener('click', function(e) {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });
    }
  });
  
  drawHUD(); // 初始化顯示
  
  // === 行走速度控制修正 ===
  // 行走速度控制
  try {
    const walkspeedDecreaseBtn = document.getElementById('walkspeed-decrease');
    const walkspeedIncreaseBtn = document.getElementById('walkspeed-increase');
    
    if (walkspeedDecreaseBtn) {
      walkspeedDecreaseBtn.addEventListener('click', function() {
        walkSpeed = Math.max(1.0, walkSpeed - 0.1);
        const display = document.getElementById('walkspeed-display');
        if (display) display.textContent = walkSpeed.toFixed(1);
        if (player) player.speed = walkSpeed;
      });
    }
    
    if (walkspeedIncreaseBtn) {
      walkspeedIncreaseBtn.addEventListener('click', function() {
        walkSpeed = Math.min(10.0, walkSpeed + 0.1);
        const display = document.getElementById('walkspeed-display');
        if (display) display.textContent = walkSpeed.toFixed(1);
        if (player) player.speed = walkSpeed;
      });
    }
  } catch (error) {
    console.log('行走速度控制初始化失敗:', error);
  }
});

// 更新音效音量的輔助函數
// function updateSfxVolume() {
//   sfxPools.normal.forEach(audio => audio.volume = sfxVolume);
//   sfxPools.jump.forEach(audio => audio.volume = sfxVolume);
//   sfxPools.spike.forEach(audio => audio.volume = sfxVolume);
//   sfxPools.vanish.forEach(audio => audio.volume = sfxVolume);
//   sfxPools.dead.forEach(audio => audio.volume = sfxVolume);
// }

function handleFirstInteraction() {
  if (!firstInteraction) {
    firstInteraction = true;
    // 不要強制改變靜音狀態，只同步 audio 標籤
    sfxPools.normal.forEach(audio => audio.muted = sfxMuted);
    sfxPools.jump.forEach(audio => audio.muted = sfxMuted);
    sfxPools.spike.forEach(audio => audio.muted = sfxMuted);
    sfxPools.vanish.forEach(audio => audio.muted = sfxMuted);
    sfxPools.dead.forEach(audio => audio.muted = sfxMuted);
    bgm.muted = bgmMuted;
    tryPlayBgm();
  }
}
window.addEventListener('click', handleFirstInteraction, { once: true });
window.addEventListener('touchstart', handleFirstInteraction, { once: true });

// ===== 新增噴血效果相關函數 =====
function createBloodSplatter(x, y, count = 50) {
  for (let i = 0; i < count; i++) {
    // 添加一些隨機偏移，讓噴血效果更自然
    const offsetX = (Math.random() - 0.5) * 20;
    const offsetY = (Math.random() - 0.5) * 10;
    
    bloodParticles.push({
      x: x + offsetX,
      y: y + offsetY,
      vx: (Math.random() - 0.5) * 12,
      vy: (Math.random() - 0.5) * 15 - 8,
      size: Math.random() * 4 + 2,
      lifespan: Math.random() * 120 + 80,
      gravity: 0.2,
      // 添加一些隨機的顏色變化
      colorVariation: Math.random() * 0.3 - 0.15
    });
  }
}

function updateBloodParticles() {
  const deltaTime = FIXED_TIMESTEP * 60; // 轉換為60FPS基準
  for (let i = bloodParticles.length - 1; i >= 0; i--) {
    let p = bloodParticles[i];
    p.vy += p.gravity * deltaTime;
    p.x += p.vx * deltaTime;
    p.y += p.vy * deltaTime;
    p.lifespan--;
    if (p.lifespan <= 0) {
      bloodParticles.splice(i, 1);
    }
  }
}

function drawBloodParticles() {
  for (const p of bloodParticles) {
    // 計算透明度（基於生命週期）
    const alpha = p.lifespan / 200; // 200是最大生命週期
    
    // 使用顏色變化
    const redVariation = Math.floor(255 + (p.colorVariation || 0) * 50);
    const greenVariation = Math.floor(50 + (p.colorVariation || 0) * 30);
    
    // 繪製陰影
    ctx.fillStyle = 'rgba(80, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.arc(p.x + 1, p.y + 1, p.size, 0, Math.PI * 2);
    ctx.fill();
    
    // 繪製主體（亮紅色，帶顏色變化）
    ctx.fillStyle = `rgba(${redVariation}, ${greenVariation}, 50, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    
    // 繪製高光
    ctx.fillStyle = `rgba(255, 150, 150, ${alpha * 0.6})`;
    ctx.beginPath();
    ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.4, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ===== 新增平台碎裂效果相關函數 =====
function createDebris(x, y, width, height, count = 50) {
  for (let i = 0; i < count; i++) {
    // 添加一些隨機偏移，讓碎裂效果更自然
    const offsetX = (Math.random() - 0.5) * width * 0.2;
    const offsetY = (Math.random() - 0.5) * height * 0.2;
    
    // 灰白色系的粉塵顏色 - 主要是白色、淺灰色、銀灰色
    const colorTypes = [
      // 純白色
      `rgb(${240 + Math.random()*15}, ${240 + Math.random()*15}, ${240 + Math.random()*15})`,
      // 淺灰色
      `rgb(${200 + Math.random()*30}, ${200 + Math.random()*30}, ${200 + Math.random()*30})`,
      // 銀灰色
      `rgb(${180 + Math.random()*20}, ${180 + Math.random()*20}, ${180 + Math.random()*20})`,
      // 中灰色
      `rgb(${150 + Math.random()*30}, ${150 + Math.random()*30}, ${150 + Math.random()*30})`,
      // 淺銀色
      `rgb(${220 + Math.random()*20}, ${220 + Math.random()*20}, ${220 + Math.random()*20})`
    ];
    const selectedColor = colorTypes[Math.floor(Math.random() * colorTypes.length)];
    
    // 隨機決定粒子類型
    const particleType = Math.random();
    const isSmoke = particleType < 0.4; // 40%煙霧
    const isDust = particleType < 0.7; // 30%粉塵
    const isFragment = particleType >= 0.7; // 30%碎片
    
    debrisParticles.push({
      x: x + Math.random() * width + offsetX,
      y: y + Math.random() * height + offsetY,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 8 - 3,
      size: Math.random() * 8 + 3,
      lifespan: Math.random() * 120 + 80,
      gravity: 0.15,
      // 粒子類型
      isSmoke: isSmoke,
      isDust: isDust,
      isFragment: isFragment,
      smokeSize: Math.random() * 12 + 8,
      // 添加旋轉效果
      rotation: Math.random() * Math.PI * 2,
      rotationSpeed: (Math.random() - 0.5) * 0.2,
      // 顏色變化
      colorVariation: Math.random() * 0.4 - 0.2,
      color: selectedColor,
      // 不規則形狀
      shape: Math.random() < 0.3 ? 'circle' : 'square',
      // 風力影響
      windEffect: Math.random() * 0.5 - 0.25
    });
  }
}

function updateDebrisParticles() {
  const deltaTime = FIXED_TIMESTEP * 60; // 轉換為60FPS基準
  for (let i = debrisParticles.length - 1; i >= 0; i--) {
    let p = debrisParticles[i];
    p.vy += p.gravity * deltaTime;
    p.x += p.vx * deltaTime;
    p.y += p.vy * deltaTime;
    
    // 添加風力效果
    if (p.windEffect !== undefined) {
      p.x += p.windEffect * deltaTime;
      p.windEffect *= 0.98; // 風力逐漸減弱
    }
    
    p.lifespan--;
    
    // 更新旋轉
    if (p.rotation !== undefined) {
      p.rotation += (p.rotationSpeed || 0) * deltaTime;
    }
    
    if (p.lifespan <= 0) {
      debrisParticles.splice(i, 1);
    }
  }
}

function drawDebrisParticles() {
  for (const p of debrisParticles) {
    // 計算透明度（基於生命週期）
    const alpha = p.lifespan / 200; // 200是最大生命週期
    
    if (p.isSmoke) {
      // 煙霧效果 - 使用灰白色系的漸變
      const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.smokeSize);
      gradient.addColorStop(0, `rgba(240, 240, 240, ${alpha * 0.7})`);
      gradient.addColorStop(0.3, `rgba(220, 220, 220, ${alpha * 0.5})`);
      gradient.addColorStop(0.7, `rgba(200, 200, 200, ${alpha * 0.3})`);
      gradient.addColorStop(1, `rgba(180, 180, 180, 0)`);
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.smokeSize, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.isDust) {
      // 粉塵效果 - 小顆粒，半透明，灰白色系
      const dustSize = p.size * 0.6;
      ctx.fillStyle = `rgba(220, 220, 220, ${alpha * 0.5})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, dustSize, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // 固體碎片 - 添加旋轉、陰影和漸變
      ctx.save();
      ctx.translate(p.x + p.size / 2, p.y + p.size / 2);
      if (p.rotation !== undefined) {
        ctx.rotate(p.rotation);
      }
      ctx.translate(-p.size / 2, -p.size / 2);
      
      // 使用顏色變化 - 確保綠色通道不會增加，避免出現綠色
      const colorVariation = p.colorVariation || 0;
      const baseColor = p.color.match(/\d+/g);
      const r = Math.min(255, Math.max(0, parseInt(baseColor[0]) + colorVariation * 20));
      const g = Math.min(255, Math.max(0, parseInt(baseColor[1]) - Math.abs(colorVariation) * 15)); // 綠色通道只能減少
      const b = Math.min(255, Math.max(0, parseInt(baseColor[2]) + colorVariation * 20));
      
      // 額外確保綠色通道不會太高
      const finalG = Math.min(g, Math.max(r, b) * 0.9); // 綠色通道不能超過紅藍通道的90%
      
      // 陰影 - 使用灰白色系的陰影
      ctx.fillStyle = `rgba(120, 120, 120, ${alpha * 0.4})`;
      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.size/2 + 1, p.size/2 + 1, p.size/2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(1, 1, p.size, p.size);
      }
      
      // 主體
      ctx.fillStyle = `rgba(${r}, ${finalG}, ${b}, ${alpha})`;
      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.size/2, p.size/2, p.size/2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(0, 0, p.size, p.size);
      }
      
      // 高光 - 更亮的白色高光
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
      if (p.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(p.size * 0.3, p.size * 0.3, p.size * 0.2, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillRect(p.size * 0.2, p.size * 0.2, p.size * 0.3, p.size * 0.3);
      }
      
      ctx.restore();
    }
  }
}

// 固定裂痕資料（相對於平台寬高，0~1）
const FIXED_CRACKS = [
  // 主裂痕
  { points: [ [0.12,0.7], [0.28,0.4], [0.38,0.8] ] },
  { points: [ [0.7,0.2], [0.55,0.6], [0.8,0.7] ] },
  { points: [ [0.3,0.2], [0.5,0.5], [0.4,0.8] ] },
  // 分岔
  { points: [ [0.28,0.4], [0.22,0.25] ] },
  { points: [ [0.55,0.6], [0.65,0.45] ] }
];

// 彈簧平台動畫補間（每幀呼叫）
function animateSpringPlatforms() {
  const dt = FIXED_TIMESTEP; // 使用固定時間步長
  for (let p of platforms) {
    if (p.type === 'jump' && typeof p.squashAnim === 'number' && typeof p.targetSquash === 'number') {
      if (typeof p.squashLock === 'number' && p.squashLock > 0) {
        p.squashLock -= dt;
        p.targetSquash = 0; // 拉伸狀態
        if (p.squashLock < 0) p.squashLock = 0;
      } else {
        // 鎖定結束後，回到正常狀態
        p.targetSquash = 1; // 正常高度
      }
      // 0.3秒補間，使用固定時間步長
      const speed = 1 / 0.3; // 每秒補間速度
      const frameSpeed = speed * dt; // 每幀補間量
      if (p.squashAnim < p.targetSquash) {
        p.squashAnim = Math.min(p.squashAnim + frameSpeed, p.targetSquash);
      } else if (p.squashAnim > p.targetSquash) {
        p.squashAnim = Math.max(p.squashAnim - frameSpeed, p.targetSquash);
      }
    }
  }
}

initGame();
</script>
</body>
</html>
